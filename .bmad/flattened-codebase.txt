NaN
BMAD FLATTENED CODEBASE - Generated: 2025-09-01T09:38:59.577Z
Project: mcp-outreach-server
NaN

TABLE OF CONTENTS:


NaN
FILE: .bmad/agent-planner.js
SIZE: 33.92 KB | LINES: 1096
MODIFIED: 2025-09-01T09:37:16.642Z
NaN

#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

class BMadAgentPlanner {
  constructor() {
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.storiesDir = path.join(__dirname, 'stories');
    this.agentsDir = path.join(__dirname, 'agents');
    this.stories = [];

    this.specialistTiers = {
      tier1: {
        name: 'Core Development Specialists',
        description: 'Primary specialists for common development tasks',
        specialists: [
          'Full-Stack Developer',
          'API Integration Specialist',
          'Testing Engineer',
          'DevOps Engineer'
        ]
      },
      tier2: {
        name: 'Domain Specialists',
        description: 'Specialized expertise for specific domains',
        specialists: [
          'MCP Protocol Specialist',
          'Outreach API Expert',
          'Performance Optimization Engineer',
          'Security Specialist',
          'UI/UX Designer'
        ]
      },
      tier3: {
        name: 'Strategic Consultants',
        description: 'High-level architectural and business consultants',
        specialists: [
          'Software Architect',
          'Product Manager',
          'Technical Lead',
          'Business Analyst',
          'Quality Assurance Director'
        ]
      }
    };

    this.executionStrategies = {
      sequential: 'Execute tasks one after another in defined order',
      parallel: 'Execute multiple tasks simultaneously where possible',
      iterative: 'Execute in iterations with feedback loops',
      phased: 'Execute in distinct phases with gates between phases'
    };
  }

  async generatePlans() {
    console.log('ðŸŽ¯ Starting BMAD Agent Planning...');
    console.log(`ðŸ•’ Timestamp: ${this.timestamp}`);

    await this.loadStories();

    const plans = await this.createExecutionPlans();

    const consultationStrategies = await this.createConsultationStrategies();

    const resourcePlans = await this.createResourcePlans(plans);

    await this.writePlans(plans, consultationStrategies, resourcePlans);

    await this.generateMasterRoadmap(plans);

    console.log('âœ… Agent planning complete!');
  }

  async loadStories() {
    try {
      if (!fs.existsSync(this.storiesDir)) {
        console.log('âš ï¸  No stories directory found. Run `npm run bmad:story` first.');
        process.exit(1);
      }

      const files = fs.readdirSync(this.storiesDir).filter(f => f.endsWith('.md') && f !== 'index.md');

      for (const file of files) {
        const content = fs.readFileSync(path.join(this.storiesDir, file), 'utf8');
        const story = this.parseStoryFromMarkdown(content, file);
        if (story) {
          this.stories.push(story);
        }
      }

      console.log(`ðŸ“š Loaded ${this.stories.length} stories for planning`);

    } catch (error) {
      console.error('âŒ Error loading stories:', error.message);
      process.exit(1);
    }
  }

  parseStoryFromMarkdown(content, filename) {
    const lines = content.split('\n');
    const story = {
      filename,
      title: '',
      id: '',
      type: '',
      priority: '',
      category: '',
      estimatedHours: 0,
      acceptanceCriteria: [],
      technicalRequirements: [],
      testingRequirements: []
    };

    const titleMatch = content.match(/^# (.+)$/m);
    if (titleMatch) story.title = titleMatch[1];

    const idMatch = content.match(/\*\*Story ID:\*\* (.+)$/m);
    if (idMatch) story.id = idMatch[1];

    const typeMatch = content.match(/\*\*Type:\*\* (.+)$/m);
    if (typeMatch) story.type = typeMatch[1];

    const priorityMatch = content.match(/\*\*Priority:\*\* (.+)$/m);
    if (priorityMatch) story.priority = priorityMatch[1];

    const categoryMatch = content.match(/\*\*Category:\*\* (.+)$/m);
    if (categoryMatch) story.category = categoryMatch[1];

    const hoursMatch = content.match(/\*\*Estimated Hours:\*\* (.+)$/m);
    if (hoursMatch) story.estimatedHours = parseInt(hoursMatch[1]);

    return story;
  }

  async createExecutionPlans() {
    console.log('ðŸ—ºï¸  Creating execution plans for each story...');

    const plans = [];

    for (const story of this.stories) {
      const plan = await this.createPlanForStory(story);
      plans.push(plan);
    }

    return plans;
  }

  async createPlanForStory(story) {
    const planId = `PLAN-${story.id}`;

    const strategy = this.selectExecutionStrategy(story);

    const tasks = this.breakdownIntoTasks(story);

    const requiredSpecialists = this.identifyRequiredSpecialists(story);

    const timeline = this.estimateTimeline(tasks, story.estimatedHours);

    const dependencies = this.identifyDependencies(story, tasks);

    const risks = this.assessRisks(story, tasks);

    const plan = {
      id: planId,
      storyId: story.id,
      storyTitle: story.title,
      priority: story.priority,
      category: story.category,
      strategy: strategy,
      tasks: tasks,
      requiredSpecialists: requiredSpecialists,
      timeline: timeline,
      dependencies: dependencies,
      risks: risks,
      created: new Date().toISOString()
    };

    return plan;
  }

  selectExecutionStrategy(story) {

    if (story.category === 'bugfix') {
      return {
        type: 'sequential',
        rationale: 'Bug fixes require careful sequential approach to avoid introducing new issues'
      };
    } else if (story.category === 'performance') {
      return {
        type: 'iterative',
        rationale: 'Performance improvements benefit from iterative testing and optimization'
      };
    } else if (story.estimatedHours > 16) {
      return {
        type: 'phased',
        rationale: 'Large stories benefit from phased approach with validation gates'
      };
    } else if (story.category === 'testing') {
      return {
        type: 'parallel',
        rationale: 'Testing tasks can often be executed in parallel'
      };
    } else {
      return {
        type: 'sequential',
        rationale: 'Standard sequential approach for feature development'
      };
    }
  }

  breakdownIntoTasks(story) {
    const tasks = [];

    if (story.type === 'feature') {
      tasks.push(
        {
          id: `${story.id}-RESEARCH`,
          name: 'Research and Design',
          description: 'Research requirements and design solution approach',
          estimatedHours: Math.ceil(story.estimatedHours * 0.2),
          dependencies: [],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-IMPLEMENT`,
          name: 'Core Implementation',
          description: 'Implement the main feature functionality',
          estimatedHours: Math.ceil(story.estimatedHours * 0.5),
          dependencies: [`${story.id}-RESEARCH`],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-TEST`,
          name: 'Testing Implementation',
          description: 'Create and execute comprehensive tests',
          estimatedHours: Math.ceil(story.estimatedHours * 0.2),
          dependencies: [`${story.id}-IMPLEMENT`],
          specialist: 'Testing Engineer'
        },
        {
          id: `${story.id}-REVIEW`,
          name: 'Code Review and Refinement',
          description: 'Peer review and address feedback',
          estimatedHours: Math.ceil(story.estimatedHours * 0.1),
          dependencies: [`${story.id}-TEST`],
          specialist: 'Technical Lead'
        }
      );
    } else if (story.type === 'enhancement') {
      tasks.push(
        {
          id: `${story.id}-ANALYZE`,
          name: 'Performance Analysis',
          description: 'Analyze current performance and identify bottlenecks',
          estimatedHours: Math.ceil(story.estimatedHours * 0.25),
          dependencies: [],
          specialist: 'Performance Optimization Engineer'
        },
        {
          id: `${story.id}-OPTIMIZE`,
          name: 'Implementation Optimization',
          description: 'Implement performance improvements',
          estimatedHours: Math.ceil(story.estimatedHours * 0.5),
          dependencies: [`${story.id}-ANALYZE`],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-VALIDATE`,
          name: 'Performance Validation',
          description: 'Validate performance improvements meet requirements',
          estimatedHours: Math.ceil(story.estimatedHours * 0.25),
          dependencies: [`${story.id}-OPTIMIZE`],
          specialist: 'Performance Optimization Engineer'
        }
      );
    } else if (story.type === 'bugfix') {
      tasks.push(
        {
          id: `${story.id}-REPRODUCE`,
          name: 'Bug Reproduction',
          description: 'Reproduce and fully understand the bug',
          estimatedHours: Math.ceil(story.estimatedHours * 0.3),
          dependencies: [],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-FIX`,
          name: 'Bug Fix Implementation',
          description: 'Implement the fix for the identified bug',
          estimatedHours: Math.ceil(story.estimatedHours * 0.4),
          dependencies: [`${story.id}-REPRODUCE`],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-VERIFY`,
          name: 'Fix Verification',
          description: 'Verify fix resolves issue without side effects',
          estimatedHours: Math.ceil(story.estimatedHours * 0.3),
          dependencies: [`${story.id}-FIX`],
          specialist: 'Testing Engineer'
        }
      );
    } else if (story.type === 'technical') {
      tasks.push(
        {
          id: `${story.id}-REFACTOR`,
          name: 'Code Refactoring',
          description: 'Refactor code to address technical debt',
          estimatedHours: Math.ceil(story.estimatedHours * 0.6),
          dependencies: [],
          specialist: 'Full-Stack Developer'
        },
        {
          id: `${story.id}-VALIDATE`,
          name: 'Regression Testing',
          description: 'Ensure refactoring doesn\'t break existing functionality',
          estimatedHours: Math.ceil(story.estimatedHours * 0.4),
          dependencies: [`${story.id}-REFACTOR`],
          specialist: 'Testing Engineer'
        }
      );
    }

    return tasks;
  }

  identifyRequiredSpecialists(story) {
    const specialists = new Set();

    specialists.add('Full-Stack Developer');

    switch (story.category) {
      case 'reliability':
      case 'monitoring':
        specialists.add('DevOps Engineer');
        specialists.add('MCP Protocol Specialist');
        break;
      case 'performance':
        specialists.add('Performance Optimization Engineer');
        break;
      case 'testing':
        specialists.add('Testing Engineer');
        specialists.add('Quality Assurance Director');
        break;
      case 'documentation':
        specialists.add('Technical Writer');
        break;
      case 'security':
        specialists.add('Security Specialist');
        break;
    }

    if (story.title.toLowerCase().includes('api')) {
      specialists.add('API Integration Specialist');
    }
    if (story.title.toLowerCase().includes('outreach')) {
      specialists.add('Outreach API Expert');
    }
    if (story.title.toLowerCase().includes('mcp')) {
      specialists.add('MCP Protocol Specialist');
    }

    if (story.estimatedHours > 16) {
      specialists.add('Technical Lead');
      specialists.add('Software Architect');
    }

    return Array.from(specialists);
  }

  estimateTimeline(tasks, totalHours) {
    const workingHoursPerDay = 6;
    const totalDays = Math.ceil(totalHours / workingHoursPerDay);

    const startDate = new Date();
    const endDate = new Date(startDate);
    endDate.setDate(startDate.getDate() + totalDays);

    return {
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0],
      totalDays: totalDays,
      totalHours: totalHours,
      workingHoursPerDay: workingHoursPerDay
    };
  }

  identifyDependencies(story, tasks) {
    const dependencies = [];

    if (story.category === 'performance') {
      dependencies.push({
        type: 'external',
        description: 'Baseline performance metrics must be established',
        impact: 'Cannot validate improvements without baseline'
      });
    }

    if (story.category === 'testing') {
      dependencies.push({
        type: 'external',
        description: 'Core functionality must be stable',
        impact: 'Testing framework changes may affect existing tests'
      });
    }

    if (story.title.toLowerCase().includes('api')) {
      dependencies.push({
        type: 'external',
        description: 'External API must be accessible and stable',
        impact: 'API changes or downtime will block implementation'
      });
    }

    return dependencies;
  }

  assessRisks(story, tasks) {
    const risks = [];

    if (story.category === 'performance') {
      risks.push({
        type: 'technical',
        description: 'Performance improvements may introduce new bugs',
        probability: 'medium',
        impact: 'high',
        mitigation: 'Comprehensive regression testing and gradual rollout'
      });
    }

    if (story.category === 'reliability') {
      risks.push({
        type: 'technical',
        description: 'Changes to error handling may mask other issues',
        probability: 'low',
        impact: 'high',
        mitigation: 'Thorough testing with error injection scenarios'
      });
    }

    if (story.estimatedHours > 20) {
      risks.push({
        type: 'resource',
        description: 'Large story may exceed time estimates',
        probability: 'medium',
        impact: 'medium',
        mitigation: 'Break into smaller deliverable chunks with regular checkpoints'
      });
    }

    if (story.title.toLowerCase().includes('api')) {
      risks.push({
        type: 'external',
        description: 'External API changes may break integration',
        probability: 'low',
        impact: 'high',
        mitigation: 'Monitor API documentation and implement robust error handling'
      });
    }

    return risks;
  }

  async createConsultationStrategies() {
    console.log('ðŸ‘¥ Creating specialist consultation strategies...');

    const strategies = {};

    const specialistNeeds = this.analyzeSpecialistNeeds();

    for (const [specialist, needs] of Object.entries(specialistNeeds)) {
      strategies[specialist] = this.createConsultationStrategy(specialist, needs);
    }

    return strategies;
  }

  analyzeSpecialistNeeds() {
    const needs = {};

    this.stories.forEach(story => {
      const requiredSpecialists = this.identifyRequiredSpecialists(story);

      requiredSpecialists.forEach(specialist => {
        if (!needs[specialist]) {
          needs[specialist] = {
            stories: [],
            totalHours: 0,
            priorities: { high: 0, medium: 0, low: 0 },
            categories: {}
          };
        }

        needs[specialist].stories.push(story);
        needs[specialist].totalHours += story.estimatedHours;
        needs[specialist].priorities[story.priority]++;
        needs[specialist].categories[story.category] = (needs[specialist].categories[story.category] || 0) + 1;
      });
    });

    return needs;
  }

  createConsultationStrategy(specialist, needs) {
    const tier = this.getSpecialistTier(specialist);

    return {
      specialist: specialist,
      tier: tier,
      totalEngagement: needs.totalHours,
      storiesCount: needs.stories.length,
      consultationApproach: this.determineConsultationApproach(specialist, needs),
      scheduleRecommendation: this.createScheduleRecommendation(specialist, needs),
      deliverables: this.defineConsultationDeliverables(specialist, needs),
      success_criteria: this.defineSuccessCriteria(specialist, needs)
    };
  }

  getSpecialistTier(specialist) {
    for (const [tier, info] of Object.entries(this.specialistTiers)) {
      if (info.specialists.includes(specialist)) {
        return tier;
      }
    }
    return 'tier1';
  }

  determineConsultationApproach(specialist, needs) {
    if (needs.totalHours > 40) {
      return 'embedded';
    } else if (needs.priorities.high > 2) {
      return 'intensive';
    } else {
      return 'advisory';
    }
  }

  createScheduleRecommendation(specialist, needs) {
    const approach = this.determineConsultationApproach(specialist, needs);

    switch (approach) {
      case 'embedded':
        return {
          frequency: 'daily',
          duration: '2-4 hours per day',
          totalWeeks: Math.ceil(needs.totalHours / 20),
          milestones: 'Weekly progress reviews'
        };
      case 'intensive':
        return {
          frequency: 'twice weekly',
          duration: '2-3 hour sessions',
          totalWeeks: Math.ceil(needs.totalHours / 10),
          milestones: 'Bi-weekly deliverable reviews'
        };
      case 'advisory':
        return {
          frequency: 'weekly',
          duration: '1-2 hour sessions',
          totalWeeks: Math.ceil(needs.totalHours / 5),
          milestones: 'Monthly strategic reviews'
        };
      default:
        return {
          frequency: 'as needed',
          duration: 'variable',
          totalWeeks: 'flexible',
          milestones: 'deliverable-driven'
        };
    }
  }

  defineConsultationDeliverables(specialist, needs) {
    const deliverables = [];

    switch (specialist) {
      case 'Software Architect':
        deliverables.push('Architecture review and recommendations');
        deliverables.push('Technical design documentation');
        deliverables.push('Integration strategy plan');
        break;
      case 'Performance Optimization Engineer':
        deliverables.push('Performance baseline analysis');
        deliverables.push('Optimization implementation plan');
        deliverables.push('Performance validation report');
        break;
      case 'Testing Engineer':
        deliverables.push('Test strategy and plan');
        deliverables.push('Test automation framework');
        deliverables.push('Test coverage report');
        break;
      default:
        deliverables.push('Requirements analysis');
        deliverables.push('Implementation guidance');
        deliverables.push('Quality review and recommendations');
    }

    return deliverables;
  }

  defineSuccessCriteria(specialist, needs) {
    return [
      'All assigned stories meet acceptance criteria',
      'Deliverables are completed on time and within scope',
      'Knowledge transfer is completed to development team',
      'Quality standards are met or exceeded',
      'No critical issues introduced in specialist\'s area'
    ];
  }

  async createResourcePlans(plans) {
    console.log('ðŸ“Š Creating resource allocation plans...');

    const resourcePlan = {
      totalProjects: plans.length,
      totalEstimatedHours: plans.reduce((sum, plan) => sum + plan.timeline.totalHours, 0),
      priorityBreakdown: this.calculatePriorityBreakdown(plans),
      specialistWorkload: this.calculateSpecialistWorkload(plans),
      timelineAnalysis: this.analyzeTimelines(plans),
      resourceRecommendations: this.generateResourceRecommendations(plans)
    };

    return resourcePlan;
  }

  calculatePriorityBreakdown(plans) {
    return plans.reduce((breakdown, plan) => {
      breakdown[plan.priority] = (breakdown[plan.priority] || 0) + 1;
      return breakdown;
    }, {});
  }

  calculateSpecialistWorkload(plans) {
    const workload = {};

    plans.forEach(plan => {
      plan.requiredSpecialists.forEach(specialist => {
        if (!workload[specialist]) {
          workload[specialist] = {
            projectCount: 0,
            totalHours: 0,
            priorities: { high: 0, medium: 0, low: 0 }
          };
        }

        workload[specialist].projectCount++;
        workload[specialist].totalHours += plan.timeline.totalHours;
        workload[specialist].priorities[plan.priority]++;
      });
    });

    return workload;
  }

  analyzeTimelines(plans) {
    const timelines = plans.map(plan => plan.timeline.totalDays);

    return {
      shortestProject: Math.min(...timelines),
      longestProject: Math.max(...timelines),
      averageProject: Math.round(timelines.reduce((sum, days) => sum + days, 0) / timelines.length),
      totalSequentialDays: timelines.reduce((sum, days) => sum + days, 0),
      parallelExecutionDays: Math.max(...timelines)
    };
  }

  generateResourceRecommendations(plans) {
    const recommendations = [];

    const highPriorityCount = plans.filter(p => p.priority === 'high').length;
    if (highPriorityCount > 3) {
      recommendations.push({
        type: 'prioritization',
        message: `${highPriorityCount} high-priority stories detected. Consider staggered execution.`,
        action: 'Create execution phases to prevent resource conflicts'
      });
    }

    const specialistWorkload = this.calculateSpecialistWorkload(plans);
    Object.entries(specialistWorkload).forEach(([specialist, workload]) => {
      if (workload.totalHours > 80) {
        recommendations.push({
          type: 'capacity',
          message: `${specialist} has ${workload.totalHours}h workload across ${workload.projectCount} projects`,
          action: 'Consider additional specialists or extended timeline'
        });
      }
    });

    const parallelizable = plans.filter(plan => plan.strategy.type === 'parallel');
    if (parallelizable.length > 1) {
      recommendations.push({
        type: 'optimization',
        message: `${parallelizable.length} stories can be executed in parallel`,
        action: 'Schedule parallel execution to reduce overall timeline'
      });
    }

    return recommendations;
  }

  async writePlans(plans, consultationStrategies, resourcePlans) {
    console.log('ðŸ’¾ Writing execution plans to files...');

    fs.mkdirSync(this.agentsDir, { recursive: true });

    for (const plan of plans) {
      const filename = `execution-plan-${plan.storyId}.md`;
      const filepath = path.join(this.agentsDir, filename);

      const content = this.generatePlanMarkdown(plan);
      fs.writeFileSync(filepath, content, 'utf8');

      console.log(`ðŸ“„ Created: ${filename}`);
    }

    const consultationContent = this.generateConsultationMarkdown(consultationStrategies);
    fs.writeFileSync(path.join(this.agentsDir, 'specialist-consultation-strategies.md'), consultationContent, 'utf8');

    const resourceContent = this.generateResourcePlanMarkdown(resourcePlans);
    fs.writeFileSync(path.join(this.agentsDir, 'resource-allocation-plan.md'), resourceContent, 'utf8');

    console.log(`ðŸ“š Created ${plans.length} execution plans and resource strategies`);
  }

  generatePlanMarkdown(plan) {
    return `# Execution Plan: ${plan.storyTitle}

**Plan ID:** ${plan.id}
**Story ID:** ${plan.storyId}
**Priority:** ${plan.priority}
**Category:** ${plan.category}
**Created:** ${new Date(plan.created).toLocaleDateString()}

## Execution Strategy

**Type:** ${plan.strategy.type}
**Rationale:** ${plan.strategy.rationale}

## Task Breakdown

${plan.tasks.map(task => `
### ${task.name}
- **Task ID:** ${task.id}
- **Estimated Hours:** ${task.estimatedHours}
- **Specialist:** ${task.specialist}
- **Dependencies:** ${task.dependencies.length ? task.dependencies.join(', ') : 'None'}
- **Description:** ${task.description}
`).join('\n')}

## Required Specialists

${plan.requiredSpecialists.map(specialist => `- ${specialist}`).join('\n')}

## Timeline

- **Start Date:** ${plan.timeline.startDate}
- **End Date:** ${plan.timeline.endDate}
- **Total Days:** ${plan.timeline.totalDays}
- **Total Hours:** ${plan.timeline.totalHours}
- **Working Hours/Day:** ${plan.timeline.workingHoursPerDay}

## Dependencies

${plan.dependencies.length ? plan.dependencies.map(dep => `
### ${dep.type} Dependency
- **Description:** ${dep.description}
- **Impact:** ${dep.impact}
`).join('\n') : 'No external dependencies identified.'}

## Risk Assessment

${plan.risks.map(risk => `
### ${risk.type} Risk: ${risk.description}
- **Probability:** ${risk.probability}
- **Impact:** ${risk.impact}
- **Mitigation:** ${risk.mitigation}
`).join('\n')}

---

*Generated by BMAD Agent Planner on ${new Date().toISOString()}*
`;
  }

  generateConsultationMarkdown(strategies) {
    let content = `# Specialist Consultation Strategies

Generated: ${new Date().toISOString()}

## Overview

This document outlines consultation strategies for each required specialist across all planned stories.

`;

    Object.values(strategies).forEach(strategy => {
      content += `
## ${strategy.specialist}

**Tier:** ${strategy.tier}
**Total Engagement:** ${strategy.totalEngagement} hours
**Stories Count:** ${strategy.storiesCount}
**Approach:** ${strategy.consultationApproach}

### Schedule Recommendation
- **Frequency:** ${strategy.scheduleRecommendation.frequency}
- **Duration:** ${strategy.scheduleRecommendation.duration}
- **Total Weeks:** ${strategy.scheduleRecommendation.totalWeeks}
- **Milestones:** ${strategy.scheduleRecommendation.milestones}

### Expected Deliverables
${strategy.deliverables.map(d => `- ${d}`).join('\n')}

### Success Criteria
${strategy.success_criteria.map(c => `- ${c}`).join('\n')}

---
`;
    });

    return content;
  }

  generateResourcePlanMarkdown(resourcePlan) {
    return `# Resource Allocation Plan

Generated: ${new Date().toISOString()}

## Summary

- **Total Projects:** ${resourcePlan.totalProjects}
- **Total Estimated Hours:** ${resourcePlan.totalEstimatedHours}

## Priority Breakdown

${Object.entries(resourcePlan.priorityBreakdown).map(([priority, count]) =>
  `- **${priority}:** ${count} projects`
).join('\n')}

## Timeline Analysis

- **Shortest Project:** ${resourcePlan.timelineAnalysis.shortestProject} days
- **Longest Project:** ${resourcePlan.timelineAnalysis.longestProject} days
- **Average Project:** ${resourcePlan.timelineAnalysis.averageProject} days
- **Sequential Execution:** ${resourcePlan.timelineAnalysis.totalSequentialDays} days
- **Parallel Execution:** ${resourcePlan.timelineAnalysis.parallelExecutionDays} days

## Specialist Workload

${Object.entries(resourcePlan.specialistWorkload).map(([specialist, workload]) => `
### ${specialist}
- **Projects:** ${workload.projectCount}
- **Total Hours:** ${workload.totalHours}
- **High Priority:** ${workload.priorities.high}
- **Medium Priority:** ${workload.priorities.medium}
- **Low Priority:** ${workload.priorities.low}
`).join('\n')}

## Recommendations

${resourcePlan.resourceRecommendations.map(rec => `
### ${rec.type}: ${rec.message}
**Action:** ${rec.action}
`).join('\n')}

---

*Generated by BMAD Agent Planner*
`;
  }

  async generateMasterRoadmap(plans) {
    console.log('ðŸ—ºï¸  Generating master execution roadmap...');

    const sortedPlans = this.sortPlansByExecution(plans);

    const roadmap = {
      phases: this.createExecutionPhases(sortedPlans),
      milestones: this.defineMilestones(sortedPlans),
      criticalPath: this.identifyCriticalPath(sortedPlans),
      resourceTimeline: this.createResourceTimeline(sortedPlans)
    };

    const content = this.generateRoadmapMarkdown(roadmap);
    fs.writeFileSync(path.join(this.agentsDir, 'master-execution-roadmap.md'), content, 'utf8');

    this.displayRoadmapSummary(roadmap);
  }

  sortPlansByExecution(plans) {

    return plans.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];

      if (priorityDiff !== 0) return priorityDiff;

      return a.timeline.totalHours - b.timeline.totalHours;
    });
  }

  createExecutionPhases(sortedPlans) {
    const phases = [
      { name: 'Phase 1: Critical Foundation', plans: [] },
      { name: 'Phase 2: Core Features', plans: [] },
      { name: 'Phase 3: Enhancements', plans: [] },
      { name: 'Phase 4: Optimization', plans: [] }
    ];

    sortedPlans.forEach(plan => {
      if (plan.priority === 'high' && plan.category === 'bugfix') {
        phases[0].plans.push(plan);
      } else if (plan.priority === 'high') {
        phases[1].plans.push(plan);
      } else if (plan.priority === 'medium') {
        phases[2].plans.push(plan);
      } else {
        phases[3].plans.push(plan);
      }
    });

    return phases;
  }

  defineMilestones(sortedPlans) {
    const milestones = [];
    let cumulativeHours = 0;

    sortedPlans.forEach((plan, index) => {
      cumulativeHours += plan.timeline.totalHours;

      if (index % 3 === 2 || index === sortedPlans.length - 1) {
        milestones.push({
          name: `Milestone ${Math.floor(index / 3) + 1}`,
          completedProjects: index + 1,
          cumulativeHours: cumulativeHours,
          description: `Complete ${index + 1} of ${sortedPlans.length} planned stories`
        });
      }
    });

    return milestones;
  }

  identifyCriticalPath(sortedPlans) {

    return sortedPlans.filter(plan =>
      plan.priority === 'high' ||
      plan.category === 'bugfix' ||
      plan.dependencies.some(dep => dep.type === 'external')
    );
  }

  createResourceTimeline(sortedPlans) {
    const timeline = {};
    let currentWeek = 1;

    sortedPlans.forEach(plan => {
      const weeks = Math.ceil(plan.timeline.totalDays / 7);

      plan.requiredSpecialists.forEach(specialist => {
        if (!timeline[specialist]) {
          timeline[specialist] = [];
        }

        timeline[specialist].push({
          weeks: `Week ${currentWeek}-${currentWeek + weeks - 1}`,
          project: plan.storyTitle,
          priority: plan.priority
        });
      });

      currentWeek += weeks;
    });

    return timeline;
  }

  generateRoadmapMarkdown(roadmap) {
    return `# Master Execution Roadmap

Generated: ${new Date().toISOString()}

## Execution Phases

${roadmap.phases.map(phase => `
### ${phase.name}
${phase.plans.length ? phase.plans.map(plan =>
  `- **${plan.storyTitle}** (${plan.timeline.totalHours}h, ${plan.priority} priority)`
).join('\n') : '- No projects assigned to this phase'}
`).join('\n')}

## Milestones

${roadmap.milestones.map(milestone => `
### ${milestone.name}
- **Completed Projects:** ${milestone.completedProjects}
- **Cumulative Hours:** ${milestone.cumulativeHours}
- **Description:** ${milestone.description}
`).join('\n')}

## Critical Path

${roadmap.criticalPath.map(plan => `
### ${plan.storyTitle}
- **Priority:** ${plan.priority}
- **Category:** ${plan.category}
- **Hours:** ${plan.timeline.totalHours}
- **Rationale:** Critical for project success
`).join('\n')}

## Resource Timeline

${Object.entries(roadmap.resourceTimeline).map(([specialist, assignments]) => `
### ${specialist}
${assignments.map(assignment =>
  `- **${assignment.weeks}:** ${assignment.project} (${assignment.priority})`
).join('\n')}
`).join('\n')}

---

*Generated by BMAD Agent Planner*
`;
  }

  displayRoadmapSummary(roadmap) {
    console.log('\nðŸŽ¯ EXECUTION PLANNING COMPLETE!');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log(`ðŸ“‹ Total execution plans: ${this.stories.length}`);
    console.log(`ðŸš© Critical path items: ${roadmap.criticalPath.length}`);
    console.log(`ðŸŽ¯ Execution phases: ${roadmap.phases.length}`);
    console.log(`ðŸ“ Milestones defined: ${roadmap.milestones.length}`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('\nðŸ’¡ Next steps:');
    console.log('   1. Review execution plans in .bmad/agents/');
    console.log('   2. Begin with Phase 1 critical foundation items');
    console.log('   3. Engage specialists according to consultation strategies');
    console.log('   4. Use npm run bmad:deploy when ready for deployment');
  }
}

if (import.meta.url === `file:
  const planner = new BMadAgentPlanner();
  planner.generatePlans().catch(error => {
    console.error('ðŸ’¥ Agent planning failed:', error);
    process.exit(1);
  });
}

export default BMadAgentPlanner;

NaN
FILE: .bmad/codebase-flattener.js
SIZE: 8.79 KB | LINES: 294
MODIFIED: 2025-09-01T09:33:40.233Z
NaN

#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

const config = {
  outputFile: path.join(projectRoot, '.bmad', 'flattened-codebase.txt'),
  includePatterns: [
    /\.(js|ts|jsx|tsx|json|md|yml|yaml)$/,
    /^package\.json$/,
    /^\.env\.example$/,
    /^README\.md$/,
    /^tsconfig\.json$/
  ],
  excludePatterns: [
    /node_modules/,
    /\.git/,
    /dist/,
    /build/,
    /coverage/,
    /\.nyc_output/,
    /\.next/,
    /\.cache/,
    /\.bmad\/flattened-codebase\.txt$/,
    /\.log$/,
    /\.lock$/,
    /package-lock\.json$/,
    /yarn\.lock$/
  ],
  maxFileSize: 1024 * 1024,
  removeComments: true,
  optimizeWhitespace: true
};

class CodebaseFlattener {
  constructor() {
    this.stats = {
      filesProcessed: 0,
      linesProcessed: 0,
      bytesProcessed: 0,
      commentsRemoved: 0,
      whitespaceOptimized: 0
    };
    this.outputLines = [];
    this.startTime = Date.now();
  }

  async flatten() {
    console.log('ðŸ”„ Starting codebase flattening...');
    console.log(`ðŸ“‚ Project root: ${projectRoot}`);

    this.addHeader();

    await this.processDirectory(projectRoot);

    await this.writeOutput();

    this.showStats();
  }

  addHeader() {
    const timestamp = new Date().toISOString();
    this.outputLines.push(
      '=' * 80,
      `BMAD FLATTENED CODEBASE - Generated: ${timestamp}`,
      `Project: ${path.basename(projectRoot)}`,
      '=' * 80,
      '',
      'TABLE OF CONTENTS:',
      ''
    );
  }

  async processDirectory(dirPath, relativePath = '') {
    try {
      const items = fs.readdirSync(dirPath);

      for (const item of items) {
        const fullPath = path.join(dirPath, item);
        const relativeItemPath = path.join(relativePath, item);

        if (this.shouldExclude(relativeItemPath, fullPath)) {
          continue;
        }

        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          await this.processDirectory(fullPath, relativeItemPath);
        } else if (stat.isFile() && this.shouldInclude(item)) {
          await this.processFile(fullPath, relativeItemPath);
        }
      }
    } catch (error) {
      console.error(`âŒ Error processing directory ${dirPath}:`, error.message);
    }
  }

  shouldExclude(relativePath, fullPath) {
    return config.excludePatterns.some(pattern => pattern.test(relativePath));
  }

  shouldInclude(filename) {
    return config.includePatterns.some(pattern => pattern.test(filename));
  }

  async processFile(fullPath, relativePath) {
    try {
      const stat = fs.statSync(fullPath);

      if (stat.size > config.maxFileSize) {
        console.log(`â­ï¸  Skipping large file: ${relativePath} (${this.formatBytes(stat.size)})`);
        return;
      }

      const content = fs.readFileSync(fullPath, 'utf8');
      const lines = content.split('\n');

      this.stats.filesProcessed++;
      this.stats.linesProcessed += lines.length;
      this.stats.bytesProcessed += stat.size;

      this.outputLines.push(
        '',
        'â”€' * 80,
        `FILE: ${relativePath}`,
        `SIZE: ${this.formatBytes(stat.size)} | LINES: ${lines.length}`,
        `MODIFIED: ${stat.mtime.toISOString()}`,
        'â”€' * 80,
        ''
      );

      const processedContent = this.processFileContent(content, fullPath);
      this.outputLines.push(processedContent);

      console.log(`âœ… Processed: ${relativePath}`);

    } catch (error) {
      console.error(`âŒ Error processing file ${relativePath}:`, error.message);
    }
  }

  processFileContent(content, filePath) {
    let processed = content;
    const ext = path.extname(filePath).toLowerCase();

    if (config.removeComments) {
      processed = this.removeComments(processed, ext);
    }

    if (config.optimizeWhitespace && !['.md', '.txt'].includes(ext)) {
      processed = this.optimizeWhitespace(processed);
    }

    return processed;
  }

  removeComments(content, fileExt) {
    const beforeLines = content.split('\n').length;
    let processed = content;

    switch (fileExt) {
      case '.js':
      case '.ts':
      case '.jsx':
      case '.tsx':

        processed = processed.replace(/\/\/.*$/gm, '');

        processed = processed.replace(/\/\*(?!\*)([\s\S]*?)\*\
        break;

      case '.json':

        break;

      case '.md':

        break;

      case '.yml':
      case '.yaml':

        processed = processed.replace(/^\s*#.*$/gm, '');
        break;
    }

    const afterLines = processed.split('\n').length;
    this.stats.commentsRemoved += (beforeLines - afterLines);

    return processed;
  }

  optimizeWhitespace(content) {
    const beforeLength = content.length;

    let processed = content.replace(/[ \t]+$/gm, '');

    processed = processed.replace(/\n{3,}/g, '\n\n');

    processed = processed.replace(/^\n+/, '').replace(/\n+$/, '\n');

    const afterLength = processed.length;
    this.stats.whitespaceOptimized += (beforeLength - afterLength);

    return processed;
  }

  async writeOutput() {
    const content = this.outputLines.join('\n');

    const footer = [
      '',
      '=' * 80,
      'FLATTENING STATISTICS',
      '=' * 80,
      `Files processed: ${this.stats.filesProcessed}`,
      `Lines processed: ${this.stats.linesProcessed.toLocaleString()}`,
      `Bytes processed: ${this.formatBytes(this.stats.bytesProcessed)}`,
      `Comments removed: ${this.stats.commentsRemoved.toLocaleString()} lines`,
      `Whitespace optimized: ${this.formatBytes(this.stats.whitespaceOptimized)}`,
      `Generated: ${new Date().toISOString()}`,
      `Processing time: ${Date.now() - this.startTime}ms`,
      '=' * 80
    ].join('\n');

    const finalContent = content + '\n' + footer;

    fs.writeFileSync(config.outputFile, finalContent, 'utf8');
    console.log(`\nðŸ“ Flattened codebase written to: ${config.outputFile}`);
    console.log(`ðŸ“Š Output size: ${this.formatBytes(finalContent.length)}`);
  }

  showStats() {
    const duration = Date.now() - this.startTime;

    console.log('\nðŸŽ¯ FLATTENING COMPLETE!');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log(`ðŸ“Š Files processed: ${this.stats.filesProcessed}`);
    console.log(`ðŸ“ Lines processed: ${this.stats.linesProcessed.toLocaleString()}`);
    console.log(`ðŸ’¾ Data processed: ${this.formatBytes(this.stats.bytesProcessed)}`);
    console.log(`ðŸ§¹ Comments removed: ${this.stats.commentsRemoved.toLocaleString()} lines`);
    console.log(`âœ¨ Whitespace saved: ${this.formatBytes(this.stats.whitespaceOptimized)}`);
    console.log(`â±ï¸  Processing time: ${duration}ms`);
    console.log(`ðŸ“ Output: ${path.relative(process.cwd(), config.outputFile)}`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('\nðŸ’¡ Next steps:');
    console.log('   1. npm run bmad:story  - Generate development stories');
    console.log('   2. npm run bmad:plan   - Create execution strategy');
    console.log('   3. Implement features with Claude Code');
    console.log('   4. npm run bmad:deploy - Deploy with context');
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}

if (import.meta.url === `file:
  const flattener = new CodebaseFlattener();
  flattener.flatten().catch(error => {
    console.error('ðŸ’¥ Flattening failed:', error);
    process.exit(1);
  });
}

export default CodebaseFlattener;

NaN
FILE: .bmad/deploy-with-context.js
SIZE: 22.42 KB | LINES: 707
MODIFIED: 2025-09-01T09:38:49.339Z
NaN

#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { spawn, exec } from 'child_process';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

class BMadContextualDeployment {
  constructor() {
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.deploymentId = `DEPLOY-${this.timestamp}`;
    this.logFile = path.join(__dirname, 'deployment-logs', `${this.deploymentId}.log`);
    this.contextFile = path.join(__dirname, 'deployment-context', `${this.deploymentId}-context.json`);

    this.deploymentContext = {
      id: this.deploymentId,
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'production',
      platform: 'railway',
      projectRoot: projectRoot,
      gitCommit: null,
      gitBranch: null,
      packageVersion: null,
      environmentVariables: [],
      preDeploymentHealth: null,
      stories: [],
      plans: [],
      rollbackStrategy: null
    };

    this.checks = {
      git: false,
      dependencies: false,
      tests: false,
      build: false,
      environment: false,
      health: false
    };
  }

  async deploy() {
    console.log('ðŸš€ Starting BMAD Contextual Deployment...');
    console.log(`ðŸ“‹ Deployment ID: ${this.deploymentId}`);

    await this.initializeDeployment();

    await this.runPreDeploymentChecks();

    await this.gatherDeploymentContext();

    await this.deployToRailway();

    await this.runPostDeploymentValidation();

    await this.generateDeploymentReport();

    console.log('âœ… Contextual deployment complete!');
  }

  async initializeDeployment() {
    console.log('ðŸ“ Initializing deployment context preservation...');

    const logsDir = path.dirname(this.logFile);
    const contextDir = path.dirname(this.contextFile);

    fs.mkdirSync(logsDir, { recursive: true });
    fs.mkdirSync(contextDir, { recursive: true });

    this.startLogging();

    this.log('info', 'BMAD Contextual Deployment initialized');
    this.log('info', `Deployment ID: ${this.deploymentId}`);
  }

  startLogging() {
    this.logStream = fs.createWriteStream(this.logFile, { flags: 'a' });

    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;

    console.log = (...args) => {
      const message = args.join(' ');
      this.log('info', message);
      originalConsoleLog(...args);
    };

    console.error = (...args) => {
      const message = args.join(' ');
      this.log('error', message);
      originalConsoleError(...args);
    };
  }

  log(level, message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}\n`;

    if (this.logStream) {
      this.logStream.write(logEntry);
    }
  }

  async runPreDeploymentChecks() {
    console.log('ðŸ” Running pre-deployment validation checks...');

    const checks = [
      { name: 'git', fn: this.checkGitStatus },
      { name: 'dependencies', fn: this.checkDependencies },
      { name: 'tests', fn: this.runTests },
      { name: 'build', fn: this.runBuild },
      { name: 'environment', fn: this.checkEnvironment },
      { name: 'health', fn: this.checkCurrentHealth }
    ];

    for (const check of checks) {
      try {
        console.log(`  â³ ${check.name}...`);
        await check.fn.call(this);
        this.checks[check.name] = true;
        console.log(`  âœ… ${check.name} passed`);
      } catch (error) {
        console.error(`  âŒ ${check.name} failed:`, error.message);
        this.log('error', `Pre-deployment check failed: ${check.name} - ${error.message}`);

        if (['tests', 'build'].includes(check.name)) {
          throw new Error(`Critical check failed: ${check.name}`);
        }
      }
    }
  }

  async checkGitStatus() {
    return new Promise((resolve, reject) => {
      exec('git status --porcelain', { cwd: projectRoot }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Git check failed: ${error.message}`));
          return;
        }

        if (stdout.trim()) {
          this.log('warn', 'Uncommitted changes detected');
          console.log('  âš ï¸  Uncommitted changes detected');
        }

        exec('git rev-parse HEAD', { cwd: projectRoot }, (err, commitHash) => {
          if (!err) {
            this.deploymentContext.gitCommit = commitHash.trim();
          }

          exec('git rev-parse --abbrev-ref HEAD', { cwd: projectRoot }, (err, branch) => {
            if (!err) {
              this.deploymentContext.gitBranch = branch.trim();
            }
            resolve();
          });
        });
      });
    });
  }

  async checkDependencies() {
    return new Promise((resolve, reject) => {
      exec('npm audit --audit-level moderate', { cwd: projectRoot }, (error, stdout, stderr) => {
        if (error && error.code !== 0) {
          this.log('warn', 'Dependency vulnerabilities detected');
          console.log('  âš ï¸  Dependency vulnerabilities detected');
        }

        exec('npm outdated --json', { cwd: projectRoot }, (err, outdatedOutput) => {
          if (outdatedOutput) {
            try {
              const outdated = JSON.parse(outdatedOutput);
              const count = Object.keys(outdated).length;
              if (count > 0) {
                this.log('info', `${count} outdated dependencies detected`);
              }
            } catch (e) {

            }
          }
          resolve();
        });
      });
    });
  }

  async runTests() {
    return new Promise((resolve, reject) => {

      const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));

      if (!packageJson.scripts?.test) {
        this.log('warn', 'No test script found, skipping tests');
        resolve();
        return;
      }

      exec('npm test', { cwd: projectRoot }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Tests failed: ${stderr}`));
          return;
        }

        this.log('info', 'All tests passed');
        resolve();
      });
    });
  }

  async runBuild() {
    return new Promise((resolve, reject) => {
      const packageJson = JSON.parse(fs.readFileSync(path.join(projectRoot, 'package.json'), 'utf8'));
      this.deploymentContext.packageVersion = packageJson.version;

      if (!packageJson.scripts?.build) {
        this.log('info', 'No build script found, skipping build');
        resolve();
        return;
      }

      exec('npm run build', { cwd: projectRoot }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Build failed: ${stderr}`));
          return;
        }

        this.log('info', 'Build completed successfully');
        resolve();
      });
    });
  }

  async checkEnvironment() {
    const requiredEnvVars = [
      'OUTREACH_CLIENT_ID',
      'OUTREACH_CLIENT_SECRET',
      'OUTREACH_REFRESH_TOKEN'
    ];

    const missingVars = [];

    requiredEnvVars.forEach(varName => {
      if (!process.env[varName]) {
        missingVars.push(varName);
      } else {
        this.deploymentContext.environmentVariables.push({
          name: varName,
          set: true,
          length: process.env[varName].length
        });
      }
    });

    if (missingVars.length > 0) {
      throw new Error(`Missing environment variables: ${missingVars.join(', ')}`);
    }

    this.log('info', `Environment variables validated: ${requiredEnvVars.length} variables set`);
  }

  async checkCurrentHealth() {

    const criticalFiles = [
      'package.json',
      'server.js',
      'src/index.js',
      'outreach-proxy.cjs'
    ];

    const missingFiles = [];

    criticalFiles.forEach(file => {
      if (!fs.existsSync(path.join(projectRoot, file))) {
        missingFiles.push(file);
      }
    });

    if (missingFiles.length > 0) {
      throw new Error(`Missing critical files: ${missingFiles.join(', ')}`);
    }

    this.deploymentContext.preDeploymentHealth = {
      criticalFiles: criticalFiles.length,
      allPresent: true,
      timestamp: new Date().toISOString()
    };
  }

  async gatherDeploymentContext() {
    console.log('ðŸ“Š Gathering comprehensive deployment context...');

    await this.loadBMADContext();

    await this.captureSystemInfo();

    await this.createRollbackStrategy();

    fs.writeFileSync(this.contextFile, JSON.stringify(this.deploymentContext, null, 2));

    this.log('info', 'Deployment context captured and saved');
  }

  async loadBMADContext() {
    try {

      const storiesDir = path.join(__dirname, 'stories');
      if (fs.existsSync(storiesDir)) {
        const storyFiles = fs.readdirSync(storiesDir).filter(f => f.endsWith('.md') && f !== 'index.md');
        this.deploymentContext.stories = storyFiles.map(file => ({
          file: file,
          size: fs.statSync(path.join(storiesDir, file)).size,
          modified: fs.statSync(path.join(storiesDir, file)).mtime.toISOString()
        }));
      }

      const agentsDir = path.join(__dirname, 'agents');
      if (fs.existsSync(agentsDir)) {
        const planFiles = fs.readdirSync(agentsDir).filter(f => f.startsWith('execution-plan-'));
        this.deploymentContext.plans = planFiles.map(file => ({
          file: file,
          size: fs.statSync(path.join(agentsDir, file)).size,
          modified: fs.statSync(path.join(agentsDir, file)).mtime.toISOString()
        }));
      }

      this.log('info', `BMAD context loaded: ${this.deploymentContext.stories.length} stories, ${this.deploymentContext.plans.length} plans`);

    } catch (error) {
      this.log('warn', `Could not load BMAD context: ${error.message}`);
    }
  }

  async captureSystemInfo() {
    this.deploymentContext.system = {
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
      cpus: require('os').cpus().length,
      memory: Math.round(require('os').totalmem() / 1024 / 1024 / 1024),
      timestamp: new Date().toISOString()
    };
  }

  async createRollbackStrategy() {
    this.deploymentContext.rollbackStrategy = {
      gitCommit: this.deploymentContext.gitCommit,
      packageVersion: this.deploymentContext.packageVersion,
      environmentBackup: this.deploymentContext.environmentVariables,
      instructions: [
        'Revert to previous Railway deployment',
        `Roll back git to commit: ${this.deploymentContext.gitCommit}`,
        'Restore environment variables if needed',
        'Verify health endpoints are responding',
        'Check MCP server initialization'
      ]
    };
  }

  async deployToRailway() {
    console.log('ðŸš‚ Deploying to Railway...');

    return new Promise((resolve, reject) => {

      exec('railway --version', (error) => {
        if (error) {
          this.log('warn', 'Railway CLI not found, deployment may need manual trigger');
          console.log('  âš ï¸  Railway CLI not found. Deployment will be triggered by git push.');

          this.deployViaGitPush().then(resolve).catch(reject);
          return;
        }

        this.deployViaRailwayCLI().then(resolve).catch(reject);
      });
    });
  }

  async deployViaRailwayCLI() {
    return new Promise((resolve, reject) => {
      const deployProcess = spawn('railway', ['up'], {
        cwd: projectRoot,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let output = '';
      let errorOutput = '';

      deployProcess.stdout.on('data', (data) => {
        const message = data.toString();
        output += message;
        this.log('info', `Railway: ${message.trim()}`);
      });

      deployProcess.stderr.on('data', (data) => {
        const message = data.toString();
        errorOutput += message;
        this.log('error', `Railway Error: ${message.trim()}`);
      });

      deployProcess.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`Railway deployment failed with code ${code}: ${errorOutput}`));
          return;
        }

        this.log('info', 'Railway deployment completed successfully');
        resolve();
      });
    });
  }

  async deployViaGitPush() {
    return new Promise((resolve, reject) => {

      exec('git status --porcelain', { cwd: projectRoot }, (error, stdout) => {
        if (error) {
          reject(new Error(`Git status check failed: ${error.message}`));
          return;
        }

        if (stdout.trim()) {

          this.commitAndPush().then(resolve).catch(reject);
        } else {

          this.pushToRemote().then(resolve).catch(reject);
        }
      });
    });
  }

  async commitAndPush() {
    return new Promise((resolve, reject) => {
      const commitMessage = `Deploy: ${this.deploymentId} - BMAD contextual deployment`;

      exec('git add .', { cwd: projectRoot }, (error) => {
        if (error) {
          reject(new Error(`Git add failed: ${error.message}`));
          return;
        }

        exec(`git commit -m "${commitMessage}"`, { cwd: projectRoot }, (error) => {
          if (error) {
            this.log('warn', 'Git commit failed, may be nothing to commit');
          }

          this.pushToRemote().then(resolve).catch(reject);
        });
      });
    });
  }

  async pushToRemote() {
    return new Promise((resolve, reject) => {
      exec('git push origin main', { cwd: projectRoot }, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Git push failed: ${error.message}`));
          return;
        }

        this.log('info', 'Code pushed to repository, Railway deployment triggered');
        console.log('  ðŸ“¤ Code pushed to repository');
        console.log('  â³ Railway deployment triggered automatically');

        resolve();
      });
    });
  }

  async runPostDeploymentValidation() {
    console.log('ðŸ” Running post-deployment validation...');

    console.log('  â³ Waiting for deployment to stabilize...');
    await this.sleep(30000);

    try {

      await this.validateHealthEndpoint();

      await this.validateMCPServer();

      console.log('  âœ… Post-deployment validation passed');
      this.log('info', 'Post-deployment validation completed successfully');

    } catch (error) {
      console.error('  âŒ Post-deployment validation failed:', error.message);
      this.log('error', `Post-deployment validation failed: ${error.message}`);

      console.log('  âš ï¸  Continuing despite validation issues');
    }
  }

  async validateHealthEndpoint() {
    return new Promise((resolve, reject) => {
      const healthUrl = 'https:

      exec(`curl -s -o /dev/null -w "%{http_code}" ${healthUrl}`, (error, stdout) => {
        if (error) {
          reject(new Error(`Health endpoint check failed: ${error.message}`));
          return;
        }

        if (stdout.trim() === '200') {
          this.log('info', 'Health endpoint responding correctly');
          resolve();
        } else {
          reject(new Error(`Health endpoint returned status: ${stdout.trim()}`));
        }
      });
    });
  }

  async validateMCPServer() {
    return new Promise((resolve, reject) => {
      const toolsUrl = 'https:

      exec(`curl -s "${toolsUrl}" -H "x-api-key: 55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8"`, (error, stdout) => {
        if (error) {
          reject(new Error(`MCP server validation failed: ${error.message}`));
          return;
        }

        try {
          const response = JSON.parse(stdout);
          if (response.result && response.result.tools) {
            this.log('info', `MCP server responding with ${response.result.tools.length} tools`);
            resolve();
          } else {
            reject(new Error('MCP server not returning expected tools format'));
          }
        } catch (parseError) {
          reject(new Error(`MCP server response parsing failed: ${parseError.message}`));
        }
      });
    });
  }

  async generateDeploymentReport() {
    console.log('ðŸ“‹ Generating deployment report...');

    const report = {
      deployment: this.deploymentContext,
      checks: this.checks,
      summary: {
        success: Object.values(this.checks).every(check => check),
        duration: Date.now() - new Date(this.deploymentContext.timestamp).getTime(),
        timestamp: new Date().toISOString()
      },
      recommendations: this.generateRecommendations()
    };

    const reportPath = path.join(__dirname, 'deployment-reports', `${this.deploymentId}-report.json`);
    fs.mkdirSync(path.dirname(reportPath), { recursive: true });
    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

    const markdownReport = this.generateMarkdownReport(report);
    const markdownPath = path.join(path.dirname(reportPath), `${this.deploymentId}-report.md`);
    fs.writeFileSync(markdownPath, markdownReport);

    this.displayDeploymentSummary(report);
  }

  generateRecommendations() {
    const recommendations = [];

    if (!this.checks.tests) {
      recommendations.push({
        type: 'testing',
        message: 'Consider adding a test suite to improve deployment reliability',
        priority: 'medium'
      });
    }

    if (this.deploymentContext.environmentVariables.length < 3) {
      recommendations.push({
        type: 'configuration',
        message: 'Verify all required environment variables are configured',
        priority: 'high'
      });
    }

    if (this.deploymentContext.stories.length === 0) {
      recommendations.push({
        type: 'process',
        message: 'Run BMAD story generation before future deployments for better context',
        priority: 'low'
      });
    }

    return recommendations;
  }

  generateMarkdownReport(report) {
    return `# Deployment Report: ${this.deploymentId}

**Timestamp:** ${new Date(report.deployment.timestamp).toLocaleString()}
**Duration:** ${Math.round(report.summary.duration / 1000)}s
**Status:** ${report.summary.success ? 'âœ… Success' : 'âŒ Failed'}

## Deployment Context

- **Environment:** ${report.deployment.environment}
- **Platform:** ${report.deployment.platform}
- **Git Commit:** ${report.deployment.gitCommit || 'Unknown'}
- **Git Branch:** ${report.deployment.gitBranch || 'Unknown'}
- **Package Version:** ${report.deployment.packageVersion || 'Unknown'}

## Pre-deployment Checks

${Object.entries(report.checks).map(([check, passed]) =>
  `- **${check}:** ${passed ? 'âœ… Passed' : 'âŒ Failed'}`
).join('\n')}

## BMAD Context

- **Stories:** ${report.deployment.stories.length} files
- **Plans:** ${report.deployment.plans.length} files

## System Information

- **Node Version:** ${report.deployment.system?.nodeVersion || 'Unknown'}
- **Platform:** ${report.deployment.system?.platform || 'Unknown'}
- **CPUs:** ${report.deployment.system?.cpus || 'Unknown'}
- **Memory:** ${report.deployment.system?.memory || 'Unknown'}GB

## Rollback Strategy

${report.deployment.rollbackStrategy?.instructions.map(instruction => `- ${instruction}`).join('\n') || 'No rollback strategy defined'}

## Recommendations

${report.recommendations.map(rec => `
### ${rec.type}: ${rec.message}
**Priority:** ${rec.priority}
`).join('\n')}

---

*Generated by BMAD Contextual Deployment on ${new Date().toISOString()}*
`;
  }

  displayDeploymentSummary(report) {
    console.log('\nðŸŽ¯ DEPLOYMENT COMPLETE!');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log(`ðŸš€ Deployment ID: ${this.deploymentId}`);
    console.log(`â±ï¸  Duration: ${Math.round(report.summary.duration / 1000)}s`);
    console.log(`âœ… Status: ${report.summary.success ? 'Success' : 'Failed'}`);
    console.log(`ðŸ“Š Checks: ${Object.values(this.checks).filter(Boolean).length}/${Object.keys(this.checks).length} passed`);
    console.log(`ðŸ“‹ Context: ${report.deployment.stories.length} stories, ${report.deployment.plans.length} plans`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');

    if (report.recommendations.length > 0) {
      console.log('\nðŸ’¡ Recommendations:');
      report.recommendations.forEach((rec, i) => {
        console.log(`   ${i + 1}. ${rec.message} (${rec.priority})`);
      });
    }

    console.log(`\nðŸ“„ Full report: .bmad/deployment-reports/${this.deploymentId}-report.md`);
    console.log('ðŸ“Š Health check: https:
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

if (import.meta.url === `file:
  const deployment = new BMadContextualDeployment();
  deployment.deploy().catch(error => {
    console.error('ðŸ’¥ Deployment failed:', error);
    process.exit(1);
  });
}

export default BMadContextualDeployment;

NaN
FILE: .bmad/story-generator.js
SIZE: 19.77 KB | LINES: 619
MODIFIED: 2025-09-01T09:35:00.035Z
NaN

#!/usr/bin/env node

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

class BMadStoryGenerator {
  constructor() {
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.flattenedFile = path.join(__dirname, 'flattened-codebase.txt');
    this.outputDir = path.join(__dirname, 'stories');
    this.codebaseContext = null;

    this.storyTemplates = {
      feature: {
        priority: 'high',
        category: 'feature',
        template: 'user-story'
      },
      enhancement: {
        priority: 'medium',
        category: 'enhancement',
        template: 'improvement'
      },
      bugfix: {
        priority: 'high',
        category: 'bugfix',
        template: 'defect'
      },
      technical: {
        priority: 'low',
        category: 'technical-debt',
        template: 'refactor'
      }
    };
  }

  async generateStories() {
    console.log('ðŸ“– Starting BMAD Story Generation...');
    console.log(`ðŸ•’ Timestamp: ${this.timestamp}`);

    await this.loadCodebaseContext();

    const opportunities = await this.analyzeCodebase();

    const stories = await this.createStories(opportunities);

    await this.writeStories(stories);

    await this.generateSummary(stories);

    console.log('âœ… Story generation complete!');
  }

  async loadCodebaseContext() {
    try {
      if (!fs.existsSync(this.flattenedFile)) {
        console.log('âš ï¸  No flattened codebase found. Run `npm run bmad:flatten` first.');
        process.exit(1);
      }

      this.codebaseContext = fs.readFileSync(this.flattenedFile, 'utf8');
      console.log('ðŸ“š Loaded flattened codebase context');

    } catch (error) {
      console.error('âŒ Error loading codebase context:', error.message);
      process.exit(1);
    }
  }

  async analyzeCodebase() {
    console.log('ðŸ” Analyzing codebase for story opportunities...');

    const opportunities = [];

    const packageAnalysis = this.analyzePackageJson();
    opportunities.push(...packageAnalysis);

    const codeAnalysis = this.analyzeSourceCode();
    opportunities.push(...codeAnalysis);

    const docAnalysis = this.analyzeDocumentation();
    opportunities.push(...docAnalysis);

    const testAnalysis = this.analyzeTestCoverage();
    opportunities.push(...testAnalysis);

    console.log(`ðŸ“Š Found ${opportunities.length} potential story opportunities`);
    return opportunities;
  }

  analyzePackageJson() {
    const opportunities = [];

    if (this.codebaseContext.includes('mcp-outreach-server')) {
      opportunities.push({
        type: 'feature',
        title: 'Enhanced MCP Error Handling',
        description: 'Improve error handling and user feedback for MCP protocol validation errors',
        context: 'MCP server validation issues detected',
        priority: 'high',
        estimatedHours: 8,
        category: 'reliability'
      });

      opportunities.push({
        type: 'enhancement',
        title: 'MCP Server Health Monitoring',
        description: 'Add comprehensive health monitoring and diagnostics for MCP server',
        context: 'Production reliability improvement',
        priority: 'medium',
        estimatedHours: 12,
        category: 'monitoring'
      });
    }

    if (this.codebaseContext.includes('outreach') || this.codebaseContext.includes('Outreach')) {
      opportunities.push({
        type: 'feature',
        title: 'Outreach API Rate Limiting',
        description: 'Implement intelligent rate limiting and retry logic for Outreach API calls',
        context: 'API reliability and performance optimization',
        priority: 'high',
        estimatedHours: 16,
        category: 'performance'
      });

      opportunities.push({
        type: 'enhancement',
        title: 'Bulk Operations Optimization',
        description: 'Optimize bulk prospect creation and sequence enrollment operations',
        context: 'Performance improvement for large datasets',
        priority: 'medium',
        estimatedHours: 10,
        category: 'performance'
      });
    }

    return opportunities;
  }

  analyzeSourceCode() {
    const opportunities = [];

    const todoMatches = this.codebaseContext.match(/\/\/ TODO:.*$/gm) || [];
    todoMatches.forEach(todo => {
      opportunities.push({
        type: 'technical',
        title: `Address TODO: ${todo.replace('
        description: `Implement or resolve the TODO item: ${todo}`,
        context: 'Technical debt cleanup',
        priority: 'low',
        estimatedHours: 4,
        category: 'technical-debt'
      });
    });

    const fixmeMatches = this.codebaseContext.match(/\/\/ FIXME:.*$/gm) || [];
    fixmeMatches.forEach(fixme => {
      opportunities.push({
        type: 'bugfix',
        title: `Fix Issue: ${fixme.replace('
        description: `Resolve the identified issue: ${fixme}`,
        context: 'Bug fix required',
        priority: 'high',
        estimatedHours: 6,
        category: 'bugfix'
      });
    });

    if (this.codebaseContext.includes('console.error') && !this.codebaseContext.includes('winston')) {
      opportunities.push({
        type: 'enhancement',
        title: 'Structured Logging Implementation',
        description: 'Replace console logging with structured logging using Winston or similar',
        context: 'Production logging improvement',
        priority: 'medium',
        estimatedHours: 8,
        category: 'infrastructure'
      });
    }

    return opportunities;
  }

  analyzeDocumentation() {
    const opportunities = [];

    if (!this.codebaseContext.includes('## Installation') ||
        !this.codebaseContext.includes('## Usage')) {
      opportunities.push({
        type: 'technical',
        title: 'Complete README Documentation',
        description: 'Add comprehensive installation, usage, and deployment documentation',
        context: 'Documentation improvement',
        priority: 'medium',
        estimatedHours: 4,
        category: 'documentation'
      });
    }

    if (this.codebaseContext.includes('express') && !this.codebaseContext.includes('swagger')) {
      opportunities.push({
        type: 'enhancement',
        title: 'API Documentation with Swagger',
        description: 'Add Swagger/OpenAPI documentation for all API endpoints',
        context: 'API documentation improvement',
        priority: 'low',
        estimatedHours: 12,
        category: 'documentation'
      });
    }

    return opportunities;
  }

  analyzeTestCoverage() {
    const opportunities = [];

    if (!this.codebaseContext.includes('jest') && !this.codebaseContext.includes('mocha')) {
      opportunities.push({
        type: 'technical',
        title: 'Testing Framework Setup',
        description: 'Set up comprehensive testing framework with Jest and testing utilities',
        context: 'Quality assurance foundation',
        priority: 'high',
        estimatedHours: 16,
        category: 'testing'
      });
    }

    const functionMatches = this.codebaseContext.match(/(?:async\s+)?function\s+\w+|const\s+\w+\s*=\s*(?:async\s*)?\(/g) || [];
    if (functionMatches.length > 5 && !this.codebaseContext.includes('describe(')) {
      opportunities.push({
        type: 'technical',
        title: 'Unit Test Coverage Implementation',
        description: 'Add comprehensive unit tests for all critical functions and modules',
        context: 'Test coverage improvement',
        priority: 'medium',
        estimatedHours: 20,
        category: 'testing'
      });
    }

    return opportunities;
  }

  async createStories(opportunities) {
    console.log('âœï¸  Creating detailed user stories...');

    const stories = [];

    for (const opportunity of opportunities) {
      const story = await this.createStoryFromOpportunity(opportunity);
      stories.push(story);
    }

    stories.sort((a, b) => {
      const priorityOrder = { high: 3, medium: 2, low: 1 };
      return priorityOrder[b.priority] - priorityOrder[a.priority];
    });

    return stories;
  }

  async createStoryFromOpportunity(opportunity) {
    const storyId = this.generateStoryId();
    const template = this.storyTemplates[opportunity.type] || this.storyTemplates.feature;

    const story = {
      id: storyId,
      title: opportunity.title,
      type: opportunity.type,
      priority: opportunity.priority,
      category: opportunity.category,
      estimatedHours: opportunity.estimatedHours,
      created: new Date().toISOString(),

      asA: this.generateAsA(opportunity),
      iWant: this.generateIWant(opportunity),
      soThat: this.generateSoThat(opportunity),

      description: opportunity.description,
      context: opportunity.context,

      acceptanceCriteria: this.generateAcceptanceCriteria(opportunity),

      technicalRequirements: this.generateTechnicalRequirements(opportunity),

      testingRequirements: this.generateTestingRequirements(opportunity),

      definitionOfDone: this.generateDefinitionOfDone(opportunity)
    };

    return story;
  }

  generateStoryId() {
    const timestamp = Date.now().toString().slice(-6);
    const random = Math.random().toString(36).substr(2, 3).toUpperCase();
    return `STORY-${timestamp}-${random}`;
  }

  generateAsA(opportunity) {
    switch (opportunity.category) {
      case 'reliability':
        return 'a developer using the MCP server';
      case 'monitoring':
        return 'a system administrator';
      case 'performance':
        return 'a user of the Outreach integration';
      case 'documentation':
        return 'a new developer joining the project';
      case 'testing':
        return 'a quality assurance engineer';
      default:
        return 'a user of the system';
    }
  }

  generateIWant(opportunity) {
    return opportunity.title.toLowerCase().replace(/^(add|implement|create|fix|improve|enhance)/, 'to $1');
  }

  generateSoThat(opportunity) {
    switch (opportunity.category) {
      case 'reliability':
        return 'I can have confidence in the system\'s stability and error handling';
      case 'monitoring':
        return 'I can proactively identify and resolve system issues';
      case 'performance':
        return 'I can work more efficiently with faster response times';
      case 'documentation':
        return 'I can understand and contribute to the codebase quickly';
      case 'testing':
        return 'I can ensure code quality and prevent regressions';
      default:
        return 'I can accomplish my goals more effectively';
    }
  }

  generateAcceptanceCriteria(opportunity) {
    const criteria = [
      'Feature implementation is complete and functional',
      'All existing tests continue to pass',
      'New functionality is covered by appropriate tests',
      'Code follows existing style and conventions',
      'Documentation is updated to reflect changes'
    ];

    switch (opportunity.type) {
      case 'feature':
        criteria.unshift('User can successfully use the new feature as described');
        break;
      case 'enhancement':
        criteria.unshift('Performance improvement is measurably better than baseline');
        break;
      case 'bugfix':
        criteria.unshift('The identified issue is completely resolved');
        criteria.push('Fix does not introduce new issues');
        break;
      case 'technical':
        criteria.unshift('Technical debt is reduced without breaking existing functionality');
        break;
    }

    return criteria;
  }

  generateTechnicalRequirements(opportunity) {
    const requirements = [];

    if (opportunity.context.includes('MCP')) {
      requirements.push('Maintain compatibility with MCP protocol specification');
      requirements.push('Ensure proper error handling and validation');
    }

    if (opportunity.context.includes('API')) {
      requirements.push('Implement proper rate limiting and retry logic');
      requirements.push('Add comprehensive error handling for API failures');
    }

    if (opportunity.category === 'testing') {
      requirements.push('Achieve minimum 80% code coverage');
      requirements.push('Include both unit and integration tests');
    }

    if (opportunity.category === 'performance') {
      requirements.push('Establish performance benchmarks');
      requirements.push('Implement monitoring for performance metrics');
    }

    return requirements;
  }

  generateTestingRequirements(opportunity) {
    return [
      'Unit tests for all new/modified functions',
      'Integration tests for external API interactions',
      'Error case testing for all failure scenarios',
      'Performance testing if applicable',
      'User acceptance testing checklist'
    ];
  }

  generateDefinitionOfDone(opportunity) {
    return [
      'Code is written and peer reviewed',
      'All tests pass including new test coverage',
      'Documentation is updated',
      'Feature is deployed to staging environment',
      'User acceptance testing is completed',
      'Performance impact is measured and acceptable',
      'Security review is completed if applicable',
      'Feature is ready for production deployment'
    ];
  }

  async writeStories(stories) {
    console.log('ðŸ’¾ Writing stories to files...');

    fs.mkdirSync(this.outputDir, { recursive: true });

    for (const story of stories) {
      const filename = `${story.id}-${story.title.toLowerCase().replace(/[^a-z0-9]/g, '-')}.md`;
      const filepath = path.join(this.outputDir, filename);

      const content = this.generateStoryMarkdown(story);
      fs.writeFileSync(filepath, content, 'utf8');

      console.log(`ðŸ“„ Created: ${filename}`);
    }

    const indexContent = this.generateStoriesIndex(stories);
    fs.writeFileSync(path.join(this.outputDir, 'index.md'), indexContent, 'utf8');

    console.log(`ðŸ“š Created stories index with ${stories.length} stories`);
  }

  generateStoryMarkdown(story) {
    return `# ${story.title}

**Story ID:** ${story.id}
**Type:** ${story.type}
**Priority:** ${story.priority}
**Category:** ${story.category}
**Estimated Hours:** ${story.estimatedHours}
**Created:** ${new Date(story.created).toLocaleDateString()}

## User Story

**As a** ${story.asA}
**I want** ${story.iWant}
**So that** ${story.soThat}

## Description

${story.description}

## Context

${story.context}

## Acceptance Criteria

${story.acceptanceCriteria.map(criterion => `- [ ] ${criterion}`).join('\n')}

## Technical Requirements

${story.technicalRequirements.map(req => `- ${req}`).join('\n')}

## Testing Requirements

${story.testingRequirements.map(req => `- ${req}`).join('\n')}

## Definition of Done

${story.definitionOfDone.map(item => `- [ ] ${item}`).join('\n')}

---

*Generated by BMAD Story Generator on ${new Date().toISOString()}*
`;
  }

  generateStoriesIndex(stories) {
    const priorityGroups = {
      high: stories.filter(s => s.priority === 'high'),
      medium: stories.filter(s => s.priority === 'medium'),
      low: stories.filter(s => s.priority === 'low')
    };

    let content = `# Development Stories Index

Generated: ${new Date().toISOString()}
Total Stories: ${stories.length}

## Summary by Priority

- **High Priority:** ${priorityGroups.high.length} stories (${priorityGroups.high.reduce((sum, s) => sum + s.estimatedHours, 0)} hours)
- **Medium Priority:** ${priorityGroups.medium.length} stories (${priorityGroups.medium.reduce((sum, s) => sum + s.estimatedHours, 0)} hours)
- **Low Priority:** ${priorityGroups.low.length} stories (${priorityGroups.low.reduce((sum, s) => sum + s.estimatedHours, 0)} hours)

**Total Estimated Effort:** ${stories.reduce((sum, s) => sum + s.estimatedHours, 0)} hours

## Stories by Priority

`;

    for (const [priority, storyList] of Object.entries(priorityGroups)) {
      if (storyList.length > 0) {
        content += `\n### ${priority.toUpperCase()} Priority\n\n`;

        storyList.forEach(story => {
          const filename = `${story.id}-${story.title.toLowerCase().replace(/[^a-z0-9]/g, '-')}.md`;
          content += `- [${story.title}](${filename}) (${story.estimatedHours}h) - ${story.category}\n`;
        });
      }
    }

    content += `\n---

## Next Steps

1. Review and prioritize stories with team
2. Run \`npm run bmad:plan\` to generate implementation plans
3. Begin implementation starting with high-priority stories
4. Use \`npm run bmad:deploy\` when ready to deploy

*Generated by BMAD Story Generator*
`;

    return content;
  }

  async generateSummary(stories) {
    const summary = {
      generated: new Date().toISOString(),
      totalStories: stories.length,
      totalEstimatedHours: stories.reduce((sum, s) => sum + s.estimatedHours, 0),
      priorityBreakdown: {
        high: stories.filter(s => s.priority === 'high').length,
        medium: stories.filter(s => s.priority === 'medium').length,
        low: stories.filter(s => s.priority === 'low').length
      },
      categoryBreakdown: stories.reduce((acc, story) => {
        acc[story.category] = (acc[story.category] || 0) + 1;
        return acc;
      }, {}),
      nextSteps: [
        'Review generated stories in .bmad/stories/',
        'Run npm run bmad:plan to create implementation strategies',
        'Begin development with highest priority stories',
        'Use generated acceptance criteria for validation'
      ]
    };

    console.log('\nðŸŽ¯ STORY GENERATION SUMMARY');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log(`ðŸ“š Total stories: ${summary.totalStories}`);
    console.log(`â±ï¸  Total estimated hours: ${summary.totalEstimatedHours}`);
    console.log(`ðŸ”´ High priority: ${summary.priorityBreakdown.high}`);
    console.log(`ðŸŸ¡ Medium priority: ${summary.priorityBreakdown.medium}`);
    console.log(`ðŸŸ¢ Low priority: ${summary.priorityBreakdown.low}`);
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('\nðŸ’¡ Next steps:');
    summary.nextSteps.forEach((step, i) => {
      console.log(`   ${i + 1}. ${step}`);
    });
  }
}

if (import.meta.url === `file:
  const generator = new BMadStoryGenerator();
  generator.generateStories().catch(error => {
    console.error('ðŸ’¥ Story generation failed:', error);
    process.exit(1);
  });
}

export default BMadStoryGenerator;

NaN
FILE: .claude/settings.local.json
SIZE: 897 B | LINES: 36
MODIFIED: 2025-08-28T22:52:22.902Z
NaN

{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(railway login:*)",
      "Bash(railway init:*)",
      "Bash(git init:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git remote add:*)",
      "Bash(git push:*)",
      "Bash(node:*)",
      "WebSearch",
      "Bash(railway status:*)",
      "Bash(railway link:*)",
      "Bash(git checkout:*)",
      "WebFetch(domain:mcp-outreach-server-production.up.railway.app)",
      "Bash(timeout:*)",
      "Bash(gtimeout:*)",
      "Bash(railway logs:*)",
      "Bash(echo:*)",
      "Bash(chmod:*)",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "Bash(npm run:*)",
      "Bash(npx tsc:*)",
      "Bash(git reset:*)",
      "Bash(git pull:*)"
    ],
    "deny": [],
    "ask": [],
    "additionalDirectories": [
      "/Users/raphaelberrebi"
    ]
  }
}

NaN
FILE: .env.example
SIZE: 347 B | LINES: 10
MODIFIED: 2025-08-19T12:05:27.731Z
NaN

# Outreach OAuth Configuration
OUTREACH_CLIENT_ID=your_client_id_here
OUTREACH_CLIENT_SECRET=your_client_secret_here
OUTREACH_REDIRECT_URI=http://localhost:3000/callback
OUTREACH_REFRESH_TOKEN=your_refresh_token_here
OUTREACH_API_BASE_URL=https://api.outreach.io/api/v2

# MCP Server Configuration
MCP_SERVER_NAME=outreach-mcp
MCP_SERVER_PORT=3000

NaN
FILE: CLAUDE-DEPLOYMENT-GUIDE.md
SIZE: 9.16 KB | LINES: 342
MODIFIED: 2025-09-01T07:37:31.374Z
NaN

# ðŸ“š Complete Guide: Deploying Outreach MCP Server to Claude Desktop

## ðŸŽ¯ Overview
This guide provides **three different methods** to deploy the Outreach MCP Server to your Claude Desktop application, ranging from the simplest remote setup to full local installation.

---

## ðŸš€ Method 1: Remote Server (Easiest - 2 Minutes)
**Best for**: Users who want immediate access without any setup or API keys

### What You Get
- âœ… **No OAuth setup required** - Authentication handled remotely
- âœ… **24 pre-configured tools** ready to use
- âœ… **Zero maintenance** - Updates handled automatically
- âœ… **No API keys needed** - Everything managed server-side

### Setup Steps

1. **Download the Bridge Script**
   ```bash
   # Download the proxy script from the repository
   curl -O https://raw.githubusercontent.com/raphael656-GTM/mcp-outreach-server/main/outreach-proxy.cjs
   ```
   Or manually download `outreach-proxy.cjs` from the repository

2. **Add to Claude Desktop Configuration**
   
   Open your Claude config file:
   - **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`
   - **Linux**: `~/.config/Claude/claude_desktop_config.json`

   Add this configuration:
   ```json
   {
     "mcpServers": {
       "outreach-remote": {
         "command": "node",
         "args": ["/absolute/path/to/outreach-proxy.cjs"]
       }
     }
   }
   ```

3. **Restart Claude Desktop**
   - Completely quit Claude Desktop
   - Relaunch the application

4. **Test the Connection**
   Try these commands in Claude:
   - "List all available Outreach tools"
   - "Check the health of the Outreach server"

---

## ðŸ  Method 2: Local Installation with OAuth (Recommended for Teams)
**Best for**: Teams who want full control with their own Outreach OAuth app

### Prerequisites
- Node.js v18 or higher
- Admin access to Outreach account
- Ability to create OAuth applications in Outreach

### Step 1: Create Outreach OAuth Application

1. **Log into Outreach as Admin**
   - Navigate to: Settings â†’ Integrations â†’ API Access
   - Click "Create New App" or "Register Application"

2. **Configure OAuth App**
   ```
   Application Name: MCP Integration
   Redirect URI: http://localhost:3000/callback
   Application Type: Private/Internal
   ```

3. **Select Required Scopes**
   - `accounts.all` - Account management
   - `prospects.all` - Prospect management
   - `sequences.all` - Sequence operations
   - `sequenceStates.all` - Sequence enrollment
   - `mailboxes.all` - Mailbox access
   - `tags.all` - Tag management
   - `users.all` - User information

4. **Save Credentials**
   Copy your **Client ID** and **Client Secret**

### Step 2: Install MCP Server Locally

1. **Clone the Repository**
   ```bash
   git clone https://github.com/raphael656-GTM/mcp-outreach-server.git
   cd mcp-outreach-server
   ```

2. **Install Dependencies**
   ```bash
   npm install
   ```

3. **Configure Environment**
   ```bash
   cp .env.example .env
   ```
   
   Edit `.env` file:
   ```env
   OUTREACH_CLIENT_ID=your_client_id_here
   OUTREACH_CLIENT_SECRET=your_client_secret_here
   OUTREACH_REDIRECT_URI=http://localhost:3000/callback
   OUTREACH_API_BASE_URL=https://api.outreach.io/api/v2
   ```

4. **Authenticate with Outreach**
   ```bash
   npm run setup
   ```
   This will:
   - Open your browser for OAuth authorization
   - Save refresh token to `.env`
   - Confirm successful authentication

5. **Build the Server**
   ```bash
   npm run build
   ```

### Step 3: Configure Claude Desktop

Edit your Claude config file and add:

```json
{
  "mcpServers": {
    "outreach-local": {
      "command": "node",
      "args": ["/path/to/mcp-outreach-server/dist/index.js"],
      "env": {
        "OUTREACH_CLIENT_ID": "your_oauth_client_id",
        "OUTREACH_CLIENT_SECRET": "your_oauth_client_secret",
        "OUTREACH_REDIRECT_URI": "http://localhost:3000/callback",
        "OUTREACH_REFRESH_TOKEN": "your_refresh_token"
      }
    }
  }
}
```

### Step 4: Restart Claude and Test

1. Restart Claude Desktop
2. Test with: "List my Outreach sequences"

---

## ðŸ”‘ Method 3: Personal Access Token (Simplest Local Setup)
**Best for**: Individual users with existing Outreach API tokens

### Step 1: Get Your Outreach API Token

1. **Generate Personal Access Token**
   - Log into Outreach
   - Go to: Settings â†’ Apps â†’ API Access
   - Click "Generate Personal Access Token"
   - Copy the token (you won't see it again!)

### Step 2: Quick Setup

1. **Download Pre-built Server**
   ```bash
   # Clone repository
   git clone https://github.com/raphael656-GTM/mcp-outreach-server.git
   cd mcp-outreach-server
   
   # Install dependencies
   npm install
   
   # Build
   npm run build
   ```

2. **Configure Claude Desktop**
   
   Add to your Claude config:
   ```json
   {
     "mcpServers": {
       "outreach-token": {
         "command": "node",
         "args": ["/path/to/mcp-outreach-server/dist/index.js"],
         "env": {
           "OUTREACH_API_TOKEN": "your_personal_access_token_here"
         }
       }
     }
   }
   ```

3. **Restart Claude Desktop and Test**

---

## ðŸ› ï¸ Available Tools (All Methods)

### High-Level Workflow Tools
- `create_complete_email_sequence` - Build entire email sequences
- `create_and_enroll_prospect` - Create and enroll in one step
- `create_campaign_with_prospects` - Full campaign automation

### Bulk Operations
- `bulk_create_prospects` - Create 25-50 prospects at once
- `bulk_enroll_prospects` - Mass enrollment in sequences
- `bulk_create_templates` - Batch template creation

### Core Functions
- `create_prospect` - Add individual prospects
- `search_prospects` - Find prospects by criteria
- `get_sequences` - List all sequences
- `create_sequence` - Build new sequences
- `add_prospect_to_sequence` - Enroll prospects

### Monitoring Tools
- `get_health_status` - Server health check
- `get_performance_metrics` - Performance statistics
- `clear_cache` - Reset cached data

---

## ðŸ”§ Troubleshooting

### Common Issues and Solutions

#### "MCP server not initialized"
- **Cause**: Server is starting up
- **Fix**: Wait 30 seconds and retry

#### "Connection refused"
- **Cause**: Incorrect path or server not running
- **Fix**: Verify absolute path in config, check Node.js installation

#### "Authentication failed"
- **Cause**: Invalid or expired credentials
- **Fix**: Re-run OAuth setup or regenerate API token

#### Claude Not Recognizing Server
1. Use absolute paths (not relative) in config
2. Ensure Node.js is installed: `node --version`
3. Check file permissions: `chmod +x outreach-proxy.cjs`
4. Completely quit and restart Claude Desktop

### Debug Commands

Test your setup:
```bash
# Test Node.js
node --version

# Test server directly (local installation)
node /path/to/mcp-outreach-server/dist/index.js

# Check Claude config syntax
cat ~/Library/Application\ Support/Claude/claude_desktop_config.json | python -m json.tool
```

---

## ðŸ“Š Comparison Table

| Feature | Remote (Method 1) | Local OAuth (Method 2) | Local Token (Method 3) |
|---------|------------------|----------------------|----------------------|
| **Setup Time** | 2 minutes | 15 minutes | 5 minutes |
| **API Keys Required** | No | Yes (OAuth) | Yes (Token) |
| **Maintenance** | None | Self-managed | Self-managed |
| **Data Privacy** | Via proxy | Direct to Outreach | Direct to Outreach |
| **Customization** | Limited | Full | Full |
| **Best For** | Quick start | Teams/Production | Individual users |

---

## ðŸ“ˆ Example Usage Patterns

### Creating a Complete Campaign
```
"Using Outreach, create a complete campaign called 'Q1 Enterprise Outreach' with:
- A 4-email sequence over 2 weeks
- Initial email with subject 'Quick question about [Company]'
- Follow-ups at days 3, 7, and 14
- Enroll these prospects: john@example.com, sarah@company.com"
```

### Bulk Prospect Import
```
"Import these 10 prospects to Outreach and tag them as 'WebinarAttendees':
[Paste CSV or list of contacts]
Then add them all to the 'Webinar Follow-up' sequence"
```

### Performance Monitoring
```
"Check the Outreach server performance metrics and cache statistics"
```

---

## ðŸ†˜ Getting Help

### Resources
- **Repository**: https://github.com/raphael656-GTM/mcp-outreach-server
- **Issues**: Report bugs on GitHub Issues
- **Health Check** (Remote): https://mcp-outreach-server-production.up.railway.app/health

### Quick Checks
1. Verify Node.js is installed: `node --version`
2. Check config file syntax is valid JSON
3. Use absolute paths in configuration
4. Ensure proper file permissions

---

## ðŸŽ‰ Success Indicators

You'll know your setup is working when:
- âœ… Claude responds to "List Outreach tools" command
- âœ… You can create a test prospect
- âœ… Sequences list appears when requested
- âœ… No error messages in Claude's response

---

## ðŸš¦ Next Steps

Once installed, try these progressively complex tasks:

1. **Basic Test**: "Create a prospect named Test User with email test@example.com"
2. **List Resources**: "Show me all my Outreach sequences"
3. **Create Content**: "Create a 3-email follow-up sequence for demo requests"
4. **Automation**: "Build a complete outreach campaign for our new product launch"

---

**Questions?** Check the troubleshooting section or file an issue on GitHub!

NaN
FILE: CONTEXT.md
SIZE: 7.67 KB | LINES: 142
MODIFIED: 2025-08-24T08:06:32.559Z
NaN

# MCP Outreach Automation - Project Context

## PROJECT OVERVIEW
**Name**: AI-Powered Prospect Research & Outreach Automation
**Goal**: Automate end-to-end prospect research, email generation, and sequence creation in Outreach
**Architecture**: MCP Server + n8n Workflows + AI Processing + Multi-source Data Integration

## CURRENT TECH STACK
- **MCP Server**: Node.js with Outreach API integration, OAuth 2.0 authentication, connection pooling
- **Performance Layer**: Multi-tier caching, bulk operations, real-time monitoring
- **Deployment**: Railway cloud hosting with HTTP wrapper for production scalability
- **Workflow Engine**: n8n for automation orchestration  
- **AI Processing**: Claude 3.5 Sonnet for email generation and prospect analysis
- **Data Sources**: Apollo.io, LinkedIn Sales Navigator, company websites
- **Integration**: RESTful APIs, JSON:API format for Outreach

## PROJECT STRUCTURE
```
/mcp-outreach-server/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.js              # MCP server main entry with HTTP wrapper
â”‚   â”œâ”€â”€ outreach-client.js     # Enhanced Outreach API client
â”‚   â”œâ”€â”€ tools.js              # Extended MCP tool definitions (20+ tools)
â”‚   â”œâ”€â”€ setup-oauth.js        # OAuth setup utilities
â”‚   â””â”€â”€ performance/          # Performance optimization modules
â”‚       â”œâ”€â”€ cache-manager.js   # Multi-tier caching system
â”‚       â”œâ”€â”€ connection-pool.js # HTTP connection pooling
â”‚       â”œâ”€â”€ bulk-operations.js # Bulk API operations
â”‚       â”œâ”€â”€ enhanced-oauth.js  # Proactive token management
â”‚       â””â”€â”€ performance-monitor.js # Real-time metrics
â”œâ”€â”€ /n8n-automation/          # Workflow automation
â”‚   â”œâ”€â”€ workflows/            # n8n workflow templates
â”‚   â””â”€â”€ custom-nodes/         # Custom n8n nodes
â”œâ”€â”€ Dockerfile               # Container configuration
â”œâ”€â”€ docker-compose.yml       # Local development setup
â”œâ”€â”€ railway.json            # Railway deployment config
â””â”€â”€ /.env                   # Configuration and credentials
```

## CURRENT STATE - PRODUCTION ENHANCEMENT COMPLETE
âœ… **Core Infrastructure**:
- Enhanced MCP server with production-grade performance optimizations
- Railway cloud deployment with HTTPS endpoints
- Complete OAuth 2.0 authentication with proactive token management
- Full CRUD operations for prospects, sequences, templates
- Steve Jobs-style email templates with correct Outreach variables
- GitHub repository with comprehensive documentation

âœ… **Performance Features**:
- Connection pooling with 15 persistent HTTP connections
- Multi-tier caching: OAuth (55min), API responses (5min), sequences (1hr)
- Bulk operations supporting 25-50 items per request
- Real-time performance monitoring with metrics dashboard
- Enhanced error recovery with exponential backoff retry logic
- Graceful shutdown with proper resource cleanup

âœ… **Enhanced MCP Tools** (20+ tools available):
- **Bulk Operations**: bulk_create_prospects, bulk_create_sequences, bulk_create_templates, bulk_enroll_prospects
- **Performance Monitoring**: get_performance_metrics, get_health_status, generate_performance_report
- **Cache Management**: clear_cache, get_cache_stats
- **Standard Operations**: All original CRUD operations maintained

ðŸ”„ **Active Integration Points**:
- Production MCP server on Railway cloud with HTTP wrapper
- Local development server on localhost:3000
- Outreach API integration via enhanced OAuth 2.0
- Template creation with {{first_name}} and {{account.name}} variables
- Sequence creation with automatic step linking and bulk enrollment

## BUSINESS OBJECTIVES
- **Automation Scale**: 50-100 prospects researched daily
- **Personalization**: 90%+ accuracy in personalized outreach
- **Response Rates**: 40% improvement over generic templates  
- **Time Savings**: 85% reduction vs manual process
- **Quality**: Steve Jobs-style direct, compelling communication

## TECHNICAL SPECIFICATIONS
- **Performance**: <5 second API responses with connection pooling and caching
- **Scalability**: Bulk operations supporting 25-50 items per request
- **Rate Limits**: Intelligent handling of Outreach API limits with retry logic
- **Data Quality**: Ensure accurate prospect enrichment with validation
- **Security**: Enhanced OAuth token refresh with proactive management
- **Reliability**: Comprehensive error handling with exponential backoff
- **Monitoring**: Real-time performance metrics and health status reporting
- **Memory**: Efficient cache management with automatic cleanup

## CODING STANDARDS
- **Style**: ES6+ JavaScript modules, async/await patterns
- **Error Handling**: Comprehensive try/catch with retry logic
- **Documentation**: JSDoc comments for all functions
- **Testing**: Unit tests for core business logic
- **Security**: No secrets in code, environment variables only

## COMPLETED ENHANCEMENTS
âœ… **Token Management**: Proactive OAuth refresh with 55-minute cache TTL
âœ… **Scalability**: High-volume processing with bulk operations and connection pooling
âœ… **Performance**: Sub-5-second response times with multi-tier caching
âœ… **Reliability**: Enhanced error handling with exponential backoff retry
âœ… **Monitoring**: Real-time performance metrics and health status
âœ… **Deployment**: Production Railway hosting with HTTP wrapper

## NEXT PHASE PRIORITIES
1. **Utilization**: Leverage new bulk operations for high-volume processing
2. **AI Optimization**: Prompt engineering for consistent quality with performance data
3. **Integration**: Seamless n8n to enhanced MCP server communication
4. **Quality Assurance**: Validating AI-generated content at scale
5. **Analytics**: Performance trend analysis and optimization recommendations

## PROJECT MILESTONE - PRODUCTION ENHANCEMENT COMPLETE
**Date**: August 2024
**Phase**: Development â†’ Production Enhancement Complete
**Status**: 95% Complete - All Performance Optimizations Deployed

### Major Achievements
- âœ… Successfully deployed enhanced MCP server to Railway with comprehensive performance optimizations
- âœ… Implemented connection pooling with 15 persistent HTTP connections using HttpsAgent
- âœ… Added multi-tier caching system (OAuth: 55min, API: 5min, sequences: 1hr)
- âœ… Built bulk operations supporting 25-50 items per request for scalable processing
- âœ… Added real-time performance monitoring with response times, success rates, memory usage
- âœ… Enhanced error recovery with exponential backoff retry logic
- âœ… Implemented graceful shutdown with proper cleanup
- âœ… Fixed agentkeepalive import issues and verified local/Railway compatibility
- âœ… Added 13 new MCP tools including bulk operations and performance monitoring
- âœ… Committed all changes to git and successfully pushed to Railway deployment

### Technical Architecture Enhancements
- **Connection Management**: HttpsAgent with keepAlive and connection pooling
- **Caching Strategy**: Multi-tier with different TTL values for optimal performance
- **Bulk Processing**: Parallel operations with configurable batch sizes
- **Error Handling**: Comprehensive retry logic with exponential backoff
- **Monitoring**: Real-time metrics collection and reporting
- **Resource Management**: Proper cleanup and graceful shutdown procedures

### Production Capabilities Now Live
- Enhanced server now live on Railway with backward compatibility maintained
- All 20+ MCP tools operational including new bulk operations
- Performance monitoring dashboard available via get_performance_metrics
- Cache management tools for optimization and debugging
- Health status reporting for proactive monitoring

### Next Steps
Focus has shifted from development to utilization and monitoring of the enhanced production system. The core infrastructure is now production-ready with enterprise-grade performance optimizations.

NaN
FILE: DISTRIBUTION-README.md
SIZE: 6.34 KB | LINES: 162
MODIFIED: 2025-08-28T19:16:54.377Z
NaN

# ðŸš€ Outreach MCP Server - Remote Access

## What This Is
Access **24 powerful Outreach tools** directly from Claude Desktop without any OAuth setup, API keys, or configuration on your end. Everything runs through our secure Railway server.

## âš¡ Quick Setup (2 minutes)

### Step 1: Download the Bridge Script
Download the single file you need:
- **File**: `outreach-proxy.cjs`
- **Size**: ~15KB
- **Requirements**: Node.js (already installed if you use Claude Desktop)

### Step 2: Add to Claude Desktop
1. **Open your Claude Desktop config**:
   - **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

2. **Add this configuration**:
   ```json
   {
     "mcpServers": {
       "outreach-remote": {
         "command": "node",
         "args": ["/full/path/to/outreach-proxy.cjs"]
       }
     }
   }
   ```

3. **Replace `/full/path/to/` with the actual path** where you saved the file

### Step 3: Restart Claude Desktop
Quit Claude Desktop completely and restart it.

### Step 4: Test It!
Try these commands in Claude:
- *"List all available Outreach tools"*
- *"Check the health of the Outreach server"*
- *"Create a prospect named John Doe with email john@example.com"*

## ðŸ› ï¸ Available Tools (24 Total)

### **ðŸŽ¯ High-Level Workflow Tools**
- **`create_complete_email_sequence`** - Create complete sequence with emails and timing in one call
- **`create_and_enroll_prospect`** - Create prospect and enroll in sequence (2-in-1)
- **`create_campaign_with_prospects`** - Full campaign setup: sequence + emails + prospects

### **âš¡ Bulk Operations** 
- **`bulk_create_prospects`** - Create 25-50 prospects at once
- **`bulk_create_sequences`** - Create multiple sequences in batch
- **`bulk_create_templates`** - Create multiple email templates in batch
- **`bulk_enroll_prospects`** - Enroll multiple prospects in sequences

### **ðŸ“Š Performance & Monitoring**
- **`get_performance_metrics`** - Detailed server performance metrics
- **`get_health_status`** - Component health status with alerts
- **`generate_performance_report`** - Performance report with recommendations
- **`clear_cache`** - Clear cached data for fresh API calls
- **`get_cache_stats`** - Cache performance statistics

### **ðŸ”§ Core Outreach Operations**
- **`create_prospect`** - Create individual prospects
- **`search_prospects`** - Search prospects by email, company, tags
- **`get_sequences`** - List all sequences with caching
- **`create_sequence`** - Create new sequences
- **`create_sequence_step`** - Add email/call/task steps to sequences
- **`create_sequence_template`** - Create email templates with variables
- **`link_template_to_step`** - Connect templates to sequence steps
- **`add_prospect_to_sequence`** - Enroll prospects in sequences
- **`get_mailboxes`** - List available sending mailboxes
- **`health_check`** - Server and API connection status

## ðŸ”’ Security & Privacy

### **What We Handle For You:**
- âœ… **OAuth Authentication** - We manage all Outreach API credentials
- âœ… **API Key Management** - Secure server-side authentication  
- âœ… **Rate Limiting** - Built-in request throttling and caching
- âœ… **Error Handling** - Graceful failures with helpful messages

### **What We Don't See:**
- âŒ **Your Claude conversations** - Bridge only forwards tool requests
- âŒ **Your personal data** - No data storage or logging on our end
- âŒ **Other MCP servers** - Isolated to Outreach functionality only

### **Data Flow:**
```
Claude Desktop â†’ Your Bridge Script â†’ Our Railway Server â†’ Outreach API
```

## ðŸš¨ Troubleshooting

### **"MCP server not initialized" Error**
- **Cause**: Railway server is starting up (cold start)
- **Solution**: Wait 30 seconds and try again

### **"Connection refused" Error**  
- **Cause**: Network connectivity or server maintenance
- **Solution**: Check https://mcp-outreach-server-production.up.railway.app/health

### **"Tool not found" Error**
- **Cause**: Typo in tool name or outdated bridge script
- **Solution**: Use exact tool names from the list above

### **Claude Desktop Not Recognizing Server**
1. **Check file path** - Use absolute path in config
2. **Restart Claude Desktop** - Completely quit and reopen  
3. **Check Node.js** - Ensure `node` command works in terminal
4. **File permissions** - Make sure the file is executable: `chmod +x outreach-proxy.cjs`

## ðŸ“ž Support & Updates

### **Get Help:**
- **Health Check**: https://mcp-outreach-server-production.up.railway.app/health
- **Issues**: Report problems with specific error messages
- **Feature Requests**: Suggest new Outreach tools or workflows

### **Stay Updated:**
- **Version**: Current version embedded in bridge script
- **Updates**: New versions announced with enhanced tools and bug fixes
- **Backwards Compatible**: Old bridge scripts continue working

## ðŸŒŸ Example Usage

### **Create a Complete Email Sequence:**
```
"Using Outreach, create a complete email sequence called 'SaaS Demo Follow-up' with 3 emails:

1. Initial follow-up (day 0): Subject 'Thanks for the demo, {{first_name}}!'
2. Value add (day 3): Subject 'Helpful resources for {{account.name}}'  
3. Final touch (day 7): Subject 'Quick question about {{account.name}} priorities'

Each email should be friendly and personalized."
```

### **Bulk Create Prospects:**
```
"Using Outreach, create prospects for these contacts in bulk:
- John Smith, john@techcorp.com, TechCorp, CTO
- Sarah Johnson, sarah@innovate.co, Innovate Co, VP Marketing  
- Mike Davis, mike@startup.io, Startup Inc, Founder"
```

### **Campaign with Full Setup:**
```
"Using Outreach, create a complete campaign called 'Q4 Security Outreach' targeting security professionals with a 3-email sequence, and enroll the prospects I just mentioned."
```

## ðŸŽ‰ What Makes This Special

- **ðŸ”¥ No Setup Required** - Download one file, add one config entry
- **âš¡ 24 Powerful Tools** - Everything from simple prospect creation to complex campaign automation
- **ðŸš€ High-Performance** - Bulk operations, caching, and optimized workflows
- **ðŸ”’ Secure & Reliable** - Production-ready with proper error handling
- **ðŸ“ˆ Scalable** - Handles individual requests or batch operations seamlessly

---

**Ready to supercharge your Outreach workflows with Claude?** ðŸš€

Download `outreach-proxy.cjs`, add it to your config, restart Claude Desktop, and start automating your sales outreach like never before!

NaN
FILE: INSTALL-PROXY-SCRIPT.md
SIZE: 1.76 KB | LINES: 81
MODIFIED: 2025-09-01T08:09:31.275Z
NaN

# Installing the Outreach Proxy Script

Since the proxy script can't be downloaded directly from GitHub, follow these steps:

## Option 1: Create from Terminal

1. Create the file:
```bash
cat > ~/mcp-files/outreach-proxy.cjs << 'EOF'
[PASTE THE ENTIRE SCRIPT HERE]
EOF
```

2. Make it executable:
```bash
chmod +x ~/mcp-files/outreach-proxy.cjs
```

## Option 2: Manual Creation

1. Open TextEdit or your preferred text editor
2. Create a new file
3. Copy the entire script content (provided separately)
4. Save as: `outreach-proxy.cjs` in your `~/mcp-files/` folder
5. In Terminal, make it executable:
```bash
chmod +x ~/mcp-files/outreach-proxy.cjs
```

## Option 3: Download from Alternative Source

Ask the administrator to provide one of these:
- A public Gist URL with the script
- A download link from a file sharing service
- The script via email or Slack

## Verify Installation

After creating the file, verify it's correct:

```bash
# Check file size (should be around 24KB)
ls -lh ~/mcp-files/outreach-proxy.cjs

# Check it starts with the shebang
head -n 1 ~/mcp-files/outreach-proxy.cjs
# Should show: #!/usr/bin/env node

# Check it has the correct server URL
grep "mcp-outreach-server-production" ~/mcp-files/outreach-proxy.cjs
# Should show the Railway URL
```

## Configure Claude Desktop

Once the file is created:

1. Open Claude config:
```bash
open -e ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

2. Add this configuration:
```json
{
  "mcpServers": {
    "outreach-remote": {
      "command": "node",
      "args": ["/Users/leeyalazarovic/mcp-files/outreach-proxy.cjs"]
    }
  }
}
```

3. Save, quit Claude completely, and restart

## Test the Connection

In Claude, try:
- "List all available Outreach tools"
- "Check the health of the Outreach server"

NaN
FILE: LEEYA-COMPLETE-SETUP.md
SIZE: 6.06 KB | LINES: 246
MODIFIED: 2025-09-01T08:59:46.509Z
NaN

# ðŸš€ Complete Outreach MCP Setup Guide for Leeya

## Prerequisites Check

First, let's check if Node.js is installed:

```bash
node --version
```

If you see a version number (like v18.x.x), you're good. If not, download Node.js from https://nodejs.org/

---

## Step 1: Clean Up Any Previous Attempts

```bash
# Remove any existing config file
rm -f ~/Library/Application\ Support/Claude/claude_desktop_config.json

# Remove any old proxy files
rm -f ~/mcp-files/outreach-proxy.cjs

# Make sure the directory exists
mkdir -p ~/mcp-files
```

---

## Step 2: Download the Proxy Script

```bash
# Navigate to the mcp-files directory
cd ~/mcp-files

# Download the proxy script from Raphael's server
curl -o outreach-proxy.cjs https://mcp-outreach-server-production.up.railway.app/download/proxy

# Make it executable
chmod +x outreach-proxy.cjs

# Verify it downloaded correctly (should be about 24KB)
ls -lh outreach-proxy.cjs
```

If the file is too small (like 14 bytes), it means the download failed. In that case, we'll create it manually (see Alternative Method below).

---

## Step 3: Create Claude Desktop Configuration

We'll use printf to avoid any quote issues:

```bash
# Create the config file with proper straight quotes
printf '{"mcpServers":{"outreach-remote":{"command":"node","args":["/Users/leeyalazarovic/mcp-files/outreach-proxy.cjs"]}}}' > ~/Library/Application\ Support/Claude/claude_desktop_config.json

# Verify the file was created
cat ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

You should see:
```json
{"mcpServers":{"outreach-remote":{"command":"node","args":["/Users/leeyalazarovic/mcp-files/outreach-proxy.cjs"]}}}
```

---

## Step 4: Verify Everything is Correct

```bash
# Check the config file exists and has the right content
echo "Config file:"
cat ~/Library/Application\ Support/Claude/claude_desktop_config.json

echo -e "\nProxy file size:"
ls -lh ~/mcp-files/outreach-proxy.cjs

echo -e "\nNode.js version:"
node --version
```

---

## Step 5: Restart Claude Desktop

1. **Completely quit Claude Desktop**
   - Press `Cmd + Q` while Claude is active
   - Or right-click Claude in the dock and select "Quit"

2. **Wait 5 seconds**

3. **Reopen Claude Desktop**
   - Should open without any error messages

---

## Step 6: Test the Connection

In Claude, type these commands one by one:

1. **First test:**
   ```
   List all available Outreach tools
   ```
   
   **Expected result:** A list of 24 tools

2. **If you see "MCP server not initialized":**
   - Wait 30 seconds (server is waking up)
   - Try again

3. **Second test:**
   ```
   Check the health of the Outreach server
   ```
   
   **Expected result:** Health status showing "healthy"

4. **Third test:**
   ```
   Create a test prospect named John Doe with email john.doe@example.com
   ```
   
   **Expected result:** Confirmation that prospect was created

---

## Alternative Method: Manual Proxy Script Creation

If the download doesn't work (file is too small), ask Raphael to:

1. **Create a GitHub Gist:**
   - Go to https://gist.github.com
   - Paste the contents of outreach-proxy.cjs
   - Make it public
   - Share the raw URL

2. **Or send the file directly via:**
   - Email
   - Slack/Discord
   - File sharing service

Then you can create the file manually:

```bash
# Open nano editor
nano ~/mcp-files/outreach-proxy.cjs

# Paste the contents Raphael provides
# Save with Ctrl+X, then Y, then Enter

# Make it executable
chmod +x ~/mcp-files/outreach-proxy.cjs
```

---

## Troubleshooting

### "Command not found: node"
- Install Node.js from https://nodejs.org/

### "MCP server not initialized"
- Wait 30 seconds and try again (server needs to wake up)

### "Error reading or parsing claude_desktop_config.json"
- You have curly quotes instead of straight quotes
- Run this to fix:
```bash
rm ~/Library/Application\ Support/Claude/claude_desktop_config.json
printf '{"mcpServers":{"outreach-remote":{"command":"node","args":["/Users/leeyalazarovic/mcp-files/outreach-proxy.cjs"]}}}' > ~/Library/Application\ Support/Claude/claude_desktop_config.json
```

### Claude doesn't respond to Outreach commands
- Make sure you completely quit Claude (not just closed window)
- Verify Node.js is installed: `node --version`
- Check proxy file exists: `ls -lh ~/mcp-files/outreach-proxy.cjs`
- Check config file: `cat ~/Library/Application\ Support/Claude/claude_desktop_config.json`

### Test the server directly
```bash
curl https://mcp-outreach-server-production.up.railway.app/health
```
Should return JSON with "status": "healthy"

---

## What You Can Do Once Connected

### Basic Commands:
```
Create a prospect named Sarah Johnson with email sarah@techcorp.com at company TechCorp

Search for prospects with tag "hot-lead"

List all my Outreach sequences

Get all available mailboxes
```

### Advanced Commands:
```
Create a complete email sequence called "Q1 Outreach" with 3 emails:
1. Initial outreach (day 0): "Quick question about {{account.name}}"
2. Follow-up (day 3): "Following up on my previous email"
3. Final touch (day 7): "Final thoughts on our solution"

Then enroll john@example.com in this sequence
```

### Bulk Operations:
```
Create 5 prospects in bulk:
- Alice Johnson, alice@startup.io, Startup Inc, CEO
- Bob Wilson, bob@tech.co, Tech Co, CTO
- Carol Brown, carol@sales.com, Sales Corp, VP Sales
- David Lee, david@market.io, Market Inc, CMO
- Eve Davis, eve@product.co, Product Co, PM
```

---

## Success Checklist

- [ ] Node.js is installed
- [ ] Created ~/mcp-files directory
- [ ] Downloaded outreach-proxy.cjs (should be ~24KB)
- [ ] Created claude_desktop_config.json with straight quotes
- [ ] Restarted Claude Desktop
- [ ] No error messages when opening Claude
- [ ] "List all available Outreach tools" works
- [ ] Can create test prospects

Once all items are checked, you're ready to use all 24 Outreach tools! ðŸŽ‰

---

## Need Help?

If the proxy download doesn't work from the server, ask Raphael to either:
1. Make the repository public temporarily
2. Create a public Gist with the proxy script
3. Send the file directly

The server health check URL: https://mcp-outreach-server-production.up.railway.app/health

NaN
FILE: MCP_TOOL_EXECUTION_GUIDE.md
SIZE: 5.52 KB | LINES: 275
MODIFIED: 2025-08-28T12:11:55.276Z
NaN

# Outreach MCP Tool Execution Guide

## ðŸ”§ **Available MCP Tools**

### **Sequence Management**
- `find_sequence` - Find existing sequences by name
- `create_sequence` - Create new sequence container
- `get_sequences` - List all sequences

### **Template Management**  
- `create_sequence_template` - Create email templates
- `get_sequence_templates` - List all templates
- `find_sequence_template` - Find template by name

### **Step Management**
- `create_sequence_step` - Add steps to sequences
- `get_sequence_steps` - Get steps for a sequence
- `link_template_to_step` - Connect template to step

### **Prospect Management**
- `create_prospect` - Create new prospect
- `search_prospects` - Find existing prospects
- `add_prospect_to_sequence` - Enroll prospect in sequence

### **Bulk Operations**
- `bulk_create_prospects` - Create multiple prospects at once
- `bulk_create_sequences` - Create multiple sequences
- `bulk_create_templates` - Create multiple templates
- `bulk_enroll_prospects` - Enroll multiple prospects

### **System Tools**
- `get_mailboxes` - List available mailboxes
- `health_check` - Check MCP server status
- `get_performance_metrics` - Get server performance data

## ðŸ“‹ **Tool Execution Format**

Each tool follows this format:

```
[tool_name]
{
  "parameter1": "value1",
  "parameter2": "value2"
}
```

## ðŸŽ¯ **Core Workflow Tools**

### **1. Check Sequence Exists**
```
find_sequence
{
  "name": "Sequence Name Here"
}
```

### **2. Create Sequence**
```
create_sequence
{
  "name": "Sequence Name",
  "description": "Sequence description",
  "tags": ["tag1", "tag2"],
  "shareType": "shared"
}
```
*Returns: sequence ID*

### **3. Create Email Template**
```
create_sequence_template
{
  "name": "Template Name",
  "subject": "Email subject with {{first_name}}",
  "bodyHtml": "<![CDATA[Email content with {{first_name}} and {{account.name}}]]>",
  "tags": ["tag1", "tag2"],
  "trackLinks": true,
  "trackOpens": true
}
```
*Returns: template ID*

### **4. Create Sequence Step**
```
create_sequence_step
{
  "sequenceId": "sequence_id_from_step_2",
  "stepType": "auto_email",
  "order": 1,
  "intervalInDays": 0
}
```
*Returns: step ID*

### **5. Link Template to Step**
```
link_template_to_step
{
  "sequenceStepId": "step_id_from_step_4",
  "templateId": "template_id_from_step_3"
}
```

### **6. Create Prospect**
```
create_prospect
{
  "firstName": "First",
  "lastName": "Last", 
  "email": "email@company.com",
  "company": "Company Name",
  "title": "Job Title"
}
```
*Returns: prospect ID*

### **7. Enroll Prospect in Sequence**
```
add_prospect_to_sequence
{
  "prospectId": "prospect_id_from_step_6",
  "sequenceId": "sequence_id_from_step_2"
}
```

## ðŸš€ **Bulk Operations**

### **Bulk Create Multiple Prospects**
```
bulk_create_prospects
{
  "prospects": [
    {
      "firstName": "John",
      "lastName": "Doe",
      "email": "john@company.com",
      "company": "Company A",
      "title": "CEO"
    },
    {
      "firstName": "Jane",
      "lastName": "Smith", 
      "email": "jane@company.com",
      "company": "Company B",
      "title": "CTO"
    }
  ],
  "options": {
    "batchSize": 25,
    "continueOnError": true
  }
}
```

### **Bulk Create Multiple Templates**
```
bulk_create_templates
{
  "templates": [
    {
      "name": "Template 1",
      "subject": "Subject 1 with {{first_name}}",
      "bodyHtml": "<![CDATA[Content 1 with {{first_name}}]]>",
      "tags": ["campaign1"]
    },
    {
      "name": "Template 2", 
      "subject": "Subject 2 with {{first_name}}",
      "bodyHtml": "<![CDATA[Content 2 with {{account.name}}]]>",
      "tags": ["campaign1"]
    }
  ]
}
```

### **Bulk Enroll Prospects**
```
bulk_enroll_prospects
{
  "enrollments": [
    {
      "prospectId": "123",
      "sequenceId": "456"
    },
    {
      "prospectId": "789", 
      "sequenceId": "456"
    }
  ]
}
```

## ðŸ” **Search and List Tools**

### **Find Existing Prospects**
```
search_prospects
{
  "email": "john@company.com"
}
```

### **List All Sequences**
```
get_sequences
{
  "limit": 50
}
```

### **Get Available Mailboxes**
```
get_mailboxes
{}
```

## ðŸ“Š **Monitoring Tools**

### **Check Server Health**
```
health_check
{}
```

### **Get Performance Metrics**
```
get_performance_metrics
{
  "includeDetails": true
}
```

### **Get Cache Statistics**
```
get_cache_stats
{}
```

## âš¡ **Key Parameters**

### **Required Fields:**
- **Prospects**: firstName, lastName, email
- **Sequences**: name
- **Templates**: name, subject
- **Steps**: sequenceId
- **Linking**: sequenceStepId, templateId

### **Common Parameters:**
- **shareType**: "shared" (recommended for team visibility)
- **stepType**: "auto_email" (for automated emails)
- **trackLinks/trackOpens**: true (for analytics)
- **intervalInDays**: 0, 3, 4, 5 (typical timing)

### **Personalization Variables:**
- `{{first_name}}` - Prospect's first name
- `{{account.name}}` - Company name
- `{{sender.firstName}}` - Sender's first name

### **HTML Formatting:**
- Wrap HTML content in `<![CDATA[...]]>`
- Use `<br>` for line breaks
- Use `<b>` for bold text

## ðŸŽ¯ **Simple Execution Sequence**

1. **find_sequence** â†’ Check if exists
2. **create_sequence** â†’ Get sequence ID  
3. **create_sequence_template** â†’ Get template ID (repeat for each email)
4. **create_sequence_step** â†’ Get step ID (repeat for each step)
5. **link_template_to_step** â†’ Connect each template to its step
6. **create_prospect** â†’ Get prospect ID (or use bulk_create_prospects)
7. **add_prospect_to_sequence** â†’ Enroll prospect

**Result**: Complete working sequence with prospects enrolled and ready to execute.

NaN
FILE: README.md
SIZE: 6.34 KB | LINES: 248
MODIFIED: 2025-08-19T12:07:20.897Z
NaN

# MCP Outreach Server

A Model Context Protocol (MCP) server that provides Claude with direct integration to Outreach.io's sales engagement platform.

## Features

- **Prospect Management**: Create, search, update, and tag prospects
- **Sequence Operations**: Manage sequences and prospect enrollments
- **Account Management**: Create and search company accounts
- **Mailbox Access**: List available mailboxes for sending
- **OAuth 2.0 Authentication**: Secure token-based authentication
- **Comprehensive Error Handling**: Proper error handling for rate limits and authentication

## Prerequisites

- Node.js v18 or higher
- Outreach.io account with API access
- OAuth 2.0 application registered in Outreach

## Quick Start

### 1. Set Up Outreach OAuth Application

1. Log into your Outreach account as an admin
2. Navigate to **Settings â†’ Integrations â†’ API Access**
3. Click **Create New App** or **Register Application**
4. Fill in the details:
   - **Application Name**: "MCP Integration"
   - **Redirect URI**: `http://localhost:3000/callback`
   - **Application Type**: "Private" or "Internal"
5. Select required scopes:
   - `accounts.all` - Account management
   - `prospects.all` - Prospect management
   - `sequences.all` - Sequence operations
   - `sequenceStates.all` - Sequence enrollment
   - `mailboxes.all` - Mailbox access
   - `tags.all` - Tag management
   - `users.all` - User information
6. Save and copy your **Client ID** and **Client Secret**

### 2. Install and Configure

```bash
# Clone/download the project
git clone <repository-url>
cd mcp-outreach-server

# Install dependencies
npm install

# Create environment file
cp .env.example .env
```

Edit `.env` with your OAuth credentials:
```bash
OUTREACH_CLIENT_ID=your_client_id_here
OUTREACH_CLIENT_SECRET=your_client_secret_here
OUTREACH_REDIRECT_URI=http://localhost:3000/callback
OUTREACH_API_BASE_URL=https://api.outreach.io/api/v2
MCP_SERVER_NAME=outreach-mcp
MCP_SERVER_PORT=3000
```

### 3. Get OAuth Refresh Token

```bash
# Run OAuth setup (opens browser automatically)
npm run setup
```

This will:
- Open your browser to authorize with Outreach
- Save the refresh token to your `.env` file
- Display success confirmation

## Usage with Claude Desktop

1. Add the server to your Claude Desktop configuration:

Edit `~/Library/Application Support/Claude/claude_desktop_config.json`:

### For OAuth (Recommended):
```json
{
  "mcpServers": {
    "outreach": {
      "command": "node",
      "args": ["/path/to/mcp-outreach-server/dist/index.js"],
      "env": {
        "OUTREACH_CLIENT_ID": "your_oauth_client_id_here",
        "OUTREACH_CLIENT_SECRET": "your_oauth_client_secret_here",
        "OUTREACH_REDIRECT_URI": "http://localhost:3000/callback"
      }
    }
  }
}
```

### For Personal Access Token:
```json
{
  "mcpServers": {
    "outreach": {
      "command": "node",
      "args": ["/path/to/mcp-outreach-server/dist/index.js"],
      "env": {
        "OUTREACH_API_TOKEN": "your_outreach_api_token_here"
      }
    }
  }
}
```

2. Restart Claude Desktop

3. **First-time OAuth setup**: If using OAuth, the first time you use the server, it will:
   - Open your browser to authorize the app
   - Ask you to log into Outreach and approve access
   - Store the tokens locally in `~/.mcp-outreach/token.json`
   - Automatically refresh tokens as needed

## Available Tools

### create_sequence
Create a new sequence in Outreach.

Parameters:
- `name` (required): Name of the sequence
- `description`: Description of the sequence
- `enabled`: Whether the sequence is enabled (default: true)
- `shareType`: Share type - private, read_only, or shared (default: private)

### list_sequences
List all sequences in your Outreach account.

Parameters:
- `limit`: Number of sequences to return (default: 50)
- `offset`: Offset for pagination (default: 0)

### search_accounts
Search for accounts by name or domain.

Parameters:
- `query` (required): Search query (name or domain)
- `limit`: Number of accounts to return (default: 20)

### get_account_prospects
Get prospects from a specific account.

Parameters:
- `accountId`: ID of the account
- `accountName`: Name of the account (alternative to accountId)
- `limit`: Number of prospects to return (default: 100)

### add_prospects_to_sequence
Add prospects to a sequence.

Parameters:
- `sequenceId` (required): ID of the sequence
- `prospectIds` (required): Array of prospect IDs to add
- `mailboxId`: ID of the mailbox to use for sending

### create_sequence_step
Add a step to a sequence.

Parameters:
- `sequenceId` (required): ID of the sequence
- `order` (required): Order of the step in the sequence
- `interval`: Days to wait before this step (default: 1)
- `stepType` (required): Type of step - auto_email, manual_email, call, task, or linkedin_send_message
- `subject`: Email subject (for email steps)
- `body`: Content of the step

## Example Workflows

### Create a sequence and add prospects

1. Create a new sequence:
```
"Create a new sequence called 'Q1 Outreach Campaign' with description 'Targeting enterprise accounts'"
```

2. Search for an account:
```
"Search for accounts with domain acme.com"
```

3. Load prospects from the account:
```
"Get all prospects from account ID 12345"
```

4. Add prospects to the sequence:
```
"Add prospect IDs [1001, 1002, 1003] to sequence ID 5678"
```

### Build a multi-step email sequence

1. Create the sequence:
```
"Create a sequence called 'Product Demo Follow-up'"
```

2. Add email steps:
```
"Add an auto_email step to sequence 5678 with subject 'Thanks for your interest' that sends immediately"
"Add another auto_email step that waits 3 days with subject 'Quick follow-up'"
```

## Development

To run in development mode:
```bash
npm run dev
```

To build:
```bash
npm run build
```

## API Rate Limits

Please be aware of Outreach API rate limits:
- Standard rate limit: 10,000 requests per hour
- Bulk operations may have additional limits

The server implements error handling for rate limit responses.

## Troubleshooting

### Authentication Errors
- Ensure your API token is valid and has the required scopes
- Check that the token is properly set in your environment

### Connection Issues
- Verify your network connection
- Check if the Outreach API endpoint is accessible

### Permission Errors
- Ensure your API token has the necessary permissions for the operations you're trying to perform
- Some operations may require admin privileges in Outreach

## License

MIT

NaN
FILE: REMOTE-MCP-SUCCESS-GUIDE.md
SIZE: 6.62 KB | LINES: 193
MODIFIED: 2025-08-28T19:14:49.455Z
NaN

# ðŸš€ Remote MCP Server Success Guide

## âœ… WHAT WE ACHIEVED
Successfully created a **remote MCP server** that allows multiple users to access Outreach tools via Claude Desktop without any local setup, OAuth configuration, or API keys on their end.

## ðŸ—ï¸ WINNING ARCHITECTURE

### **Core Problem Solved**
- **Challenge**: Claude Desktop's MCP protocol expects stdio communication, but remote servers use HTTP
- **Solution**: Created a proper **stdio-to-HTTP bridge** that translates MCP protocol correctly

### **Architecture Overview**
```
Claude Desktop (stdio) 
    â†“ (JSON-RPC over stdio)
outreach-proxy.cjs (Bridge)
    â†“ (HTTP requests with API key)
Railway Server (HTTP MCP Server)
    â†“ (Authenticated API calls)
Outreach API
```

## ðŸ› ï¸ KEY COMPONENTS

### 1. **Railway HTTP Server** (`server.js`)
- **Purpose**: Hosts MCP tools over HTTP with API key authentication
- **Endpoints**: 
  - `/tools/call` - Executes MCP tools
  - `/health` - Server health check
- **Authentication**: API key middleware (`x-api-key` header)
- **Environment**: All OAuth credentials stored securely in Railway

### 2. **Stdio-to-HTTP Bridge** (`outreach-proxy.cjs`)
- **Purpose**: Translates Claude Desktop's stdio MCP protocol to HTTP requests
- **Key Features**:
  - Proper JSON-RPC 2.0 message handling
  - Complete tool schema definitions (24 tools)
  - Request buffering and parsing
  - Error handling with correct error codes

### 3. **Tool Definitions** (Embedded in proxy)
- **24 Enhanced Tools** including:
  - High-level workflow tools (`create_complete_email_sequence`)
  - Bulk operations (`bulk_create_prospects`)
  - Performance monitoring (`get_performance_metrics`)
  - Core Outreach operations (`create_prospect`, `get_sequences`)

## ðŸ”§ CRITICAL SUCCESS FACTORS

### **1. JSON-RPC Protocol Compliance**
```javascript
// âœ… CORRECT Response Format
{
  "jsonrpc": "2.0",
  "id": request.id,           // MUST match request ID
  "result": { /* data */ }    // OR "error": { code, message }
}

// âŒ WRONG Format (what was causing validation errors)
{
  "error": "message"  // Missing jsonrpc, id fields
}
```

### **2. MCP Method Handling**
```javascript
// Essential MCP methods the proxy MUST handle:
- "initialize" -> Server capability negotiation
- "tools/list" -> Return all available tools with schemas
- "tools/call" -> Execute specific tools with parameters
- "notifications/initialized" -> Acknowledge initialization (no response)
```

### **3. Message Buffering**
```javascript
// Critical for handling multiple JSON messages in stdio stream
let buffer = '';
process.stdin.on('data', (data) => {
  buffer += data.toString();
  const lines = buffer.split('\n');
  buffer = lines.pop() || ''; // Keep incomplete line
  
  for (const line of lines) {
    if (line.trim()) {
      const request = JSON.parse(line);
      await processRequest(request);
    }
  }
});
```

## ðŸ“‹ DEPLOYMENT CHECKLIST

### **Railway Server Setup**
- [x] Environment variables: `OUTREACH_CLIENT_ID`, `OUTREACH_CLIENT_SECRET`, `OUTREACH_REFRESH_TOKEN`
- [x] API key authentication middleware
- [x] `/tools/call` endpoint for tool execution
- [x] Proper JSON-RPC error responses
- [x] CORS headers for cross-origin requests

### **Bridge Script (`outreach-proxy.cjs`)**
- [x] All 24 tool definitions with complete schemas
- [x] JSON-RPC 2.0 compliant responses
- [x] Proper error handling with correct codes (-32700, -32601, -32603)
- [x] Message buffering for stdio communication
- [x] HTTP client with authentication headers

### **User Configuration**
- [x] Simple `claude_desktop_config.json` entry
- [x] No API keys or OAuth required from users
- [x] Single file distribution (`outreach-proxy.cjs`)

## ðŸŽ¯ LESSONS LEARNED

### **What Broke Originally**
1. **SDK Version Issues**: Using `@modelcontextprotocol/sdk@^1.17.3` vs Lemlist's `^0.5.0`
2. **Custom Connector vs MCP Server**: Tried using Claude's custom connector feature instead of native MCP server support
3. **JSON-RPC Format**: Missing required fields (`jsonrpc`, `id`) in error responses
4. **HTTP vs Stdio**: Direct HTTP server instead of proper stdio-to-HTTP bridge

### **What Fixed It**
1. **Analyzed Working Implementation**: Studied Lemlist's successful MCP remote server
2. **Proper Bridge Pattern**: Created stdio-to-HTTP proxy following proven patterns
3. **Complete Tool Migration**: Moved all 24 enhanced tools to remote proxy
4. **Protocol Compliance**: Fixed all JSON-RPC validation issues

## ðŸ“ˆ SCALING STRATEGY

### **For New MCP Servers**
1. **Copy Architecture**: Use the same Railway + Bridge pattern
2. **Tool Migration**: Extract tools from local server to bridge proxy
3. **Authentication**: Implement API key middleware for security
4. **Testing**: Validate JSON-RPC compliance before deployment

### **For Multiple Services**
1. **Unified Bridge**: Create multi-service proxy that routes to different backends
2. **Service Discovery**: Dynamic tool loading from multiple MCP servers
3. **Load Balancing**: Multiple Railway instances behind load balancer
4. **Monitoring**: Centralized logging and metrics collection

### **For Enterprise Distribution**
1. **Package Management**: npm package for easy installation
2. **Configuration Templates**: Pre-built config files for common setups
3. **Documentation**: Step-by-step setup guides for different platforms
4. **Support Tools**: Health check and troubleshooting utilities

## ðŸ”— FILE STRUCTURE
```
/Users/raphaelberrebi/mcp-outreach-server/
â”œâ”€â”€ server.js                    # Railway HTTP MCP server
â”œâ”€â”€ outreach-proxy.cjs          # Stdio-to-HTTP bridge (DISTRIBUTION FILE)
â”œâ”€â”€ src/enhanced-tools.js       # Original tool definitions  
â”œâ”€â”€ dist/index.js              # Compiled MCP server (local use)
â””â”€â”€ REMOTE-MCP-SUCCESS-GUIDE.md # This documentation
```

## ðŸŽ DISTRIBUTION PACKAGE

**For other users, they only need:**
1. `outreach-proxy.cjs` (single file)
2. Claude Desktop config entry
3. No additional dependencies or setup

**Example Distribution:**
```bash
# User downloads single file
curl -o outreach-proxy.cjs https://raw.githubusercontent.com/[repo]/outreach-proxy.cjs
chmod +x outreach-proxy.cjs

# Add to Claude Desktop config
{
  "mcpServers": {
    "outreach-remote": {
      "command": "node",
      "args": ["/path/to/outreach-proxy.cjs"]
    }
  }
}

# Restart Claude Desktop and use Outreach tools!
```

---

## ðŸ† SUCCESS METRICS
- âœ… **Zero JSON-RPC validation errors**
- âœ… **24 tools available remotely**  
- âœ… **No user-side OAuth setup required**
- âœ… **Single-file distribution**
- âœ… **Production-ready on Railway**
- âœ… **Scalable architecture pattern**

**This architecture can now be replicated for ANY MCP server to create remote access!** ðŸš€

NaN
FILE: SCALING-TEMPLATE.md
SIZE: 9.42 KB | LINES: 387
MODIFIED: 2025-08-28T19:15:57.688Z
NaN

# ðŸš€ MCP Remote Server Scaling Template

## REPLICATION BLUEPRINT
Use this template to convert ANY local MCP server into a remote-accessible server.

## ðŸ“‹ STEP-BY-STEP REPLICATION

### **Phase 1: Analyze Existing MCP Server**
```bash
# 1. Identify your local MCP server files
find . -name "*mcp*" -o -name "*tools*" -o -name "*index.js"

# 2. Extract tool definitions
grep -r "name.*:" src/ | grep -v "description"

# 3. Find tool schemas
grep -A 20 "inputSchema" src/
```

### **Phase 2: Create HTTP Server** 
**File: `server.js`**
```javascript
#!/usr/bin/env node
import express from 'express';
import cors from 'cors';

const app = express();
const PORT = process.env.PORT || 3000;
const API_KEY = 'your-generated-api-key';

app.use(cors());
app.use(express.json());

// API Key Middleware
app.use((req, res, next) => {
  const openPaths = ['/health', '/', '/auth'];
  if (openPaths.includes(req.path)) return next();
  
  const key = req.headers['x-api-key'];
  if (key !== API_KEY) {
    return res.status(401).json({
      jsonrpc: '2.0',
      id: req.body?.id || null,
      error: { code: -32001, message: 'Unauthorized: Invalid API key' }
    });
  }
  next();
});

// Tools endpoint
app.post('/tools/call', async (req, res) => {
  try {
    const { name, arguments: args = {} } = req.body;
    
    // TODO: Add your tool execution logic here
    // Example: const result = await yourMCPServer.callTool(name, args);
    
    const response = {
      jsonrpc: '2.0',
      id: req.body.id || Date.now(),
      result: {
        content: [{ type: 'text', text: `Tool ${name} executed successfully` }]
      }
    };
    res.json(response);
  } catch (error) {
    const errorResponse = {
      jsonrpc: '2.0',
      id: req.body?.id || null,
      error: { code: -32603, message: error.message }
    };
    res.status(500).json(errorResponse);
  }
});

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    timestamp: new Date().toISOString()
  });
});

app.listen(PORT, () => {
  console.log(`ðŸŒ [SERVICE_NAME] MCP Server running on port ${PORT}`);
});
```

### **Phase 3: Create Bridge Script**
**File: `[service]-proxy.cjs`**
```javascript
#!/usr/bin/env node

const https = require('https');
const http = require('http');

// Configuration
const SERVER_URL = 'https://your-app.railway.app';
const API_KEY = 'your-api-key';

// TODO: Replace with your actual tools from your MCP server
const TOOLS = [
  {
    name: 'example_tool',
    description: 'Example tool description',
    inputSchema: {
      type: 'object',
      properties: {
        param1: { type: 'string', description: 'Example parameter' }
      },
      required: ['param1']
    }
  }
  // Add all your tools here...
];

let buffer = '';

function makeHttpRequest(data) {
  return new Promise((resolve, reject) => {
    const url = new URL(SERVER_URL + '/tools/call');
    const options = {
      hostname: url.hostname,
      port: url.port || (url.protocol === 'https:' ? 443 : 80),
      path: url.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': API_KEY,
        'Content-Length': Buffer.byteLength(JSON.stringify(data))
      }
    };

    const client = url.protocol === 'https:' ? https : http;
    const req = client.request(options, (res) => {
      let responseData = '';
      res.on('data', (chunk) => responseData += chunk);
      res.on('end', () => {
        try {
          resolve(JSON.parse(responseData));
        } catch (e) {
          resolve({ error: 'Invalid JSON response', data: responseData });
        }
      });
    });

    req.on('error', reject);
    req.write(JSON.stringify(data));
    req.end();
  });
}

async function processRequest(request) {
  try {
    let response;

    if (request.method === 'initialize') {
      response = {
        jsonrpc: '2.0',
        id: request.id,
        result: {
          protocolVersion: '2024-11-05',
          capabilities: { tools: {} },
          serverInfo: {
            name: '[SERVICE_NAME]-mcp-server',
            version: '1.0.0'
          }
        }
      };
    } else if (request.method === 'notifications/initialized') {
      return; // No response needed
    } else if (request.method === 'tools/list') {
      response = {
        jsonrpc: '2.0',
        id: request.id,
        result: { tools: TOOLS }
      };
    } else if (request.method === 'tools/call') {
      const { name, arguments: args = {} } = request.params;
      
      try {
        const toolResponse = await makeHttpRequest({ name, arguments: args });
        
        if (toolResponse.error) {
          response = {
            jsonrpc: '2.0',
            id: request.id,
            error: { code: -32603, message: toolResponse.error }
          };
        } else {
          response = {
            jsonrpc: '2.0',
            id: request.id,
            result: toolResponse.result || {
              content: [{ type: 'text', text: JSON.stringify(toolResponse, null, 2) }]
            }
          };
        }
      } catch (error) {
        response = {
          jsonrpc: '2.0',
          id: request.id,
          error: { code: -32603, message: `Tool call failed: ${error.message}` }
        };
      }
    } else {
      response = {
        jsonrpc: '2.0',
        id: request.id,
        error: { code: -32601, message: `Method not found: ${request.method}` }
      };
    }

    if (response) {
      console.log(JSON.stringify(response));
    }

  } catch (error) {
    const errorResponse = {
      jsonrpc: '2.0',
      id: request.id || null,
      error: { code: -32603, message: `Proxy error: ${error.message}` }
    };
    console.log(JSON.stringify(errorResponse));
  }
}

// Handle stdin
process.stdin.on('data', async (data) => {
  buffer += data.toString();
  const lines = buffer.split('\n');
  buffer = lines.pop() || '';
  
  for (const line of lines) {
    if (line.trim()) {
      try {
        const request = JSON.parse(line);
        await processRequest(request);
      } catch (error) {
        console.log(JSON.stringify({
          jsonrpc: '2.0',
          id: null,
          error: { code: -32700, message: 'Parse error' }
        }));
      }
    }
  }
});

process.stdin.on('end', () => process.exit(0));
console.error(`[Proxy] [SERVICE_NAME] MCP Proxy started, connecting to ${SERVER_URL}`);
```

### **Phase 4: Deploy to Railway**
```bash
# 1. Initialize Railway project
railway init

# 2. Set environment variables
railway variables set API_KEY=your-generated-api-key
railway variables set SERVICE_SPECIFIC_VAR=value

# 3. Deploy
railway up

# 4. Get deployment URL
railway domain
```

### **Phase 5: Package for Distribution**
```bash
# 1. Make proxy executable
chmod +x [service]-proxy.cjs

# 2. Test locally
echo '{"jsonrpc": "2.0", "id": 1, "method": "tools/list"}' | node [service]-proxy.cjs

# 3. Create README for users
cat > DISTRIBUTION-README.md << EOF
# [SERVICE_NAME] Remote MCP Server

## Quick Setup
1. Download: \`[service]-proxy.cjs\`
2. Add to Claude Desktop config:
   \`\`\`json
   {
     "mcpServers": {
       "[service]-remote": {
         "command": "node",
         "args": ["/path/to/[service]-proxy.cjs"]
       }
     }
   }
   \`\`\`
3. Restart Claude Desktop
4. Use [SERVICE_NAME] tools!

## Available Tools
- tool1: Description
- tool2: Description
EOF
```

## ðŸ”§ CUSTOMIZATION CHECKLIST

### **Replace These Placeholders:**
- [ ] `[SERVICE_NAME]` - Your service name (e.g., "lemlist", "hubspot")
- [ ] `your-generated-api-key` - Generate a secure API key
- [ ] Tool definitions in `TOOLS` array
- [ ] HTTP server tool execution logic
- [ ] Environment variables for your service
- [ ] Railway app configuration

### **Tool Migration Process:**
1. **Extract from local MCP server**:
   ```bash
   # Find tool definitions
   grep -A 50 "name.*:" src/tools.js
   ```

2. **Convert to proxy format**:
   ```javascript
   {
     name: 'tool_name',
     description: 'Tool description', 
     inputSchema: { /* complete schema */ }
   }
   ```

3. **Test tool execution**:
   ```bash
   curl -X POST http://localhost:3000/tools/call \
     -H "Content-Type: application/json" \
     -H "x-api-key: your-key" \
     -d '{"name": "tool_name", "arguments": {}}'
   ```

## ðŸ“Š SUCCESS VALIDATION

### **Test Checklist:**
- [ ] Bridge responds to `initialize` method
- [ ] Bridge returns all tools in `tools/list`
- [ ] Bridge executes tools via `tools/call`
- [ ] No JSON-RPC validation errors in Claude Desktop
- [ ] All tools accessible from Claude Desktop
- [ ] HTTP server handles authentication correctly
- [ ] Railway deployment stable and accessible

### **Performance Benchmarks:**
- Response time: < 2 seconds for tool calls
- Bridge startup: < 1 second
- Memory usage: < 100MB
- Claude Desktop connection: Immediate

---

## ðŸŽ¯ QUICK DEPLOYMENT COMMANDS

```bash
# Full deployment in one script
#!/bin/bash

# 1. Setup
SERVICE_NAME="your-service"
API_KEY=$(openssl rand -hex 32)

# 2. Create files from templates above
# 3. Deploy to Railway
railway login
railway init
railway variables set API_KEY=$API_KEY
railway up

# 4. Test
RAILWAY_URL=$(railway status --json | jq -r '.domains[0]')
echo '{"name":"health_check","arguments":{}}' | \
curl -X POST $RAILWAY_URL/tools/call \
  -H "Content-Type: application/json" \
  -H "x-api-key: $API_KEY" \
  -d @-

echo "âœ… $SERVICE_NAME MCP Server deployed successfully!"
echo "ðŸ“¦ Distribute: ${SERVICE_NAME}-proxy.cjs"
echo "ðŸ”— Server URL: $RAILWAY_URL"
```

This template can create remote MCP servers for ANY service following the proven Outreach pattern! ðŸš€

NaN
FILE: SETUP-COMPLETE.md
SIZE: 4.28 KB | LINES: 152
MODIFIED: 2025-08-19T15:24:19.864Z
NaN

# ðŸŽ‰ Complete MCP Outreach Server Setup Guide

## âœ… What This MCP Server Provides

**Full Outreach Sequence Management from Claude:**
- Create sequences
- Create sequence steps (email, call, task)
- Create email templates with HTML content
- Link templates to sequence steps
- Add prospects to sequences
- Manage all Outreach data through Claude

## ðŸ” Required OAuth Scopes

Your Outreach OAuth app needs **ALL** these scopes:

```
mailboxes.all
prospects.all
sequences.all
sequenceSteps.all
sequenceStates.all
templates.all
sequenceTemplates.all
users.all
```

## ðŸš€ Setup Steps

### 1. Create Outreach OAuth App
1. Go to Outreach â†’ Settings â†’ Integrations â†’ API Access
2. Create New App with name "MCP Integration"
3. Set Redirect URI: `https://your-railway-app.railway.app/callback`
4. Add **ALL 8 scopes** listed above
5. Copy Client ID and Client Secret

### 2. Install MCP Server
```bash
git clone https://github.com/yourusername/mcp-outreach-server.git
cd mcp-outreach-server
npm install
cp .env.example .env
```

### 3. Configure Environment
Edit `.env`:
```env
OUTREACH_CLIENT_ID=your_client_id
OUTREACH_CLIENT_SECRET=your_client_secret
OUTREACH_REDIRECT_URI=https://your-railway-app.railway.app/callback
```

### 4. Get OAuth Refresh Token
```bash
node get-auth-url.js
# Visit the URL, authorize, copy the code
node exchange-new-code.js YOUR_CODE_HERE
```

### 5. Configure Claude Desktop
Edit `~/Library/Application Support/Claude/claude_desktop_config.json`:
```json
{
  "mcpServers": {
    "outreach": {
      "command": "node",
      "args": ["/full/path/to/mcp-outreach-server/src/index.js"],
      "env": {
        "OUTREACH_CLIENT_ID": "your_client_id",
        "OUTREACH_CLIENT_SECRET": "your_client_secret", 
        "OUTREACH_REFRESH_TOKEN": "your_refresh_token_from_env_file",
        "OUTREACH_API_BASE_URL": "https://api.outreach.io/api/v2"
      }
    }
  }
}
```

### 6. Test in Claude
Restart Claude Desktop and try:
- "Create a new sequence called 'Product Demo'"
- "Create an email template with subject 'Hello {{prospect.firstName}}'"
- "Add an email step to sequence ID 123"
- "Link template ID 456 to sequence step ID 789"

## ðŸ”§ Available Tools

**Sequence Management:**
- `create_sequence` - Create new sequences
- `get_sequences` - List all sequences
- `find_sequence` - Find sequence by name
- `create_sequence_step` - Add steps to sequences
- `get_sequence_steps` - View sequence steps

**Template Management:**
- `create_sequence_template` - Create email templates
- `get_sequence_templates` - List all templates
- `find_sequence_template` - Find template by name
- `update_sequence_template` - Edit templates
- `link_template_to_step` - Connect templates to steps

**Prospect Management:**
- `create_prospect` - Add new prospects
- `search_prospects` - Find prospects
- `add_prospect_to_sequence` - Enroll prospects

**Other Tools:**
- `get_mailboxes` - List available mailboxes
- `health_check` - Test API connection

## ðŸŽ¯ Example Workflows

**Create Complete Sequence:**
1. "Create a sequence called 'Welcome Series'"
2. "Create an email template called 'Welcome Email' with subject 'Welcome {{prospect.firstName}}!'"
3. "Add an email step to sequence ID [sequence_id]"
4. "Link template ID [template_id] to sequence step ID [step_id]"
5. "Add prospect john@example.com to sequence ID [sequence_id]"

**Template Variables:**
Use Outreach variables in templates:
- `{{prospect.firstName}}` - Prospect's first name
- `{{prospect.lastName}}` - Prospect's last name  
- `{{prospect.company}}` - Company name
- `{{sender.firstName}}` - Your name

## ðŸ”’ Security Notes

- Keep Client Secret secure
- Refresh tokens auto-renew
- All API calls are authenticated
- Follows Outreach rate limits

## ðŸ› Troubleshooting

**"Unauthorized OAuth Scope" error:**
- Add the missing scope to your Outreach OAuth app
- Re-authorize with the new scope
- Update your refresh token

**"Template linking failed":**
- Ensure you have `sequenceTemplates.all` scope
- Template linking creates a sequenceTemplate resource

**Claude doesn't see the server:**
- Check absolute paths in Claude config
- Restart Claude Desktop after config changes
- Verify environment variables

## ðŸŽ‰ Success!

You now have complete Outreach sequence management through Claude! Your team can create sophisticated email sequences entirely through conversation.

NaN
FILE: SIMPLE-SETUP-GUIDE.md
SIZE: 3.35 KB | LINES: 149
MODIFIED: 2025-09-01T08:12:31.133Z
NaN

# ðŸš€ Outreach MCP - Simple Setup Guide for Users

## Quick Setup (2 minutes)

### Step 1: Download the Proxy Script

Open your Terminal and run:

```bash
# Create a directory for MCP files
mkdir ~/mcp-files
cd ~/mcp-files

# Download the proxy script from the server
curl -o outreach-proxy.cjs https://mcp-outreach-server-production.up.railway.app/download/proxy

# Make it executable
chmod +x outreach-proxy.cjs

# Verify it downloaded correctly (should be ~24KB)
ls -lh outreach-proxy.cjs
```

### Step 2: Configure Claude Desktop

1. **Open your Claude Desktop config file:**

   **On macOS:**
   ```bash
   open -e ~/Library/Application\ Support/Claude/claude_desktop_config.json
   ```

   **On Windows:**
   Open in Notepad:
   ```
   %APPDATA%\Claude\claude_desktop_config.json
   ```

2. **Add this configuration:**

   If the file is empty, paste this:
   ```json
   {
     "mcpServers": {
       "outreach-remote": {
         "command": "node",
         "args": ["/Users/YOUR_USERNAME/mcp-files/outreach-proxy.cjs"]
       }
     }
   }
   ```

   If the file already has content, add the outreach-remote section:
   ```json
   {
     "mcpServers": {
       "existing-server": {
         "...": "..."
       },
       "outreach-remote": {
         "command": "node",
         "args": ["/Users/YOUR_USERNAME/mcp-files/outreach-proxy.cjs"]
       }
     }
   }
   ```

3. **IMPORTANT: Replace YOUR_USERNAME with your actual username!**

   To find your username:
   ```bash
   echo $USER
   ```

   Your path will be:
   - Mac: `/Users/[your-username]/mcp-files/outreach-proxy.cjs`
   - Windows: `C:\\Users\\[your-username]\\mcp-files\\outreach-proxy.cjs`

### Step 3: Restart Claude Desktop

1. **Completely quit Claude Desktop** (not just close the window)
   - Mac: Cmd+Q or right-click dock icon â†’ Quit
   - Windows: Right-click system tray icon â†’ Quit

2. **Wait 5 seconds**

3. **Relaunch Claude Desktop**

### Step 4: Test Your Connection

In Claude, type:
```
List all available Outreach tools
```

You should see a list of 24 tools. If you see "MCP server not initialized", wait 30 seconds and try again (the server needs to wake up).

## Available Commands

Once connected, you can use commands like:

- **Create prospects:**
  ```
  Create a prospect named John Smith with email john@techcorp.com
  ```

- **Create email sequences:**
  ```
  Create a 3-email follow-up sequence called "Product Demo Follow-up"
  ```

- **Bulk operations:**
  ```
  Create 5 prospects in bulk from this list:
  - Alice Johnson, alice@startup.io, CEO
  - Bob Wilson, bob@tech.co, CTO
  [etc...]
  ```

## Troubleshooting

### "Command not found: node"
Install Node.js from https://nodejs.org/

### "MCP server not initialized"
The server is waking up. Wait 30 seconds and try again.

### Claude doesn't recognize Outreach commands
1. Make sure you completely quit Claude (not just closed window)
2. Check your config file path is correct
3. Verify the proxy script is executable: `chmod +x ~/mcp-files/outreach-proxy.cjs`

### Still having issues?
Test the server directly:
```bash
curl https://mcp-outreach-server-production.up.railway.app/health
```

Should return JSON with "status": "healthy"

## What This Gives You

âœ… **24 Outreach tools** ready to use
âœ… **No API keys** needed
âœ… **No OAuth setup** required
âœ… **Automatic updates** from the server
âœ… **Full Outreach automation** through Claude

Ready to go! ðŸŽ‰

NaN
FILE: ai-email-generator.js
SIZE: 6.58 KB | LINES: 230
MODIFIED: 2025-08-22T13:06:17.982Z
NaN

import { Anthropic } from '@anthropic-ai/sdk';
import { OpenAI } from 'openai';

export class AIEmailGenerator {
  constructor(config) {
    this.anthropic = new Anthropic({ apiKey: config.anthropicKey });
    this.openai = new OpenAI({ apiKey: config.openaiKey });
    this.model = config.preferredModel || 'claude-3-5-sonnet';
  }

  async generateSequence(researchData, config = {}) {
    const prompt = this.buildSequencePrompt(researchData, config);

    let response;
    if (this.model.includes('claude')) {
      response = await this.anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 4000,
        messages: [{ role: 'user', content: prompt }]
      });
    } else {
      response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 4000
      });
    }

    return this.parseSequenceResponse(response);
  }

  buildSequencePrompt(researchData, config) {
    return `
# AI Email Sequence Generation

## Research Data:
${JSON.stringify(researchData, null, 2)}

## Requirements:
- Style: ${config.style || 'Steve Jobs direct and compelling'}
- Sequence Type: ${config.sequenceType || '5-touch cold outreach'}
- Industry Focus: ${config.industry || 'healthcare'}
- Value Prop: ${config.valueProp || 'digital transformation ROI'}

## Instructions:
Create a ${config.sequenceType} email sequence with these specifications:

### Email 1 (Day 0): Hook + Problem Identification
- Subject: Compelling, personalized hook
- Opening: Reference specific company detail from research
- Problem: Highlight pain point from research data
- Teaser: Hint at solution without revealing everything
- CTA: Soft ask for brief conversation

### Email 2 (Day 3): Social Proof + Case Study
- Subject: Reference to similar company success
- Opening: Acknowledge potential busyness
- Case Study: Specific results from similar company in same industry
- Relevance: Connect to prospect's situation
- CTA: Offer to share more details

### Email 3 (Day 7): Resource + Value
- Subject: Free resource offer
- Opening: Different angle from previous emails
- Resource: Valuable tool/report/assessment
- Value: Clear benefit to prospect
- CTA: Download/access offer

### Email 4 (Day 14): Different Angle + Urgency
- Subject: New approach/angle
- Opening: Reference industry trend/news
- Different Value Prop: Alternative benefit
- Soft Urgency: Time-sensitive opportunity
- CTA: Quick 15-minute call

### Email 5 (Day 21): Breakup + Door Opener
- Subject: "Last email" or similar
- Opening: Acknowledge lack of response
- Assumption: Maybe not the right time
- Door Opener: Open invitation for future
- CTA: Simple yes/no response

## Variables to Use:
- {{first_name}} for prospect first name
- {{account.name}} for company name
- {{account.industry}} for industry
- Use research data for personalization

## Output Format:
Return structured JSON with:
{
  "sequence": {
    "name": "sequence name",
    "description": "sequence description"
  },
  "templates": [
    {
      "step": 1,
      "name": "template name",
      "subject": "email subject",
      "bodyHtml": "HTML email body",
      "bodyText": "plain text version",
      "intervalInDays": 0
    }
  ]
}

Generate compelling, personalized emails using the research data provided.
    `;
  }

  parseSequenceResponse(response) {
    let content;
    if (response.content) {
      content = response.content[0].text;
    } else {
      content = response.choices[0].message.content;
    }

    try {

      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) ||
                       content.match(/\{[\s\S]*\}/);

      if (jsonMatch) {
        return JSON.parse(jsonMatch[1] || jsonMatch[0]);
      }

      throw new Error('No valid JSON found in response');
    } catch (error) {
      console.error('Failed to parse AI response:', error);
      throw new Error('Failed to generate valid sequence structure');
    }
  }

  async generateSingleEmail(context, config = {}) {
    const prompt = `
Generate a compelling ${config.type || 'cold outreach'} email:

Context: ${JSON.stringify(context)}
Style: ${config.style || 'Professional but direct'}
Goal: ${config.goal || 'Schedule a meeting'}

Include:
- Personalized subject line using {{first_name}} or {{account.name}}
- Research-based opening
- Clear value proposition
- Strong call-to-action
- Professional signature

Return JSON format:
{
  "subject": "email subject",
  "bodyHtml": "HTML version",
  "bodyText": "plain text version"
}
    `;

    const response = await this.anthropic.messages.create({
      model: 'claude-3-5-sonnet-20241022',
      max_tokens: 1500,
      messages: [{ role: 'user', content: prompt }]
    });

    return this.parseEmailResponse(response);
  }

  parseEmailResponse(response) {
    const content = response.content[0].text;

    try {
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) ||
                       content.match(/\{[\s\S]*\}/);

      if (jsonMatch) {
        return JSON.parse(jsonMatch[1] || jsonMatch[0]);
      }

      throw new Error('No valid JSON found in email response');
    } catch (error) {
      console.error('Failed to parse email response:', error);
      throw new Error('Failed to generate valid email structure');
    }
  }

  async generateVariants(baseEmail, variantTypes = ['subject', 'opening', 'cta']) {
    const variants = {};

    for (const type of variantTypes) {
      const prompt = `
Create a variant of this email focusing on ${type} optimization:

Original Email: ${JSON.stringify(baseEmail)}

Generate 2 variants with different ${type} approaches.
Return JSON with variant1 and variant2 objects.
      `;

      const response = await this.anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: 2000,
        messages: [{ role: 'user', content: prompt }]
      });

      variants[type] = this.parseVariantResponse(response);
    }

    return variants;
  }

  parseVariantResponse(response) {
    const content = response.content[0].text;

    try {
      const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) ||
                       content.match(/\{[\s\S]*\}/);

      if (jsonMatch) {
        return JSON.parse(jsonMatch[1] || jsonMatch[0]);
      }

      return { variant1: null, variant2: null };
    } catch (error) {
      console.error('Failed to parse variant response:', error);
      return { variant1: null, variant2: null };
    }
  }
}

NaN
FILE: ai-research-workflow.json
SIZE: 1.97 KB | LINES: 60
MODIFIED: 2025-08-22T13:05:22.151Z
NaN

{
  "name": "AI Prospect Research to Outreach Workflow",
  "description": "Automated pipeline from prospect research to sequence creation",
  "workflow": {
    "trigger": {
      "type": "schedule",
      "frequency": "daily",
      "time": "09:00"
    },
    "steps": [
      {
        "id": "research",
        "name": "AI Prospect Research",
        "type": "ai_analysis",
        "inputs": {
          "target_criteria": {
            "industry": "healthcare",
            "company_size": "100-500",
            "job_titles": ["CEO", "CTO", "VP Engineering"],
            "location": "USA"
          },
          "research_sources": [
            "apollo",
            "linkedin_sales_nav",
            "company_website",
            "recent_news"
          ]
        },
        "ai_instructions": "Research prospects matching criteria. Extract: company pain points, recent news, technology stack, growth signals, key initiatives, decision maker info, personalization angles."
      },
      {
        "id": "email_generation",
        "name": "AI Email Sequence Creation",
        "type": "ai_writing",
        "inputs": {
          "research_data": "{{research.output}}",
          "email_style": "steve_jobs_direct",
          "sequence_type": "5_touch_cold_outreach",
          "value_proposition": "healthcare_digital_transformation"
        },
        "ai_instructions": "Create 5-email cold outreach sequence using research data. Include: personalized opening, specific pain point, value proposition, social proof, clear CTA. Use {{first_name}} and {{account.name}} variables."
      },
      {
        "id": "outreach_creation",
        "name": "MCP Outreach Integration",
        "type": "http_request",
        "inputs": {
          "mcp_server": "your_mcp_server",
          "actions": [
            "create_prospects",
            "create_sequence",
            "create_templates",
            "link_templates_to_steps",
            "add_prospects_to_sequence"
          ]
        }
      }
    ]
  }
}

NaN
FILE: analyze-existing-sequences.js
SIZE: 5.39 KB | LINES: 137
MODIFIED: 2025-08-21T07:44:01.475Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function analyzeExistingSequences() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ” Getting existing sequences...');
    const sequencesResponse = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log(`Found ${sequencesResponse.data.data.length} sequences`);

    for (const sequence of sequencesResponse.data.data) {
      console.log(`\nðŸ“‹ SEQUENCE: ${sequence.attributes.name} (ID: ${sequence.id})`);
      console.log(`- Steps: ${sequence.attributes.sequenceStepCount}`);
      console.log(`- Enabled: ${sequence.attributes.enabled}`);

      const stepsResponse = await axios.get(
        `https:
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/vnd.api+json',
            'Accept': 'application/vnd.api+json'
          }
        }
      );

      for (const step of stepsResponse.data.data) {
        console.log(`  ðŸ“§ STEP ${step.attributes.order}: ${step.attributes.stepType}`);
        console.log(`    - ID: ${step.id}`);
        console.log(`    - Interval: ${step.attributes.interval} minutes`);

        const seqTemplatesCount = step.relationships.sequenceTemplates?.data?.length || 0;
        console.log(`    - SequenceTemplates: ${seqTemplatesCount}`);

        if (seqTemplatesCount > 0) {

          const seqTemplateId = step.relationships.sequenceTemplates.data[0].id;
          const seqTemplate = stepsResponse.data.included?.find(item =>
            item.type === 'sequenceTemplate' && item.id === seqTemplateId
          );

          if (seqTemplate) {
            const templateId = seqTemplate.relationships.template.data.id;
            const template = stepsResponse.data.included?.find(item =>
              item.type === 'template' && item.id === templateId
            );

            if (template) {
              console.log(`    - Template: "${template.attributes.name}" (ID: ${templateId})`);
              console.log(`    - Subject: "${template.attributes.subject}"`);
              console.log(`    - ShareType: ${template.attributes.shareType}`);
              console.log(`    - Archived: ${template.attributes.archived}`);
            }
          }
        }

        console.log(`    - All step attributes:`, Object.keys(step.attributes));
      }

      if (sequencesResponse.data.data.indexOf(sequence) >= 1) break;
    }

    console.log('\nðŸ” Checking for mailings...');
    const mailingsResponse = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    if (mailingsResponse.data.data.length > 0) {
      console.log('Found mailings - checking their relationship to templates...');
      const mailing = mailingsResponse.data.data[0];
      console.log('Mailing attributes:', Object.keys(mailing.attributes));
      console.log('Mailing relationships:', Object.keys(mailing.relationships || {}));
    }

    console.log('\nðŸ” Checking sequenceTemplates directly...');
    const allSeqTemplates = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log(`Found ${allSeqTemplates.data.data.length} sequenceTemplates`);
    if (allSeqTemplates.data.data.length > 0) {
      const seqTemplate = allSeqTemplates.data.data[0];
      console.log('SequenceTemplate attributes:', Object.keys(seqTemplate.attributes || {}));
      console.log('SequenceTemplate relationships:', Object.keys(seqTemplate.relationships || {}));
    }

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

analyzeExistingSequences();

NaN
FILE: callback-server.js
SIZE: 1.98 KB | LINES: 77
MODIFIED: 2025-08-18T10:26:00.186Z
NaN

import express from 'express';
import cors from 'cors';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

app.get('/callback', handleOAuthCallback);
app.get('/auth/callback', handleOAuthCallback);

function handleOAuthCallback(req, res) {
  const { code, state, error } = req.query;

  console.log('OAuth callback received:', { code, state, error });

  if (error) {
    return res.status(400).json({
      error: 'Authorization failed',
      details: error
    });
  }

  if (!code) {
    return res.status(400).json({
      error: 'No authorization code received'
    });
  }

  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Authorization Successful</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        .success { color: #28a745; }
        .code { background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 20px; }
      </style>
    </head>
    <body>
      <h1 class="success">âœ… Authorization Successful!</h1>
      <p>Your authorization code has been received.</p>
      <div class="code">
        <strong>Code:</strong> ${code}<br>
        <strong>State:</strong> ${state || 'N/A'}
      </div>
      <p>You can now close this window.</p>
    </body>
    </html>
  `);
}

app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

app.get('/', (req, res) => {
  res.json({
    message: 'OAuth Callback Server',
    endpoints: {
      callback: '/callback',
      'callback-alt': '/auth/callback',
      health: '/health'
    }
  });
});

app.listen(PORT, () => {
  console.log(`OAuth callback server running on port ${PORT}`);
  console.log(`Callback URL: ${process.env.RAILWAY_PUBLIC_DOMAIN ? 'https:
});

NaN
FILE: claude-tools.json
SIZE: 13.27 KB | LINES: 478
MODIFIED: 2025-08-28T16:29:39.769Z
NaN

[
  {
    "name": "find_sequence",
    "description": "Find existing sequences by name.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "find_sequence",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "create_sequence",
    "description": "Create a new sequence container.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "description": { "type": "string" },
        "tags": { "type": "array", "items": { "type": "string" } },
        "shareType": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "create_sequence",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "get_sequences",
    "description": "List all sequences.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "get_sequences",
        "arguments": {}
      }
    }
  },
  {
    "name": "create_sequence_template",
    "description": "Create email templates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "subject": { "type": "string" },
        "bodyHtml": { "type": "string" },
        "tags": { "type": "array", "items": { "type": "string" } },
        "trackLinks": { "type": "boolean" },
        "trackOpens": { "type": "boolean" }
      },
      "required": ["name", "subject", "bodyHtml"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "create_sequence_template",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "get_sequence_templates",
    "description": "List all templates.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "get_sequence_templates",
        "arguments": {}
      }
    }
  },
  {
    "name": "find_sequence_template",
    "description": "Find template by name.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "find_sequence_template",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "create_sequence_step",
    "description": "Add steps to sequences.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceId": { "type": "string" },
        "stepType": { "type": "string" },
        "order": { "type": "integer" },
        "intervalInDays": { "type": "integer" }
      },
      "required": ["sequenceId", "stepType", "order", "intervalInDays"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "create_sequence_step",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "get_sequence_steps",
    "description": "Get steps for a sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceId": { "type": "string" }
      },
      "required": ["sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "get_sequence_steps",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "link_template_to_step",
    "description": "Connect template to step.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceStepId": { "type": "string" },
        "templateId": { "type": "string" }
      },
      "required": ["sequenceStepId", "templateId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "link_template_to_step",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "create_prospect",
    "description": "Create new prospect.",
    "input_schema": {
      "type": "object",
      "properties": {
        "firstName": { "type": "string" },
        "lastName": { "type": "string" },
        "email": { "type": "string" },
        "company": { "type": "string" },
        "title": { "type": "string" }
      },
      "required": ["firstName", "lastName", "email"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "create_prospect",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "search_prospects",
    "description": "Find existing prospects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "query": { "type": "string" }
      },
      "required": ["query"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "search_prospects",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "add_prospect_to_sequence",
    "description": "Enroll prospect in sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospectId": { "type": "string" },
        "sequenceId": { "type": "string" }
      },
      "required": ["prospectId", "sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "add_prospect_to_sequence",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "bulk_create_prospects",
    "description": "Create multiple prospects at once.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospects": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "firstName": { "type": "string" },
              "lastName": { "type": "string" },
              "email": { "type": "string" },
              "company": { "type": "string" },
              "title": { "type": "string" }
            }
          }
        }
      },
      "required": ["prospects"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "bulk_create_prospects",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "bulk_create_sequences",
    "description": "Create multiple sequences.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "description": { "type": "string" },
              "tags": { "type": "array", "items": { "type": "string" } },
              "shareType": { "type": "string" }
            }
          }
        }
      },
      "required": ["sequences"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "bulk_create_sequences",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "bulk_create_templates",
    "description": "Create multiple templates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "templates": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "subject": { "type": "string" },
              "bodyHtml": { "type": "string" },
              "tags": { "type": "array", "items": { "type": "string" } },
              "trackLinks": { "type": "boolean" },
              "trackOpens": { "type": "boolean" }
            }
          }
        }
      },
      "required": ["templates"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "bulk_create_templates",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "bulk_enroll_prospects",
    "description": "Enroll multiple prospects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospectIds": { "type": "array", "items": { "type": "string" } },
        "sequenceId": { "type": "string" }
      },
      "required": ["prospectIds", "sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "bulk_enroll_prospects",
        "arguments": "{{input}}"
      }
    }
  },
  {
    "name": "get_mailboxes",
    "description": "List available mailboxes.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "get_mailboxes",
        "arguments": {}
      }
    }
  },
  {
    "name": "health_check",
    "description": "Check MCP server status.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "health_check",
        "arguments": {}
      }
    }
  },
  {
    "name": "get_performance_metrics",
    "description": "Get server performance data.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/tools/call",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "get_performance_metrics",
        "arguments": {}
      }
    }
  }
]

NaN
FILE: debug-403-error.js
SIZE: 6.05 KB | LINES: 196
MODIFIED: 2025-08-20T06:55:08.081Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function debug403Error() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('\nðŸ” Testing current permissions...');

    try {
      const templatesTest = await axios.get('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });
      console.log('âœ… Templates read access: OK');
    } catch (err) {
      console.log('âŒ Templates read access:', err.response?.status, err.response?.data?.errors?.[0]?.detail);
    }

    try {
      const seqTemplatesTest = await axios.get('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });
      console.log('âœ… SequenceTemplates read access: OK');
    } catch (err) {
      console.log('âŒ SequenceTemplates read access:', err.response?.status, err.response?.data?.errors?.[0]?.detail);
    }

    console.log('\nðŸ“ Testing template creation...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Debug Template ' + Date.now(),
          subject: 'Debug subject {{prospect.firstName}}',
          bodyHtml: '<p>Debug content for {{prospect.firstName}}</p>',
          trackLinks: true,
          trackOpens: true
        }
      }
    };

    let templateId;
    try {
      const templateResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });
      templateId = templateResponse.data.data.id;
      console.log('âœ… Template created:', templateId);
    } catch (err) {
      console.log('âŒ Template creation failed:', err.response?.status, err.response?.data?.errors?.[0]?.detail);
      return;
    }

    console.log('\nðŸ“‹ Creating sequence and step...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Debug Sequence ' + Date.now(),
          description: 'Debug sequence for 403 error',
          shareType: 'private'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const stepId = stepResponse.data.data.id;
    console.log('âœ… Step created:', stepId);

    console.log('\nðŸ”— Testing template linking...');
    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    try {
      const linkResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });
      console.log('âœ… Template linked successfully!');
      console.log('ðŸŽ‰ All operations completed successfully!');
    } catch (err) {
      console.log('âŒ Template linking failed:');
      console.log('Status:', err.response?.status);
      console.log('Error:', err.response?.data);

      if (err.response?.status === 403) {
        console.log('\nðŸ”’ 403 FORBIDDEN - This indicates:');
        console.log('1. Missing OAuth scope (likely sequenceTemplates.write)');
        console.log('2. Insufficient permissions in Outreach');
        console.log('3. Account-level restrictions');
      }
    }

  } catch (error) {
    console.error('âŒ Unexpected error:', error.response?.data || error.message);
  }
}

debug403Error();

NaN
FILE: debug-template-visibility.js
SIZE: 6.99 KB | LINES: 216
MODIFIED: 2025-08-21T07:36:31.303Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function debugTemplateVisibility() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ“ Creating template...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Debug Template ' + Date.now(),
          subject: 'Test Subject {{prospect.firstName}}',
          bodyHtml: '<p>Test email body for {{prospect.firstName}}</p>',
          trackLinks: true,
          trackOpens: true
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const templateId = templateResponse.data.data.id;
    console.log('âœ… Template created:', templateId);
    console.log('Template details:', {
      name: templateResponse.data.data.attributes.name,
      subject: templateResponse.data.data.attributes.subject
    });

    console.log('\nðŸ“‹ Creating sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Debug Sequence ' + Date.now(),
          description: 'Testing template visibility',
          shareType: 'private'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    console.log('\nðŸ“§ Creating sequence step...');
    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const stepId = stepResponse.data.data.id;
    console.log('âœ… Step created:', stepId);

    console.log('\nðŸ”— Linking template to step...');
    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    const linkResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… SequenceTemplate created:', linkResponse.data.data.id);

    console.log('\nðŸ” Verifying template is linked to step...');
    const verifyStepResponse = await axios.get(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('Step relationships:', JSON.stringify(verifyStepResponse.data.data.relationships, null, 2));

    console.log('\nðŸ“‹ Getting sequenceTemplates for this step...');
    const seqTemplatesResponse = await axios.get(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('SequenceTemplates found:', seqTemplatesResponse.data.data.length);
    if (seqTemplatesResponse.data.data.length > 0) {
      console.log('SequenceTemplate details:', {
        id: seqTemplatesResponse.data.data[0].id,
        relationships: seqTemplatesResponse.data.data[0].relationships
      });
    }

    console.log('\nðŸ“ Summary:');
    console.log(`- Template ID: ${templateId}`);
    console.log(`- Sequence ID: ${sequenceId}`);
    console.log(`- Step ID: ${stepId}`);
    console.log(`- SequenceTemplate ID: ${linkResponse.data.data.id}`);
    console.log('\nâš ï¸  If template is not showing in Outreach UI:');
    console.log('1. The template might need to be activated/enabled');
    console.log('2. There might be a different relationship structure needed');
    console.log('3. The UI might require additional fields or configuration');
    console.log('4. Check if you need to set a default template for the step');

    console.log('\nðŸ” Checking step details with template included...');
    const stepWithTemplateResponse = await axios.get(
      `https:
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      }
    );

    if (stepWithTemplateResponse.data.included) {
      console.log('Included resources:', stepWithTemplateResponse.data.included.map(r => ({
        type: r.type,
        id: r.id,
        name: r.attributes?.name
      })));
    }

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

debugTemplateVisibility();

NaN
FILE: docker-compose.yml
SIZE: 1017 B | LINES: 31
MODIFIED: 2025-08-19T12:08:12.346Z
NaN

version: '3.8'

services:
  mcp-outreach:
    build: .
    container_name: mcp-outreach-server
    environment:
      - OUTREACH_CLIENT_ID=${OUTREACH_CLIENT_ID}
      - OUTREACH_CLIENT_SECRET=${OUTREACH_CLIENT_SECRET}
      - OUTREACH_REDIRECT_URI=${OUTREACH_REDIRECT_URI:-http://localhost:3000/callback}
      - OUTREACH_REFRESH_TOKEN=${OUTREACH_REFRESH_TOKEN}
      - OUTREACH_API_BASE_URL=${OUTREACH_API_BASE_URL:-https://api.outreach.io/api/v2}
      - MCP_SERVER_NAME=${MCP_SERVER_NAME:-outreach-mcp}
      - MCP_SERVER_PORT=${MCP_SERVER_PORT:-3000}
      - DEBUG=${DEBUG:-false}
    ports:
      - "${MCP_SERVER_PORT:-3000}:3000"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "import('./src/index.js').then(() => process.exit(0)).catch(() => process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    volumes:
      - ./logs:/app/logs
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

NaN
FILE: exchange-code.js
SIZE: 2.01 KB | LINES: 62
MODIFIED: 2025-08-19T13:27:44.290Z
NaN

import axios from 'axios';
import fs from 'fs';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

dotenv.config();

const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';
const REDIRECT_URI = process.env.OUTREACH_REDIRECT_URI;
const AUTH_CODE = 'fbvNUGaMgdz8keFVcW8VypRldtCFF9hR1ynETpJBeE8';

async function exchangeCode() {
  try {
    const params = new URLSearchParams({
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URI,
      grant_type: 'authorization_code',
      code: AUTH_CODE
    });

    console.log('Exchanging code for tokens...');
    const response = await axios.post('https:
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    const { access_token, refresh_token, expires_in } = response.data;

    const __dirname = dirname(fileURLToPath(import.meta.url));
    const envPath = join(__dirname, '.env');
    let envContent = fs.readFileSync(envPath, 'utf8');

    if (envContent.includes('OUTREACH_REFRESH_TOKEN=')) {
      envContent = envContent.replace(
        /OUTREACH_REFRESH_TOKEN=.*/,
        `OUTREACH_REFRESH_TOKEN=${refresh_token}`
      );
    } else {
      envContent += `\nOUTREACH_REFRESH_TOKEN=${refresh_token}\n`;
    }

    fs.writeFileSync(envPath, envContent);

    console.log('\nâœ… OAuth setup complete!');
    console.log('ðŸ“ Refresh token saved to .env file');
    console.log(`ðŸ”‘ Access Token: ${access_token.substring(0, 20)}...`);
    console.log(`ðŸ”„ Refresh Token: ${refresh_token.substring(0, 20)}...`);
    console.log(`â° Expires In: ${expires_in} seconds`);
    console.log('\nYou can now run: npm start\n');

  } catch (error) {
    console.error('Error exchanging code:', error.response?.data || error.message);
  }
}

exchangeCode();

NaN
FILE: exchange-new-code.js
SIZE: 1.75 KB | LINES: 55
MODIFIED: 2025-08-19T13:45:18.130Z
NaN

import axios from 'axios';
import fs from 'fs';

const CLIENT_ID = 'huKx35FSVCR1RXClVCLsorRq.Ljk9ZyPyfo2qqW~xeug';
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';
const REDIRECT_URI = 'https:

const AUTH_CODE = process.argv[2];

if (!AUTH_CODE) {
  console.log('Usage: node exchange-new-code.js YOUR_AUTHORIZATION_CODE');
  process.exit(1);
}

async function exchangeCode() {
  try {
    const params = new URLSearchParams({
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URI,
      grant_type: 'authorization_code',
      code: AUTH_CODE
    });

    console.log('ðŸ“ Exchanging code for tokens...');
    const response = await axios.post('https:
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    const { access_token, refresh_token, expires_in } = response.data;

    let envContent = fs.readFileSync('.env', 'utf8');
    envContent = envContent.replace(
      /OUTREACH_REFRESH_TOKEN=.*/,
      `OUTREACH_REFRESH_TOKEN=${refresh_token}`
    );
    fs.writeFileSync('.env', envContent);

    console.log('\nâœ… OAuth setup complete!');
    console.log('ðŸ“ Refresh token saved to .env file');
    console.log(`ðŸ”‘ Access Token: ${access_token.substring(0, 20)}...`);
    console.log(`ðŸ”„ Refresh Token: ${refresh_token.substring(0, 20)}...`);
    console.log(`â° Expires In: ${expires_in} seconds`);
    console.log('\nYou can now use the MCP server!\n');

  } catch (error) {
    console.error('Error exchanging code:', error.response?.data || error.message);
  }
}

exchangeCode();

NaN
FILE: get-auth-url.js
SIZE: 936 B | LINES: 18
MODIFIED: 2025-08-21T07:55:08.241Z
NaN

const CLIENT_ID = 'huKx35FSVCR1RXClVCLsorRq.Ljk9ZyPyfo2qqW~xeug';
const REDIRECT_URI = 'https:

const SCOPES = 'mailboxes.all prospects.all sequences.all sequenceSteps.all sequenceStates.all templates.all sequenceTemplates.all mailings.all users.all';

const authUrl = `https:
  `client_id=${CLIENT_ID}&` +
  `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
  `response_type=code&` +
  `scope=${encodeURIComponent(SCOPES)}`;

console.log('\nðŸ”— Visit this URL to authorize the app:\n');
console.log(authUrl);
console.log('\nðŸ“ After authorizing, you\'ll be redirected to the Railway app.');
console.log('Copy the authorization code from the URL and run: node exchange-new-code.js YOUR_CODE\n');

NaN
FILE: get-sequence-url.js
SIZE: 4.87 KB | LINES: 131
MODIFIED: 2025-08-21T07:58:44.219Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function getSequenceInfo() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    const sequenceId = 1204;
    console.log(`ðŸ” Getting sequence ${sequenceId} details...`);

    const sequenceResponse = await axios.get(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('Sequence details:');
    console.log('- Name:', sequenceResponse.data.data.attributes.name);
    console.log('- ID:', sequenceResponse.data.data.id);
    console.log('- Enabled:', sequenceResponse.data.data.attributes.enabled);
    console.log('- Step Count:', sequenceResponse.data.data.attributes.sequenceStepCount);

    if (sequenceResponse.data.data.links) {
      console.log('- Links:', sequenceResponse.data.data.links);
    }

    console.log('\nðŸ“§ Getting sequence steps...');
    const stepsResponse = await axios.get(
      `https:
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      }
    );

    console.log(`Found ${stepsResponse.data.data.length} steps:`);

    stepsResponse.data.data.forEach((step, index) => {
      console.log(`\n  Step ${step.attributes.order}:`);
      console.log(`  - ID: ${step.id}`);
      console.log(`  - Type: ${step.attributes.stepType}`);
      console.log(`  - Interval: ${step.attributes.interval} minutes`);

      const seqTemplatesCount = step.relationships.sequenceTemplates?.data?.length || 0;
      console.log(`  - Has sequenceTemplates: ${seqTemplatesCount > 0} (${seqTemplatesCount})`);

      if (seqTemplatesCount > 0 && stepsResponse.data.included) {
        const seqTemplateId = step.relationships.sequenceTemplates.data[0].id;
        const seqTemplate = stepsResponse.data.included.find(item =>
          item.type === 'sequenceTemplate' && item.id === seqTemplateId
        );

        if (seqTemplate) {
          const templateId = seqTemplate.relationships.template.data.id;
          const template = stepsResponse.data.included.find(item =>
            item.type === 'template' && item.id === templateId
          );

          if (template) {
            console.log(`  - Template: "${template.attributes.name}"`);
            console.log(`  - Subject: "${template.attributes.subject}"`);
          }
        }
      }
    });

    console.log('\nðŸŒ Possible Outreach URLs to try:');
    console.log(`1. https:
    console.log(`2. https:
    console.log(`3. https:
    console.log(`4. https:
    console.log(`5. https:

    try {
      const userResponse = await axios.get('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      if (userResponse.data.data.length > 0) {
        const user = userResponse.data.data[0];
        console.log('\nðŸ‘¤ User info:');
        console.log('- Email:', user.attributes.email);
        console.log('- First Name:', user.attributes.firstName);
        console.log('- Last Name:', user.attributes.lastName);
      }
    } catch (error) {
      console.log('Could not get user info');
    }

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

getSequenceInfo();

NaN
FILE: index.js
SIZE: 6.85 KB | LINES: 259
MODIFIED: 2025-08-19T11:14:26.817Z
NaN

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import OutreachClient from './outreach-client.js';
import dotenv from 'dotenv';

dotenv.config();

const outreachClient = new OutreachClient();

const TOOLS = [
  {
    name: 'create_prospect',
    description: 'Create a new prospect in Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        firstName: { type: 'string', description: 'First name of the prospect' },
        lastName: { type: 'string', description: 'Last name of the prospect' },
        email: { type: 'string', description: 'Email address of the prospect' },
        company: { type: 'string', description: 'Company name' },
        title: { type: 'string', description: 'Job title' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags to assign' },
        customFields: { type: 'object', description: 'Custom field values' }
      },
      required: ['firstName', 'lastName', 'email']
    }
  },
  {
    name: 'search_prospects',
    description: 'Search for prospects based on criteria',
    inputSchema: {
      type: 'object',
      properties: {
        email: { type: 'string', description: 'Email to search for' },
        company: { type: 'string', description: 'Company name to search for' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags to filter by' },
        limit: { type: 'number', description: 'Maximum number of results', default: 25 }
      }
    }
  },
  {
    name: 'tag_prospect',
    description: 'Add tags to an existing prospect',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: { type: 'string', description: 'ID of the prospect' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags to add' }
      },
      required: ['prospectId', 'tags']
    }
  },
  {
    name: 'update_prospect',
    description: 'Update prospect information',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: { type: 'string', description: 'ID of the prospect' },
        updates: {
          type: 'object',
          properties: {
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            email: { type: 'string' },
            company: { type: 'string' },
            title: { type: 'string' },
            tags: { type: 'array', items: { type: 'string' } }
          }
        }
      },
      required: ['prospectId', 'updates']
    }
  },
  {
    name: 'find_sequence',
    description: 'Find a sequence by name',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the sequence' }
      },
      required: ['name']
    }
  },
  {
    name: 'get_sequences',
    description: 'Get list of available sequences',
    inputSchema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Maximum number of sequences to return', default: 25 }
      }
    }
  },
  {
    name: 'add_prospect_to_sequence',
    description: 'Add a prospect to a sequence',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: { type: 'string', description: 'ID of the prospect' },
        sequenceId: { type: 'string', description: 'ID of the sequence' },
        mailboxId: { type: 'string', description: 'ID of the mailbox to use (optional)' }
      },
      required: ['prospectId', 'sequenceId']
    }
  },
  {
    name: 'create_account',
    description: 'Create a new account in Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Account name' },
        domain: { type: 'string', description: 'Company domain' },
        industry: { type: 'string', description: 'Industry' },
        size: { type: 'string', description: 'Company size' }
      },
      required: ['name']
    }
  },
  {
    name: 'search_accounts',
    description: 'Search for accounts',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Account name to search for' },
        domain: { type: 'string', description: 'Domain to search for' }
      }
    }
  },
  {
    name: 'get_mailboxes',
    description: 'Get available mailboxes for sending emails',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  }
];

const server = new Server(
  {
    name: 'mcp-outreach-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: TOOLS,
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    let result;

    switch (name) {
      case 'create_prospect':
        result = await outreachClient.createProspect(args);
        break;

      case 'search_prospects':
        result = await outreachClient.searchProspects(args);
        break;

      case 'tag_prospect':
        result = await outreachClient.tagProspect(args.prospectId, args.tags);
        break;

      case 'update_prospect':
        result = await outreachClient.updateProspect(args.prospectId, args.updates);
        break;

      case 'find_sequence':
        result = await outreachClient.findSequence(args.name);
        break;

      case 'get_sequences':
        result = await outreachClient.getSequences(args.limit || 25);
        break;

      case 'add_prospect_to_sequence':
        result = await outreachClient.addProspectToSequence(
          args.prospectId,
          args.sequenceId,
          { mailboxId: args.mailboxId }
        );
        break;

      case 'create_account':
        result = await outreachClient.createAccount(args);
        break;

      case 'search_accounts':
        result = await outreachClient.searchAccounts(args);
        break;

      case 'get_mailboxes':
        result = await outreachClient.getMailboxes();
        break;

      default:
        throw new Error(`Unknown tool: ${name}`);
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(result, null, 2),
        },
      ],
    };
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error.message}`,
        },
      ],
      isError: true,
    };
  }
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('MCP Outreach Server running on stdio');
}

main().catch((error) => {
  console.error('Server error:', error);
  process.exit(1);
});


NaN
FILE: mcp-outreach-server/.claude/settings.local.json
SIZE: 2.52 KB | LINES: 64
MODIFIED: 2025-08-28T20:31:38.015Z
NaN

{
  "permissions": {
    "allow": [
      "Bash(npm install:*)",
      "Bash(cp:*)",
      "Bash(node:*)",
      "Bash(grep:*)",
      "Bash(railway status:*)",
      "Bash(npm run setup:*)",
      "Bash(npm start)",
      "Bash(cat:*)",
      "WebSearch",
      "Bash(git add:*)",
      "Bash(git push:*)",
      "Bash(git commit:*)",
      "WebFetch(domain:support.outreach.io)",
      "WebFetch(domain:developers.outreach.io)",
      "WebFetch(domain:medium.com)",
      "WebFetch(domain:www.marktechpost.com)",
      "Bash(chmod:*)",
      "Bash(./setup-n8n.sh:*)",
      "Bash(mkdir:*)",
      "Bash(rm:*)",
      "Bash(npm run lint)",
      "Bash(find:*)",
      "Bash(sed:*)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/src/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/**)",
      "WebFetch(domain:developer.lemlist.com)",
      "WebFetch(domain:rollout.com)",
      "Read(/Users/raphaelberrebi/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/sub-agents/context/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/sub-agents/context/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/sub-agents/context/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/sub-agents/context/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/sub-agents/context/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-outreach-server/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Read(/Users/raphaelberrebi/mcp-lemlist-server/**)",
      "Bash(git init:*)",
      "Bash(git rm:*)",
      "Bash(npx @railway/cli@latest:*)",
      "Bash(git remote set-url:*)",
      "Bash(git remote add:*)",
      "Read(/Users/raphaelberrebi/Library/Application Support/**)",
      "Read(/Users/raphaelberrebi/Library/Application Support/Claude/**)",
      "Bash(curl:*)",
      "WebFetch(domain:www.lemlist.com)"
    ],
    "deny": [],
    "ask": [],
    "additionalDirectories": [
      "/Users/raphaelberrebi/n8n-automation"
    ]
  }
}

NaN
FILE: mcp-outreach-server/CLAUDE.md
SIZE: 2.26 KB | LINES: 71
MODIFIED: 2025-08-19T13:18:24.769Z
NaN

- Remember these steps that you give me which might be wrong... ðŸš€ MCP Outreach Server Deployment Steps

  1. Set up Outreach OAuth Application

  - Log into Outreach as admin
  - Navigate to Settings â†’ Integrations â†’ API Access
  - Click "Create New App"
  - Set Application Name: "MCP Integration"
  - Set Redirect URI: http://localhost:3000/callback
  - Select Application Type: "Private" or "Internal"
  - Add required scopes:
    - accounts.all
    - prospects.all
    - sequences.all
    - sequenceStates.all
    - mailboxes.all
    - tags.all
    - users.all
  - Save and copy Client ID and Client Secret

  2. Configure Environment Variables

  - Run: cp .env.example .env
  - Edit .env file with your OAuth credentials:
    - Replace OUTREACH_CLIENT_ID=your_client_id_here
    - Replace OUTREACH_CLIENT_SECRET=your_client_secret_here
    - Keep other settings as default

  3. Get OAuth Refresh Token

  - Run: npm run setup
  - Browser will open automatically
  - Log into Outreach and authorize the app
  - Confirm refresh token is saved to .env

  4. Test Server Locally

  - Run: npm start
  - Verify no errors in console
  - Test with debug mode: DEBUG=true npm start
  - Run syntax check: node --check src/index.js

  5. Configure Claude Desktop

  - Get refresh token from .env file
  - Edit Claude config file:
    - macOS: ~/Library/Application Support/Claude/claude_desktop_config.json
    - Windows: %APPDATA%\Claude\claude_desktop_config.json
  - Add MCP server configuration with your actual credentials
  - Use full absolute path to src/index.js

  6. Test in Claude Desktop

  - Quit Claude Desktop completely
  - Restart Claude Desktop
  - Test health check: "Check the health of the Outreach server"
  - Test basic commands:
    - "Get a list of available sequences"
    - "Search for accounts containing 'test'"
    - "Get all available mailboxes"

  7. Troubleshooting (if needed)

  - Check server logs with DEBUG=true npm start
  - Re-run OAuth setup if authentication fails
  - Verify Claude Desktop config file syntax
  - Confirm all file paths are absolute
  - Test individual file syntax

  âœ… Success criteria: All test commands work in Claude without errors and return Outreach data.
- Outreach requires the URL has to include https protocol. For example: https://your.url

NaN
FILE: mcp-outreach-server/claude:tools.json
SIZE: 11.68 KB | LINES: 402
MODIFIED: 2025-08-28T13:58:26.716Z
NaN

[
  {
    "name": "find_sequence",
    "description": "Find existing sequences by name.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/find_sequence",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "create_sequence",
    "description": "Create a new sequence container.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "description": { "type": "string" },
        "tags": { "type": "array", "items": { "type": "string" } },
        "shareType": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/create_sequence",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "get_sequences",
    "description": "List all sequences.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/get_sequences",
      "method": "GET",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "create_sequence_template",
    "description": "Create email templates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "subject": { "type": "string" },
        "bodyHtml": { "type": "string" },
        "tags": { "type": "array", "items": { "type": "string" } },
        "trackLinks": { "type": "boolean" },
        "trackOpens": { "type": "boolean" }
      },
      "required": ["name", "subject", "bodyHtml"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/create_sequence_template",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "get_sequence_templates",
    "description": "List all templates.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/get_sequence_templates",
      "method": "GET",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "find_sequence_template",
    "description": "Find template by name.",
    "input_schema": {
      "type": "object",
      "properties": {
        "name": { "type": "string" }
      },
      "required": ["name"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/find_sequence_template",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "create_sequence_step",
    "description": "Add steps to sequences.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceId": { "type": "string" },
        "stepType": { "type": "string" },
        "order": { "type": "integer" },
        "intervalInDays": { "type": "integer" }
      },
      "required": ["sequenceId", "stepType", "order", "intervalInDays"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/create_sequence_step",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "get_sequence_steps",
    "description": "Get steps for a sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceId": { "type": "string" }
      },
      "required": ["sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/get_sequence_steps",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "link_template_to_step",
    "description": "Connect template to step.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequenceStepId": { "type": "string" },
        "templateId": { "type": "string" }
      },
      "required": ["sequenceStepId", "templateId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/link_template_to_step",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "create_prospect",
    "description": "Create new prospect.",
    "input_schema": {
      "type": "object",
      "properties": {
        "firstName": { "type": "string" },
        "lastName": { "type": "string" },
        "email": { "type": "string" },
        "company": { "type": "string" },
        "title": { "type": "string" }
      },
      "required": ["firstName", "lastName", "email"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/create_prospect",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "search_prospects",
    "description": "Find existing prospects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "query": { "type": "string" }
      },
      "required": ["query"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/search_prospects",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "add_prospect_to_sequence",
    "description": "Enroll prospect in sequence.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospectId": { "type": "string" },
        "sequenceId": { "type": "string" }
      },
      "required": ["prospectId", "sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/add_prospect_to_sequence",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "bulk_create_prospects",
    "description": "Create multiple prospects at once.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospects": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "firstName": { "type": "string" },
              "lastName": { "type": "string" },
              "email": { "type": "string" },
              "company": { "type": "string" },
              "title": { "type": "string" }
            }
          }
        }
      },
      "required": ["prospects"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/bulk_create_prospects",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "bulk_create_sequences",
    "description": "Create multiple sequences.",
    "input_schema": {
      "type": "object",
      "properties": {
        "sequences": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "description": { "type": "string" },
              "tags": { "type": "array", "items": { "type": "string" } },
              "shareType": { "type": "string" }
            }
          }
        }
      },
      "required": ["sequences"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/bulk_create_sequences",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "bulk_create_templates",
    "description": "Create multiple templates.",
    "input_schema": {
      "type": "object",
      "properties": {
        "templates": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "subject": { "type": "string" },
              "bodyHtml": { "type": "string" },
              "tags": { "type": "array", "items": { "type": "string" } },
              "trackLinks": { "type": "boolean" },
              "trackOpens": { "type": "boolean" }
            }
          }
        }
      },
      "required": ["templates"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/bulk_create_templates",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "bulk_enroll_prospects",
    "description": "Enroll multiple prospects.",
    "input_schema": {
      "type": "object",
      "properties": {
        "prospectIds": { "type": "array", "items": { "type": "string" } },
        "sequenceId": { "type": "string" }
      },
      "required": ["prospectIds", "sequenceId"]
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/bulk_enroll_prospects",
      "method": "POST",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "get_mailboxes",
    "description": "List available mailboxes.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/get_mailboxes",
      "method": "GET",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "health_check",
    "description": "Check MCP server status.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/health_check",
      "method": "GET",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  },
  {
    "name": "get_performance_metrics",
    "description": "Get server performance data.",
    "input_schema": {
      "type": "object",
      "properties": {}
    },
    "api": {
      "url": "https://mcp-outreach-server-production.up.railway.app/get_performance_metrics",
      "method": "GET",
      "headers": {
        "x-api-key": "55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8",
        "Content-Type": "application/json"
      }
    }
  }
]

NaN
FILE: mcp-outreach-server/package.json
SIZE: 459 B | LINES: 20
MODIFIED: 2025-08-19T11:21:23.611Z
NaN

{
  "name": "mcp-outreach-server",
  "version": "1.0.0",
  "description": "MCP server for Outreach.io integration",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "start": "node src/index.js",
    "dev": "node --watch src/index.js",
    "setup": "node src/setup-oauth.js"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.5.0",
    "axios": "^1.6.0",
    "dotenv": "^16.3.1",
    "express": "^4.18.0",
    "open": "^9.1.0"
  }
}


NaN
FILE: mcp-workflow-integration.js
SIZE: 6.69 KB | LINES: 241
MODIFIED: 2025-08-22T13:06:47.159Z
NaN

import axios from 'axios';

export class MCPWorkflowIntegration {
  constructor(mcpServerUrl, config = {}) {
    this.baseUrl = mcpServerUrl;
    this.timeout = config.timeout || 30000;
    this.retries = config.retries || 3;
  }

  async executeFullWorkflow(aiGeneratedData, options = {}) {
    try {
      console.log('ðŸš€ Starting full prospect-to-sequence workflow...');

      const prospects = await this.createProspects(aiGeneratedData.prospects);
      console.log(`âœ… Created ${prospects.length} prospects`);

      const sequence = await this.createSequence(aiGeneratedData.sequence);
      console.log(`âœ… Created sequence: ${sequence.name}`);

      const templates = await this.createAndLinkTemplates(
        aiGeneratedData.templates,
        sequence.id
      );
      console.log(`âœ… Created and linked ${templates.length} templates`);

      const enrollments = await this.enrollProspects(
        prospects.map(p => p.id),
        sequence.id,
        options.mailboxId
      );
      console.log(`âœ… Enrolled ${enrollments.length} prospects in sequence`);

      return {
        success: true,
        summary: {
          prospects: prospects.length,
          sequence: sequence.name,
          templates: templates.length,
          enrollments: enrollments.length
        },
        details: {
          prospects,
          sequence,
          templates,
          enrollments
        }
      };

    } catch (error) {
      console.error('âŒ Workflow execution failed:', error);
      throw new Error(`MCP Workflow failed: ${error.message}`);
    }
  }

  async createProspects(prospectData) {
    const results = [];

    for (const prospect of prospectData) {
      try {
        const result = await this.callMCPTool('create_prospect', prospect);
        results.push(result.data);
      } catch (error) {
        console.error(`Failed to create prospect ${prospect.email}:`, error.message);

      }
    }

    return results;
  }

  async createSequence(sequenceData) {
    try {
      const result = await this.callMCPTool('create_sequence', {
        name: sequenceData.name,
        description: sequenceData.description || 'AI-generated sequence',
        shareType: 'shared',
        tags: ['ai-generated', 'automated']
      });

      return result.data;
    } catch (error) {
      throw new Error(`Failed to create sequence: ${error.message}`);
    }
  }

  async createAndLinkTemplates(templatesData, sequenceId) {
    const results = [];
    let stepOrder = 1;

    for (const template of templatesData) {
      try {

        const createdTemplate = await this.callMCPTool('create_sequence_template', {
          name: template.name,
          subject: template.subject,
          bodyHtml: template.bodyHtml,
          bodyText: template.bodyText,
          shareType: 'shared',
          tags: ['ai-generated']
        });

        const step = await this.callMCPTool('create_sequence_step', {
          sequenceId: sequenceId,
          stepType: 'auto_email',
          intervalInDays: template.intervalInDays || 0,
          order: stepOrder++
        });

        await this.callMCPTool('link_template_to_step', {
          sequenceStepId: step.data.id,
          templateId: createdTemplate.data.id
        });

        results.push({
          template: createdTemplate.data,
          step: step.data,
          linked: true
        });

      } catch (error) {
        console.error(`Failed to create/link template ${template.name}:`, error.message);

      }
    }

    return results;
  }

  async enrollProspects(prospectIds, sequenceId, mailboxId) {
    const results = [];

    for (const prospectId of prospectIds) {
      try {
        const enrollment = await this.callMCPTool('add_prospect_to_sequence', {
          prospectId,
          sequenceId,
          options: mailboxId ? { mailboxId } : {}
        });

        results.push(enrollment.data);
      } catch (error) {
        console.error(`Failed to enroll prospect ${prospectId}:`, error.message);

      }
    }

    return results;
  }

  async callMCPTool(toolName, args, attempt = 1) {
    try {
      const response = await axios.post(`${this.baseUrl}/call-tool`, {
        name: toolName,
        arguments: args
      }, {
        timeout: this.timeout,
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.data && response.data.content && response.data.content[0]) {
        return JSON.parse(response.data.content[0].text);
      }

      throw new Error('Invalid MCP response format');

    } catch (error) {
      if (attempt < this.retries && this.shouldRetry(error)) {
        console.log(`Retrying ${toolName} (attempt ${attempt + 1})...`);
        await this.delay(1000 * attempt);
        return this.callMCPTool(toolName, args, attempt + 1);
      }

      throw error;
    }
  }

  shouldRetry(error) {
    return error.response?.status >= 500 ||
           error.code === 'ECONNRESET' ||
           error.code === 'ETIMEDOUT';
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async getWorkflowStatus(workflowId) {

    return {
      id: workflowId,
      status: 'completed',
      progress: 100,
      results: {}
    };
  }

  async createProspectsBatch(prospectData, batchSize = 10) {
    const results = [];

    for (let i = 0; i < prospectData.length; i += batchSize) {
      const batch = prospectData.slice(i, i + batchSize);
      const batchPromises = batch.map(prospect =>
        this.callMCPTool('create_prospect', prospect).catch(error => ({ error: error.message }))
      );

      const batchResults = await Promise.allSettled(batchPromises);
      results.push(...batchResults.map(result => result.value));

      if (i + batchSize < prospectData.length) {
        await this.delay(500);
      }
    }

    return results.filter(result => !result.error);
  }

  async getWorkflowAnalytics(timeRange = '7d') {
    return {
      totalWorkflows: 25,
      successRate: 92,
      avgProspectsPerWorkflow: 15,
      avgSequenceLength: 5,
      avgEnrollmentRate: 88,
      topPerformingSequences: [],
      errorPatterns: []
    };
  }
}

NaN
FILE: n8n-research-node.js
SIZE: 3.9 KB | LINES: 148
MODIFIED: 2025-08-22T13:05:40.940Z
NaN

export const aiProspectResearch = {
  displayName: 'AI Prospect Research',
  name: 'aiProspectResearch',
  group: ['input'],
  version: 1,
  description: 'AI-powered prospect research and analysis',

  defaults: {
    name: 'AI Prospect Research',
    color: '#ff6d5a',
  },

  inputs: ['main'],
  outputs: ['main'],

  properties: [
    {
      displayName: 'Target Criteria',
      name: 'targetCriteria',
      type: 'fixedCollection',
      default: {},
      options: [
        {
          name: 'criteria',
          displayName: 'Search Criteria',
          values: [
            {
              displayName: 'Industry',
              name: 'industry',
              type: 'string',
              default: 'healthcare',
            },
            {
              displayName: 'Company Size',
              name: 'companySize',
              type: 'options',
              options: [
                { name: '1-10', value: '1-10' },
                { name: '11-50', value: '11-50' },
                { name: '51-200', value: '51-200' },
                { name: '201-1000', value: '201-1000' },
                { name: '1000+', value: '1000+' },
              ],
              default: '51-200',
            },
            {
              displayName: 'Job Titles',
              name: 'jobTitles',
              type: 'string',
              default: 'CEO, CTO, VP Engineering',
            }
          ]
        }
      ]
    },
    {
      displayName: 'AI Model',
      name: 'aiModel',
      type: 'options',
      options: [
        { name: 'Claude 3.5 Sonnet', value: 'claude-3-5-sonnet' },
        { name: 'GPT-4', value: 'gpt-4' },
      ],
      default: 'claude-3-5-sonnet',
    }
  ],

  async execute() {
    const items = this.getInputData();
    const criteria = this.getNodeParameter('targetCriteria', 0);
    const aiModel = this.getNodeParameter('aiModel', 0);

    const results = [];

    for (let i = 0; i < items.length; i++) {

      const prospectData = await this.collectProspectData(criteria);

      const aiAnalysis = await this.analyzeWithAI(prospectData, aiModel);

      const mcpReadyData = await this.formatForMCP(aiAnalysis);

      results.push({
        json: {
          prospects: mcpReadyData.prospects,
          sequences: mcpReadyData.sequences,
          templates: mcpReadyData.templates,
          research_insights: aiAnalysis.insights,
          personalization_data: aiAnalysis.personalization
        }
      });
    }

    return [results];
  },

  async collectProspectData(criteria) {

    const sources = {
      apollo: await this.searchApollo(criteria),
      linkedin: await this.searchLinkedIn(criteria),
      company_data: await this.enrichCompanyData(criteria),
      news_data: await this.getRecentNews(criteria)
    };

    return sources;
  },

  async analyzeWithAI(data, model) {
    const prompt = `
    Analyze this prospect data and provide:
    1. Key pain points for each company
    2. Personalization angles
    3. Best outreach timing
    4. Value propositions that would resonate
    5. Email sequence strategy

    Data: ${JSON.stringify(data)}
    `;

    const analysis = await this.callAI(prompt, model);
    return analysis;
  },

  async formatForMCP(analysis) {

    return {
      prospects: analysis.prospects.map(p => ({
        firstName: p.firstName,
        lastName: p.lastName,
        email: p.email,
        company: p.company,
        title: p.title,
        customFields: {
          pain_points: p.painPoints,
          personalization: p.personalization,
          best_contact_time: p.contactTiming
        }
      })),
      sequences: analysis.sequences,
      templates: analysis.templates
    };
  }
};

NaN
FILE: oauth-setup.js
SIZE: 1.07 KB | LINES: 34
MODIFIED: 2025-08-18T12:07:36.790Z
NaN

#!/usr/bin/env node

import { OutreachOAuth } from './dist/oauth.js';
import { config } from 'dotenv';

config();

async function setupOAuth() {
  if (!process.env.OUTREACH_CLIENT_ID || !process.env.OUTREACH_CLIENT_SECRET) {
    console.error('Missing OUTREACH_CLIENT_ID or OUTREACH_CLIENT_SECRET environment variables');
    process.exit(1);
  }

  const oauth = new OutreachOAuth({
    clientId: process.env.OUTREACH_CLIENT_ID,
    clientSecret: process.env.OUTREACH_CLIENT_SECRET,
    redirectUri: process.env.OUTREACH_REDIRECT_URI || 'http:
    scope: 'sequences.all prospects.all accounts.read sequenceStates.all sequenceSteps.all mailboxes.read'
  });

  try {
    console.log('Starting OAuth flow...');
    const token = await oauth.initialize();
    console.log('âœ… OAuth setup complete! Token saved.');
    console.log('You can now use the MCP server with Claude.');
    process.exit(0);
  } catch (error) {
    console.error('âŒ OAuth setup failed:', error.message);
    process.exit(1);
  }
}

setupOAuth();

NaN
FILE: oauth-test.js
SIZE: 1.26 KB | LINES: 47
MODIFIED: 2025-08-18T10:26:56.302Z
NaN

#!/usr/bin/env node

import { spawn } from 'child_process';
import { config } from 'dotenv';

config();

console.log('ðŸ” Testing OAuth Flow with Railway...\n');
console.log('Configuration:');
console.log('- Client ID:', process.env.OUTREACH_CLIENT_ID?.slice(0, 10) + '...');
console.log('- Redirect URI:', process.env.OUTREACH_REDIRECT_URI);
console.log('');

const server = spawn('node', ['dist/index.js'], {
  stdio: ['pipe', 'pipe', 'pipe']
});

server.stderr.on('data', (data) => {
  const output = data.toString();
  console.log(output);

  if (output.includes('https:
    console.log('âœ… OAuth URL generated successfully!');
    console.log('ðŸ“ The URL should redirect to Railway after authorization');
    console.log('ðŸŒ Railway callback will handle the OAuth response');

    setTimeout(() => {
      server.kill();
      console.log('\nâœ… Test completed - OAuth flow is properly configured!');
      process.exit(0);
    }, 2000);
  }
});

server.on('error', (error) => {
  console.error('âŒ Error starting server:', error);
  process.exit(1);
});

setTimeout(() => {
  server.kill();
  console.log('\nâ° Test timeout');
  process.exit(1);
}, 15000);

NaN
FILE: outreach-client.js
SIZE: 8.64 KB | LINES: 313
MODIFIED: 2025-08-19T11:19:36.708Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

class OutreachClient {
  constructor() {
    this.clientId = process.env.OUTREACH_CLIENT_ID;
    this.clientSecret = process.env.OUTREACH_CLIENT_SECRET;
    this.redirectUri = process.env.OUTREACH_REDIRECT_URI || 'http:
    this.refreshToken = process.env.OUTREACH_REFRESH_TOKEN;
    this.baseURL = process.env.OUTREACH_API_BASE_URL || 'https:
    this.tokenURL = 'https:

    this.accessToken = null;
    this.tokenExpiry = null;

    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    this.client.interceptors.request.use(
      async (config) => {
        await this.ensureValidToken();
        config.headers['Authorization'] = `Bearer ${this.accessToken}`;
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          await this.refreshAccessToken();
          originalRequest.headers['Authorization'] = `Bearer ${this.accessToken}`;
          return this.client(originalRequest);
        }

        return Promise.reject(error);
      }
    );
  }

  async ensureValidToken() {
    if (!this.accessToken || this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
  }

  isTokenExpired() {
    if (!this.tokenExpiry) return true;
    return Date.now() >= this.tokenExpiry;
  }

  async refreshAccessToken() {
    try {
      const params = new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken
      });

      const response = await axios.post(this.tokenURL, params, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });

      this.accessToken = response.data.access_token;
      this.refreshToken = response.data.refresh_token || this.refreshToken;

      this.tokenExpiry = Date.now() + ((response.data.expires_in - 300) * 1000);

      if (response.data.refresh_token && response.data.refresh_token !== this.refreshToken) {
        console.error('New refresh token received:', response.data.refresh_token);
        console.error('Update your OUTREACH_REFRESH_TOKEN in .env file');
      }

      return this.accessToken;
    } catch (error) {
      throw new Error(`Failed to refresh access token: ${error.message}`);
    }
  }

  async createProspect(data) {
    try {
      const payload = {
        data: {
          type: 'prospect',
          attributes: {
            firstName: data.firstName,
            lastName: data.lastName,
            email: data.email,
            company: data.company,
            title: data.title,
            tags: data.tags || [],
            customFields: data.customFields || {}
          }
        }
      };

      const response = await this.client.post('/prospects', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create prospect: ${error.message}`);
    }
  }

  async searchProspects(criteria) {
    try {
      const params = new URLSearchParams();

      if (criteria.email) {
        params.append('filter[email]', criteria.email);
      }
      if (criteria.company) {
        params.append('filter[company]', criteria.company);
      }
      if (criteria.tags && criteria.tags.length > 0) {
        params.append('filter[tags]', criteria.tags.join(','));
      }
      if (criteria.limit) {
        params.append('page[limit]', criteria.limit);
      }

      const response = await this.client.get(`/prospects?${params.toString()}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to search prospects: ${error.message}`);
    }
  }

  async updateProspect(prospectId, updates) {
    try {
      const payload = {
        data: {
          type: 'prospect',
          id: prospectId,
          attributes: updates
        }
      };

      const response = await this.client.patch(`/prospects/${prospectId}`, payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to update prospect: ${error.message}`);
    }
  }

  async tagProspect(prospectId, tags) {
    try {

      const prospect = await this.client.get(`/prospects/${prospectId}`);
      const currentTags = prospect.data.data.attributes.tags || [];
      const newTags = [...new Set([...currentTags, ...tags])];

      return await this.updateProspect(prospectId, { tags: newTags });
    } catch (error) {
      throw new Error(`Failed to tag prospect: ${error.message}`);
    }
  }

  async getSequences(limit = 25) {
    try {
      const response = await this.client.get(`/sequences?page[limit]=${limit}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get sequences: ${error.message}`);
    }
  }

  async findSequence(name) {
    try {
      const response = await this.client.get(`/sequences?filter[name]=${encodeURIComponent(name)}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find sequence: ${error.message}`);
    }
  }

  async addProspectToSequence(prospectId, sequenceId, options = {}) {
    try {
      const payload = {
        data: {
          type: 'sequenceState',
          attributes: {
            state: 'active',
            ...options
          },
          relationships: {
            prospect: {
              data: {
                type: 'prospect',
                id: prospectId
              }
            },
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId
              }
            }
          }
        }
      };

      if (options.mailboxId) {
        payload.data.relationships.mailbox = {
          data: {
            type: 'mailbox',
            id: options.mailboxId
          }
        };
      }

      const response = await this.client.post('/sequenceStates', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to add prospect to sequence: ${error.message}`);
    }
  }

  async removeProspectFromSequence(sequenceStateId) {
    try {
      const payload = {
        data: {
          type: 'sequenceState',
          id: sequenceStateId,
          attributes: {
            state: 'finished'
          }
        }
      };

      const response = await this.client.patch(`/sequenceStates/${sequenceStateId}`, payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to remove prospect from sequence: ${error.message}`);
    }
  }

  async createAccount(data) {
    try {
      const payload = {
        data: {
          type: 'account',
          attributes: {
            name: data.name,
            domain: data.domain,
            industry: data.industry,
            size: data.size,
            customFields: data.customFields || {}
          }
        }
      };

      const response = await this.client.post('/accounts', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create account: ${error.message}`);
    }
  }

  async searchAccounts(criteria) {
    try {
      const params = new URLSearchParams();

      if (criteria.name) {
        params.append('filter[name]', criteria.name);
      }
      if (criteria.domain) {
        params.append('filter[domain]', criteria.domain);
      }

      const response = await this.client.get(`/accounts?${params.toString()}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to search accounts: ${error.message}`);
    }
  }

  async getMailboxes() {
    try {
      const response = await this.client.get('/mailboxes');
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get mailboxes: ${error.message}`);
    }
  }
}

export default OutreachClient;


NaN
FILE: package.json
SIZE: 1.99 KB | LINES: 66
MODIFIED: 2025-09-01T09:32:43.905Z
NaN

{
  "name": "mcp-outreach-server",
  "version": "1.0.0",
  "description": "MCP server for Outreach.io integration",
  "main": "src/index.js",
  "type": "module",
  "scripts": {
    "start": "node src/index.js",
    "dev": "node --watch src/index.js",
    "build": "tsc",
    "setup": "node src/setup-oauth.js",
    "bmad:flatten": "node .bmad/codebase-flattener.js",
    "bmad:story": "node .bmad/story-generator.js",
    "bmad:plan": "node .bmad/agent-planner.js",
    "bmad:deploy": "node .bmad/deploy-with-context.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --ci --coverage --watchAll=false",
    "analytics": "node scripts/analytics.js",
    "analyze": "node scripts/analyze.js",
    "health": "node scripts/project-health.js",
    "quality": "npm run analyze && npm run health",
    "cache:stats": "node scripts/cache-stats.js",
    "cache:populate": "node scripts/cache-populate.js",
    "cache:clear": "node scripts/cache-clear.js",
    "deploy-check": "npm run health && npm run test:ci",
    "full-dev-check": "npm run analyze && npm run health && npm run test:coverage"
  },
  "keywords": [
    "mcp",
    "outreach",
    "sales",
    "automation"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.17.3",
    "agentkeepalive": "^4.6.0",
    "axios": "^1.11.0",
    "dotenv": "^16.6.1",
    "express": "^4.18.0",
    "http-agent": "^0.1.2",
    "ioredis": "^5.7.0",
    "node-cache": "^5.1.2",
    "open": "^10.2.0",
    "redis": "^5.8.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "@types/node": "^20.19.11",
    "tsx": "^4.7.0",
    "typescript": "^5.9.2"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/raphael656-GTM/mcp-outreach-server.git"
  },
  "types": "./dist/index.d.ts",
  "bugs": {
    "url": "https://github.com/raphael656-GTM/mcp-outreach-server/issues"
  },
  "homepage": "https://github.com/raphael656-GTM/mcp-outreach-server#readme"
}


NaN
FILE: railway.json
SIZE: 261 B | LINES: 12
MODIFIED: 2025-08-28T11:57:06.791Z
NaN

{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "DOCKERFILE"
  },
  "deploy": {
    "healthcheckPath": "/health",
    "healthcheckTimeout": 100,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 10
  }
}

NaN
FILE: server.js
SIZE: 17.62 KB | LINES: 628
MODIFIED: 2025-09-01T08:11:44.544Z
NaN

#!/usr/bin/env node

import express from 'express';
import cors from 'cors';
import { spawn } from 'child_process';
import { config } from 'dotenv';

config();

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

const API_KEY = '55d6900ec2fbe3804ba6904ddfb82dc1879cbf0ecdca85b5cc16b8ce964c74c8';

app.use((req, res, next) => {
  const openPaths = [
    '/health',
    '/callback',
    '/',
    '/auth',
    '/auth/validate',
    '/mcp-server',
    '/download/proxy'
  ];

  if (req.path.startsWith('/api/organizations/') && req.path.includes('/mcp/')) {
    return next();
  }

  if (openPaths.includes(req.path)) {
    return next();
  }

  const key = req.headers['x-api-key'];
  if (!API_KEY || key === API_KEY) {
    return next();
  }
  return res.status(401).json({ error: 'Unauthorized: Invalid API key' });
});

app.get('/api/organizations/:orgId/mcp/start-auth/:serverId', (req, res) => {
  const { orgId, serverId } = req.params;
  const { redirect_url } = req.query;

  console.log('ðŸ” MCP OAuth start requested:', { orgId, serverId, redirect_url });

  res.json({
    status: 'success',
    message: 'No additional authentication required',
    redirect_url: redirect_url || 'claude:
  });
});

app.post('/api/organizations/:orgId/mcp/complete-auth/:serverId', (req, res) => {
  const { orgId, serverId } = req.params;

  console.log('ðŸ” MCP OAuth complete requested:', { orgId, serverId });

  res.json({
    status: 'authenticated',
    server_id: serverId
  });
});

app.get('/auth', (req, res) => {
  res.json({
    name: "MCP Outreach Server",
    version: "1.0",
    auth_type: "none",
    capabilities: {
      tools: {}
    }
  });
});

app.post('/auth/validate', (req, res) => {
  res.json({ status: 'authenticated' });
});

let mcpProcess = null;
let isInitialized = false;

function initializeMCPServer() {
  if (mcpProcess) return mcpProcess;

  console.log('ðŸš€ Starting MCP Outreach server...');
  console.log('ðŸ“‹ Environment check:');
  console.log('  - OUTREACH_CLIENT_ID:', process.env.OUTREACH_CLIENT_ID ? 'âœ… Set' : 'âŒ Missing');
  console.log('  - OUTREACH_CLIENT_SECRET:', process.env.OUTREACH_CLIENT_SECRET ? 'âœ… Set' : 'âŒ Missing');
  console.log('  - OUTREACH_REFRESH_TOKEN:', process.env.OUTREACH_REFRESH_TOKEN ? 'âœ… Set' : 'âŒ Missing');

  mcpProcess = spawn('node', ['dist/index.js'], {
    stdio: ['pipe', 'pipe', 'pipe'],
    env: {
      ...process.env,
      OUTREACH_CLIENT_ID: process.env.OUTREACH_CLIENT_ID,
      OUTREACH_CLIENT_SECRET: process.env.OUTREACH_CLIENT_SECRET,
      OUTREACH_REFRESH_TOKEN: process.env.OUTREACH_REFRESH_TOKEN,
      OUTREACH_REDIRECT_URI: process.env.OUTREACH_REDIRECT_URI,
      OUTREACH_API_BASE_URL: process.env.OUTREACH_API_BASE_URL || 'https:
    }
  });

  mcpProcess.stdout.on('data', (data) => {
    console.log('ðŸ“¡ MCP Server:', data.toString().trim());
  });

  mcpProcess.stderr.on('data', (data) => {
    const output = data.toString().trim();
    console.log('ðŸ”§ MCP Server:', output);

    if (output.includes('Outreach MCP server running') || output.includes('Enhanced Outreach Client initialized')) {
      isInitialized = true;
    }
  });

  mcpProcess.on('error', (error) => {
    console.error('âŒ MCP Server error:', error);
  });

  mcpProcess.on('exit', (code) => {
    console.log(`ðŸ”„ MCP Server exited with code ${code}`);
    mcpProcess = null;
    isInitialized = false;
  });

  return mcpProcess;
}

app.post('/mcp', async (req, res) => {
  try {
    if (!mcpProcess || !isInitialized) {
      const jsonRpcError = {
        jsonrpc: '2.0',
        id: req.body?.id || null,
        error: {
          code: -32002,
          message: 'MCP server not initialized',
          data: { details: 'Server is starting up, please try again in a moment' }
        }
      };
      return res.status(503).json(jsonRpcError);
    }

    const request = req.body;
    console.log('ðŸ“¥ MCP Request:', JSON.stringify(request));

    mcpProcess.stdin.write(JSON.stringify(request) + '\n');

    const response = await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Request timeout')), 30000);

      const onData = (data) => {
        try {
          const lines = data.toString().split('\n').filter(line => line.trim());
          for (const line of lines) {
            const parsed = JSON.parse(line);
            if (parsed.id === request.id) {
              clearTimeout(timeout);
              mcpProcess.stdout.removeListener('data', onData);
              resolve(parsed);
              return;
            }
          }
        } catch (e) {

        }
      };

      mcpProcess.stdout.on('data', onData);
    });

    res.json(response);
  } catch (error) {
    console.error('âŒ MCP Request error:', error);
    const jsonRpcError = {
      jsonrpc: '2.0',
      id: req.body?.id || null,
      error: {
        code: -32603,
        message: error.message,
        data: { type: 'mcp_error' }
      }
    };
    res.status(500).json(jsonRpcError);
  }
});

app.get('/download/proxy', (req, res) => {
  try {
    const fs = require('fs');
    const path = require('path');

    const proxyPath = path.join(process.cwd(), 'outreach-proxy.cjs');

    if (!fs.existsSync(proxyPath)) {
      return res.status(404).json({ error: 'Proxy script not found' });
    }

    const proxyContent = fs.readFileSync(proxyPath, 'utf8');

    res.setHeader('Content-Type', 'application/javascript');
    res.setHeader('Content-Disposition', 'attachment; filename="outreach-proxy.cjs"');

    res.send(proxyContent);

    console.log('ðŸ“¥ Proxy script downloaded');
  } catch (error) {
    console.error('âŒ Error serving proxy script:', error);
    res.status(500).json({ error: 'Failed to serve proxy script' });
  }
});

app.get('/tools', async (req, res) => {
  try {
    if (!mcpProcess || !isInitialized) {
      const jsonRpcError = {
        jsonrpc: '2.0',
        id: null,
        error: {
          code: -32002,
          message: 'MCP server not initialized',
          data: { details: 'Server is starting up, please try again in a moment' }
        }
      };
      return res.status(503).json(jsonRpcError);
    }

    const request = {
      jsonrpc: '2.0',
      id: Date.now(),
      method: 'tools/list'
    };

    console.log('ðŸ“¥ Tools list request:', JSON.stringify(request));

    mcpProcess.stdin.write(JSON.stringify(request) + '\n');

    const response = await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Request timeout')), 10000);

      const onData = (data) => {
        try {
          const lines = data.toString().split('\n').filter(line => line.trim());
          for (const line of lines) {
            try {
              const parsed = JSON.parse(line);
              if (parsed.id === request.id) {
                clearTimeout(timeout);
                mcpProcess.stdout.removeListener('data', onData);
                resolve(parsed);
                return;
              }
            } catch (e) {

            }
          }
        } catch (e) {

        }
      };

      mcpProcess.stdout.on('data', onData);
    });

    res.json(response);
  } catch (error) {
    console.error('âŒ Tools request error:', error);
    const jsonRpcError = {
      jsonrpc: '2.0',
      id: null,
      error: {
        code: -32603,
        message: error.message
      }
    };
    res.status(500).json(jsonRpcError);
  }
});

app.post('/tools/call', async (req, res) => {
  try {
    if (!mcpProcess || !isInitialized) {
      const jsonRpcError = {
        jsonrpc: '2.0',
        id: req.body?.name ? Date.now() : null,
        error: {
          code: -32002,
          message: 'MCP server not initialized',
          data: { details: 'Server is starting up, please try again in a moment' }
        }
      };
      return res.status(503).json(jsonRpcError);
    }

    const { name, arguments: args = {} } = req.body;

    const request = {
      jsonrpc: '2.0',
      id: Date.now(),
      method: 'tools/call',
      params: { name, arguments: args }
    };

    console.log('ðŸ“¥ Tool call request:', JSON.stringify(request));

    mcpProcess.stdin.write(JSON.stringify(request) + '\n');

    const response = await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => reject(new Error('Request timeout')), 30000);

      const onData = (data) => {
        try {
          const lines = data.toString().split('\n').filter(line => line.trim());
          for (const line of lines) {
            try {
              const parsed = JSON.parse(line);
              if (parsed.id === request.id) {
                clearTimeout(timeout);
                mcpProcess.stdout.removeListener('data', onData);

                if (!parsed.jsonrpc) {
                  console.error('âš ï¸  Invalid response: missing jsonrpc field');
                  parsed.jsonrpc = '2.0';
                }

                if (parsed.error) {
                  if (typeof parsed.error === 'string') {
                    parsed.error = {
                      code: -32603,
                      message: parsed.error
                    };
                  }
                  if (!parsed.error.code) {
                    parsed.error.code = -32603;
                  }
                  if (!parsed.error.message) {
                    parsed.error.message = 'Unknown error';
                  }
                }

                resolve(parsed);
                return;
              }
            } catch (e) {
              console.error('âš ï¸  Failed to parse MCP response line:', line, e.message);
            }
          }
        } catch (e) {
          console.error('âš ï¸  Error processing MCP response data:', e.message);
        }
      };

      mcpProcess.stdout.on('data', onData);
    });

    if (response && response.error) {
      console.log('ðŸ“¥ MCP subprocess returned error:', JSON.stringify(response, null, 2));
      return res.json(response);
    }

    res.json(response);
  } catch (error) {
    console.error('âŒ Tool call error:', error);

    const jsonRpcError = {
      jsonrpc: '2.0',
      id: req.body?.id || Date.now(),
      error: {
        code: -32603,
        message: error.message || 'Internal server error',
        data: { type: 'wrapper_error' }
      }
    };
    res.status(500).json(jsonRpcError);
  }
});

app.get('/callback', (req, res) => {
  const { code, state, error } = req.query;

  console.log('ðŸ” OAuth callback received:', { code, state, error });

  if (error) {
    return res.status(400).json({
      error: 'Authorization failed',
      details: error
    });
  }

  if (!code) {
    return res.status(400).json({
      error: 'No authorization code received'
    });
  }

  res.send(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>Authorization Successful</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; }
        .success { color: #28a745; }
        .code { background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 20px; }
      </style>
    </head>
    <body>
      <h1 class="success">âœ… Authorization Successful!</h1>
      <p>Your MCP Outreach server has been authorized!</p>
      <div class="code">
        <strong>Code:</strong> ${code}<br>
        <strong>State:</strong> ${state || 'N/A'}
      </div>
      <p>You can now use the MCP server tools. Check <a href="/tools">/tools</a> for available tools.</p>
    </body>
    </html>
  `);
});

app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    mcp_initialized: isInitialized
  });
});

app.use('/mcp-server', (req, res) => {

  res.setHeader('Content-Type', 'application/vnd.modelcontextprotocol+json');
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  if (req.method === 'GET') {

    return res.json({
      jsonrpc: '2.0',
      result: {
        protocolVersion: '2024-11-05',
        serverInfo: {
          name: 'mcp-outreach-server',
          version: '1.0.0'
        },
        capabilities: {
          tools: {}
        }
      }
    });
  }

  if (req.method === 'POST') {
    const request = req.body;
    console.log('ðŸ“¥ MCP Remote Request:', JSON.stringify(request));

    try {
      if (request.method === 'initialize') {
        return res.json({
          jsonrpc: '2.0',
          id: request.id,
          result: {
            protocolVersion: '2024-11-05',
            capabilities: {
              tools: {},
              resources: {},
              prompts: {}
            },
            serverInfo: {
              name: 'mcp-outreach-server',
              version: '1.0.0'
            }
          }
        });
      }

      if (request.method === 'tools/list') {
        return res.json({
          jsonrpc: '2.0',
          id: request.id,
          result: {
            tools: [
              {
                name: 'health_check',
                description: 'Check MCP server status',
                inputSchema: {
                  type: 'object',
                  properties: {}
                }
              },
              {
                name: 'get_sequences',
                description: 'List all Outreach sequences',
                inputSchema: {
                  type: 'object',
                  properties: {}
                }
              },
              {
                name: 'find_sequence',
                description: 'Find sequences by name',
                inputSchema: {
                  type: 'object',
                  properties: {
                    name: { type: 'string' }
                  },
                  required: ['name']
                }
              }
            ]
          }
        });
      }

      if (request.method === 'tools/call') {
        const { name, arguments: args = {} } = request.params;

        if (name === 'health_check') {
          return res.json({
            jsonrpc: '2.0',
            id: request.id,
            result: {
              content: [{
                type: 'text',
                text: `MCP Outreach Server is running!\nStatus: ${isInitialized ? 'MCP Process Running' : 'HTTP-only mode'}\nTimestamp: ${new Date().toISOString()}`
              }]
            }
          });
        }

        return res.json({
          jsonrpc: '2.0',
          id: request.id,
          result: {
            content: [{
              type: 'text',
              text: `Tool "${name}" is available but the MCP subprocess is still initializing. The connection is working but Outreach API calls need the subprocess to be ready.`
            }]
          }
        });
      }

      return res.json({
        jsonrpc: '2.0',
        id: request.id,
        error: {
          code: -32601,
          message: `Method not found: ${request.method}`
        }
      });

    } catch (error) {
      console.error('âŒ MCP Request error:', error);
      return res.json({
        jsonrpc: '2.0',
        id: request.id,
        error: {
          code: -32603,
          message: `Internal error: ${error.message}`
        }
      });
    }
  }
});

app.get('/', (req, res) => {
  res.json({
    message: 'MCP Outreach Server',
    status: isInitialized ? 'ready' : 'initializing',
    endpoints: {
      mcp: '/mcp - POST - Send MCP requests',
      tools: '/tools - GET - List available tools',
      'tools/call': '/tools/call - POST - Call a tool',
      callback: '/callback - OAuth callback',
      health: '/health - Health check',
      'claude-tools': '/claude-tools.json - Custom connector JSON'
    }
  });
});

initializeMCPServer();

app.listen(PORT, () => {
  console.log(`ðŸŒ HTTP wrapper for MCP server running on port ${PORT}`);
  console.log(`ðŸ”— Callback URL: ${process.env.RAILWAY_PUBLIC_DOMAIN ? 'https:
});

NaN
FILE: simple-oauth.js
SIZE: 2.07 KB | LINES: 71
MODIFIED: 2025-08-19T13:30:44.318Z
NaN

import express from 'express';
import axios from 'axios';
import fs from 'fs';
import open from 'open';

const CLIENT_ID = 'huKx35FSVCR1RXClVCLsorRq.Ljk9ZyPyfo2qqW~xeug';
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';
const REDIRECT_URI = 'http:
const PORT = 3001;

const app = express();

app.get('/callback', async (req, res) => {
  const { code } = req.query;

  if (!code) {
    return res.send('Error: No authorization code received');
  }

  try {
    const params = new URLSearchParams({
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URI,
      grant_type: 'authorization_code',
      code: code
    });

    console.log('\nðŸ“ Exchanging code for tokens...');
    const response = await axios.post('https:
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    const { refresh_token } = response.data;

    let envContent = fs.readFileSync('.env', 'utf8');
    envContent = envContent.replace(
      /OUTREACH_REFRESH_TOKEN=.*/,
      `OUTREACH_REFRESH_TOKEN=${refresh_token}`
    );
    fs.writeFileSync('.env', envContent);

    console.log('\nâœ… Success! Refresh token saved to .env');
    res.send('<h1>âœ… Success!</h1><p>You can close this window.</p>');

    setTimeout(() => process.exit(0), 2000);

  } catch (error) {
    console.error('Error:', error.response?.data || error.message);
    res.send(`Error: ${JSON.stringify(error.response?.data || error.message)}`);
  }
});

app.listen(PORT, () => {
  console.log(`Server running on http:

  const authUrl = `https:
    `client_id=${CLIENT_ID}&` +
    `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
    `response_type=code&` +
    `scope=accounts.all prospects.all sequences.all sequenceStates.all mailboxes.all tags.all users.all`;

  console.log('\nOpening browser...');
  console.log('If it doesn\'t open, visit:');
  console.log(authUrl);

  open(authUrl);
});

NaN
FILE: src/enhanced-outreach-client.js
SIZE: 25 KB | LINES: 770
MODIFIED: 2025-08-28T22:52:23.623Z
NaN

import dotenv from 'dotenv';
import ConnectionPoolManager from './performance/connection-pool.js';
import CacheManager from './performance/cache-manager.js';
import BulkOperationsManager from './performance/bulk-operations.js';
import EnhancedOAuthManager from './performance/enhanced-oauth.js';
import PerformanceMonitor from './performance/performance-monitor.js';

dotenv.config();

class EnhancedOutreachClient {
  constructor() {
    this.clientId = process.env.OUTREACH_CLIENT_ID;
    this.clientSecret = process.env.OUTREACH_CLIENT_SECRET;
    this.redirectUri = process.env.OUTREACH_REDIRECT_URI || 'http:
    this.refreshToken = process.env.OUTREACH_REFRESH_TOKEN;
    this.baseURL = process.env.OUTREACH_API_BASE_URL || 'https:

    this.connectionPool = new ConnectionPoolManager({
      maxSockets: 15,
      maxFreeSockets: 10,
      timeout: 30000
    });

    this.cacheManager = new CacheManager({
      oauthTtl: 3300,
      apiTtl: 300,
      sequenceTtl: 3600
    });

    this.performanceMonitor = new PerformanceMonitor();

    this.oauthManager = new EnhancedOAuthManager(
      this.clientId,
      this.clientSecret,
      this.redirectUri,
      this.refreshToken,
      this.cacheManager
    );

    this.client = this.connectionPool.getClient();
    this.client.defaults.baseURL = this.baseURL;

    this.bulkOps = new BulkOperationsManager(this, {
      batchSize: 25,
      maxRetries: 3,
      parallelLimit: 5
    });

    this.client.interceptors.request.use(
      async (config) => {
        const startTime = Date.now();
        config.metadata = { startTime };

        const token = await this.oauthManager.getAccessToken();
        config.headers['Authorization'] = `Bearer ${token}`;

        this.connectionPool.incrementStats();
        return config;
      },
      (error) => {
        console.error('âŒ Request interceptor error:', error);
        return Promise.reject(error);
      }
    );

    this.client.interceptors.response.use(
      (response) => {

        const responseTime = Date.now() - response.config.metadata.startTime;
        const toolName = this.extractToolNameFromUrl(response.config.url);
        this.performanceMonitor.recordRequest(toolName, responseTime, true);

        return response;
      },
      async (error) => {

        if (error.config && error.config.metadata) {
          const responseTime = Date.now() - error.config.metadata.startTime;
          const toolName = this.extractToolNameFromUrl(error.config.url);
          this.performanceMonitor.recordRequest(toolName, responseTime, false);
        }

        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          try {
            console.error('ðŸ”„ Refreshing token due to 401 error...');
            const token = await this.oauthManager.refreshAccessToken();
            originalRequest.headers['Authorization'] = `Bearer ${token}`;
            return this.client(originalRequest);
          } catch (refreshError) {
            console.error('âŒ Token refresh failed:', refreshError.message);
            return Promise.reject(error);
          }
        }

        return Promise.reject(error);
      }
    );

    console.error('âœ… Enhanced Outreach Client initialized with performance optimizations');
  }

  extractToolNameFromUrl(url) {
    if (!url) return 'unknown';

    const path = url.replace(this.baseURL, '');
    if (path.includes('/prospects')) return 'prospects';
    if (path.includes('/sequences')) return 'sequences';
    if (path.includes('/templates')) return 'templates';
    if (path.includes('/sequenceSteps')) return 'sequenceSteps';
    if (path.includes('/sequenceTemplates')) return 'sequenceTemplates';
    if (path.includes('/accounts')) return 'accounts';
    if (path.includes('/mailboxes')) return 'mailboxes';

    return 'other';
  }

  async makeApiCall(method, endpoint, data = null, useCache = false) {
    const cacheKey = useCache ? `${method}:${endpoint}:${JSON.stringify(data)}` : null;

    if (useCache && method === 'GET') {
      const cached = this.cacheManager.getApiResponse(endpoint, data);
      if (cached) {
        console.error(`ðŸŽ¯ Cache hit for ${endpoint}`);
        return cached;
      }
    }

    try {
      let response;

      switch (method.toLowerCase()) {
        case 'get':
          response = await this.client.get(endpoint, { params: data });
          break;
        case 'post':
          response = await this.client.post(endpoint, data);
          break;
        case 'patch':
          response = await this.client.patch(endpoint, data);
          break;
        case 'delete':
          response = await this.client.delete(endpoint);
          break;
        default:
          throw new Error(`Unsupported HTTP method: ${method}`);
      }

      if (useCache && method === 'GET') {
        this.cacheManager.setApiResponse(endpoint, data, response.data);
      }

      return response.data;

    } catch (error) {
      console.error(`âŒ API call failed: ${method} ${endpoint}`, error.message);
      throw error;
    }
  }

  async bulkCreateProspects(prospectsData, options = {}) {
    console.error(`ðŸ“¦ Bulk creating ${prospectsData.length} prospects...`);
    return await this.bulkOps.bulkCreateProspects(prospectsData, options);
  }

  async bulkCreateSequences(sequencesData, options = {}) {
    console.error(`ðŸ“¦ Bulk creating ${sequencesData.length} sequences...`);
    return await this.bulkOps.bulkCreateSequences(sequencesData, options);
  }

  async bulkCreateTemplates(templatesData, options = {}) {
    console.error(`ðŸ“¦ Bulk creating ${templatesData.length} templates...`);
    return await this.bulkOps.bulkCreateTemplates(templatesData, options);
  }

  async bulkEnrollProspects(enrollmentData, options = {}) {
    console.error(`ðŸ“¦ Bulk enrolling ${enrollmentData.length} prospects...`);
    return await this.bulkOps.bulkEnrollProspects(enrollmentData, options);
  }

  async createProspect(data) {
    try {
      const payload = {
        data: {
          type: 'prospect',
          attributes: {
            firstName: data.firstName,
            lastName: data.lastName,
            email: data.email,
            company: data.company,
            title: data.title,
            tags: data.tags || [],
            customFields: data.customFields || {}
          }
        }
      };

      const response = await this.makeApiCall('POST', '/prospects', payload);

      if (response.data && response.data.id) {
        this.cacheManager.setProspectData(response.data.id, response.data);
      }

      return response;
    } catch (error) {
      throw new Error(`Failed to create prospect: ${error.message}`);
    }
  }

  async searchProspects(criteria) {
    try {
      const params = new URLSearchParams();

      if (criteria.email) params.append('filter[email]', criteria.email);
      if (criteria.company) params.append('filter[company]', criteria.company);
      if (criteria.tags && criteria.tags.length > 0) params.append('filter[tags]', criteria.tags.join(','));
      if (criteria.limit) params.append('page[limit]', criteria.limit);

      const response = await this.makeApiCall('GET', `/prospects?${params.toString()}`, null, true);
      return response;
    } catch (error) {
      throw new Error(`Failed to search prospects: ${error.message}`);
    }
  }

  async getSequences(limit = 25) {
    try {
      const response = await this.makeApiCall('GET', `/sequences?page[limit]=${limit}`, null, true);
      return response;
    } catch (error) {
      throw new Error(`Failed to get sequences: ${error.message}`);
    }
  }

  async createSequence(sequenceData) {
    try {
      const payload = {
        data: {
          type: 'sequence',
          attributes: {
            name: sequenceData.name,
            description: sequenceData.description || '',
            tags: sequenceData.tags || [],
            shareType: sequenceData.shareType || 'shared'
          }
        }
      };

      const response = await this.makeApiCall('POST', '/sequences', payload);

      if (response.data && response.data.id) {
        this.cacheManager.setSequenceData(response.data.id, response.data);
        response._uiLink = `https:
      }

      return response;
    } catch (error) {

      if (error.response) {
        const status = error.response.status;
        const data = error.response.data;

        if (status === 422) {

          const validationErrors = data.errors?.map(err => err.detail).join(', ') || 'Validation failed';
          throw new Error(`Sequence validation failed: ${validationErrors}`);
        } else if (status === 409) {

          throw new Error(`Sequence name '${sequenceData.name}' already exists. Please choose a different name.`);
        } else if (status === 401) {
          throw new Error('Authentication failed. Please check your Outreach credentials.');
        } else if (status === 403) {
          throw new Error('Permission denied. You may not have rights to create sequences.');
        }

        throw new Error(`Failed to create sequence (${status}): ${data.errors?.[0]?.detail || error.message}`);
      }

      throw new Error(`Failed to create sequence: ${error.message}`);
    }
  }

  async createSequenceTemplate(templateData) {
    try {
      const payload = {
        data: {
          type: 'template',
          attributes: {
            name: templateData.name,
            subject: templateData.subject,
            ...(templateData.bodyHtml && { bodyHtml: templateData.bodyHtml }),
            ...(templateData.bodyText && { bodyText: templateData.bodyText }),
            ...(templateData.tags && { tags: templateData.tags }),
            shareType: templateData.shareType || 'shared',
            archived: false,
            trackLinks: templateData.trackLinks !== false,
            trackOpens: templateData.trackOpens !== false
          }
        }
      };

      const response = await this.makeApiCall('POST', '/templates', payload);

      if (response.data && response.data.id) {
        this.cacheManager.setTemplateData(response.data.id, response.data);
      }

      return response;
    } catch (error) {
      throw new Error(`Failed to create template: ${error.message}`);
    }
  }

  async createSequenceStep(stepData) {
    try {
      let order = stepData.order;
      if (!order) {
        const existingSteps = await this.getSequenceSteps(stepData.sequenceId);
        order = existingSteps.data ? existingSteps.data.length + 1 : 1;
      }

      const payload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: stepData.stepType === 'email' ? 'auto_email' : stepData.stepType || 'auto_email',
            order: order,
            interval: stepData.intervalInDays ? stepData.intervalInDays * 24 * 60 : 0,
            ...(stepData.taskNote && { taskNote: stepData.taskNote })
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: stepData.sequenceId
              }
            }
          }
        }
      };

      const response = await this.makeApiCall('POST', '/sequenceSteps', payload);
      return response;
    } catch (error) {
      throw new Error(`Failed to create sequence step: ${error.message}`);
    }
  }

  async getSequenceSteps(sequenceId) {
    try {
      const response = await this.makeApiCall('GET', `/sequenceSteps?filter[sequence][id]=${sequenceId}&sort=order`, null, true);
      return response;
    } catch (error) {
      throw new Error(`Failed to get sequence steps: ${error.message}`);
    }
  }

  async linkTemplateToStep(sequenceStepId, templateId) {
    try {
      const payload = {
        data: {
          type: 'sequenceTemplate',
          relationships: {
            sequenceStep: {
              data: {
                type: 'sequenceStep',
                id: sequenceStepId.toString()
              }
            },
            template: {
              data: {
                type: 'template',
                id: templateId.toString()
              }
            }
          }
        }
      };

      const response = await this.makeApiCall('POST', '/sequenceTemplates', payload);
      return response;
    } catch (error) {
      throw new Error(`Failed to link template to step: ${error.message}`);
    }
  }

  async addProspectToSequence(prospectId, sequenceId, options = {}) {
    try {
      const payload = {
        data: {
          type: 'sequenceState',
          attributes: {
            state: 'active',
            ...options
          },
          relationships: {
            prospect: {
              data: {
                type: 'prospect',
                id: prospectId
              }
            },
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId
              }
            }
          }
        }
      };

      if (options.mailboxId) {
        payload.data.relationships.mailbox = {
          data: {
            type: 'mailbox',
            id: options.mailboxId
          }
        };
      }

      const response = await this.makeApiCall('POST', '/sequenceStates', payload);
      return response;
    } catch (error) {
      throw new Error(`Failed to add prospect to sequence: ${error.message}`);
    }
  }

  async getMailboxes() {
    try {
      const response = await this.makeApiCall('GET', '/mailboxes', null, true);
      return response;
    } catch (error) {
      throw new Error(`Failed to get mailboxes: ${error.message}`);
    }
  }

  async createCompleteEmailSequence(data) {
    try {
      console.error(`ðŸŽ¯ Creating complete email sequence: ${data.sequenceName}`);

      const results = {
        sequence: null,
        templates: [],
        steps: [],
        links: [],
        summary: {
          sequenceName: data.sequenceName,
          emailCount: data.emails.length,
          success: false,
          errors: []
        }
      };

      try {
        const existing = await this.findSequence(data.sequenceName);
        if (existing.data && existing.data.length > 0) {
          throw new Error(`Sequence "${data.sequenceName}" already exists`);
        }
      } catch (error) {

        if (!error.message.includes('already exists')) {
          console.error('Warning: Could not check for existing sequence:', error.message);
        } else {
          throw error;
        }
      }

      const sequenceData = {
        name: data.sequenceName,
        description: data.description,
        tags: data.tags || [],
        shareType: 'shared'
      };

      results.sequence = await this.createSequence(sequenceData);
      const sequenceId = results.sequence.data.id.toString();

      console.error(`âœ… Created sequence ID: ${sequenceId}`);

      for (let i = 0; i < data.emails.length; i++) {
        const email = data.emails[i];

        const templateData = {
          name: email.templateName,
          subject: email.subject,
          bodyHtml: email.bodyHtml,
          tags: email.tags || [],
          trackLinks: true,
          trackOpens: true
        };

        const template = await this.createSequenceTemplate(templateData);
        results.templates.push(template);
        console.error(`âœ… Created template ${i + 1}: ${template.data.id}`);
      }

      for (let i = 0; i < data.emails.length; i++) {
        const email = data.emails[i];

        const stepData = {
          sequenceId: sequenceId,
          stepType: 'auto_email',
          order: i + 1,
          intervalInDays: email.intervalInDays
        };

        const step = await this.createSequenceStep(stepData);
        results.steps.push(step);
        console.error(`âœ… Created step ${i + 1}: ${step.data.id}`);
      }

      for (let i = 0; i < results.templates.length; i++) {
        const templateId = results.templates[i].data.id.toString();
        const stepId = results.steps[i].data.id.toString();

        const link = await this.linkTemplateToStep(stepId, templateId);
        results.links.push(link);
        console.error(`âœ… Linked template ${i + 1} to step ${i + 1}`);
      }

      results.summary.success = true;
      console.error(`ðŸŽ‰ Complete sequence created successfully: ${data.emails.length} emails, ${results.steps.length} steps`);

      return results;

    } catch (error) {
      console.error(`âŒ Failed to create complete email sequence: ${error.message}`);
      throw new Error(`Failed to create complete email sequence: ${error.message}`);
    }
  }

  async createAndEnrollProspect(data) {
    try {
      console.error(`ðŸ‘¤ Creating and enrolling prospect: ${data.prospect.firstName} ${data.prospect.lastName}`);

      const results = {
        prospect: null,
        sequence: null,
        enrollment: null,
        summary: {
          prospectEmail: data.prospect.email,
          sequenceName: data.sequenceName,
          success: false
        }
      };

      const sequenceResults = await this.findSequence(data.sequenceName);
      if (!sequenceResults.data || sequenceResults.data.length === 0) {
        throw new Error(`Sequence "${data.sequenceName}" not found`);
      }

      results.sequence = sequenceResults.data[0];
      const sequenceId = results.sequence.id.toString();
      console.error(`âœ… Found sequence ID: ${sequenceId}`);

      results.prospect = await this.createProspect(data.prospect);
      const prospectId = results.prospect.data.id.toString();
      console.error(`âœ… Created prospect ID: ${prospectId}`);

      const enrollmentOptions = data.options || {};
      results.enrollment = await this.addProspectToSequence(prospectId, sequenceId, enrollmentOptions);
      console.error(`âœ… Enrolled prospect in sequence`);

      results.summary.success = true;
      console.error(`ðŸŽ‰ Prospect created and enrolled successfully`);

      return results;

    } catch (error) {
      console.error(`âŒ Failed to create and enroll prospect: ${error.message}`);
      throw new Error(`Failed to create and enroll prospect: ${error.message}`);
    }
  }

  async createCampaignWithProspects(data) {
    try {
      console.error(`ðŸš€ Creating complete campaign: ${data.sequenceName} with ${data.prospects.length} prospects`);

      const results = {
        sequence: null,
        templates: [],
        steps: [],
        links: [],
        prospects: {
          successful: [],
          failed: []
        },
        enrollments: {
          successful: [],
          failed: []
        },
        summary: {
          sequenceName: data.sequenceName,
          emailCount: data.emails.length,
          prospectCount: data.prospects.length,
          success: false,
          prospectsCreated: 0,
          prospectsEnrolled: 0
        }
      };

      console.error(`ðŸ“§ Creating email sequence...`);
      const sequenceResults = await this.createCompleteEmailSequence({
        sequenceName: data.sequenceName,
        description: data.description,
        tags: data.tags,
        emails: data.emails
      });

      results.sequence = sequenceResults.sequence;
      results.templates = sequenceResults.templates;
      results.steps = sequenceResults.steps;
      results.links = sequenceResults.links;

      const sequenceId = results.sequence.data.id.toString();
      console.error(`âœ… Email sequence created with ID: ${sequenceId}`);

      console.error(`ðŸ‘¥ Creating ${data.prospects.length} prospects...`);
      const prospectResults = await this.bulkCreateProspects(data.prospects, {
        batchSize: 25,
        continueOnError: true
      });

      results.prospects = prospectResults;
      results.summary.prospectsCreated = prospectResults.successful.length;
      console.error(`âœ… Created ${prospectResults.successful.length}/${data.prospects.length} prospects`);

      if (prospectResults.successful.length > 0) {
        console.error(`ðŸ“¬ Enrolling ${prospectResults.successful.length} prospects in sequence...`);

        const enrollmentData = prospectResults.successful.map(prospect => ({
          prospectId: prospect.data.id.toString(),
          sequenceId: sequenceId
        }));

        const enrollmentResults = await this.bulkEnrollProspects(enrollmentData);
        results.enrollments = enrollmentResults;
        results.summary.prospectsEnrolled = enrollmentResults.successful.length;
        console.error(`âœ… Enrolled ${enrollmentResults.successful.length}/${prospectResults.successful.length} prospects`);
      }

      results.summary.success = true;
      console.error(`ðŸŽ‰ Complete campaign created: ${results.summary.prospectsEnrolled} prospects enrolled in ${data.emails.length}-email sequence`);

      return results;

    } catch (error) {
      console.error(`âŒ Failed to create complete campaign: ${error.message}`);
      throw new Error(`Failed to create complete campaign: ${error.message}`);
    }
  }

  async findSequence(name) {
    try {
      const params = new URLSearchParams();
      params.append('filter[name]', name);

      const response = await this.makeApiCall('GET', `/sequences?${params.toString()}`, null, true);
      return response;
    } catch (error) {
      throw new Error(`Failed to find sequence: ${error.message}`);
    }
  }

  getHealth() {
    return {
      timestamp: new Date().toISOString(),
      oauth: this.oauthManager.getHealth(),
      connectionPool: this.connectionPool.getHealth(),
      cache: this.cacheManager.getHealth(),
      bulkOps: this.bulkOps.getHealth(),
      performance: this.performanceMonitor.getHealth()
    };
  }

  getPerformanceMetrics() {
    return {
      timestamp: new Date().toISOString(),
      oauth: this.oauthManager.getStats(),
      connectionPool: this.connectionPool.getStats(),
      cache: this.cacheManager.getStats(),
      bulkOps: this.bulkOps.getStats(),
      performance: this.performanceMonitor.getMetrics()
    };
  }

  generatePerformanceReport() {
    return this.performanceMonitor.generateReport();
  }

  async shutdown() {
    console.error('ðŸ”„ Shutting down Enhanced Outreach Client...');

    if (this.oauthManager) {
      this.oauthManager.destroy();
    }

    if (this.connectionPool) {
      await this.connectionPool.shutdown();
    }

    if (this.cacheManager) {
      this.cacheManager.close();
    }

    if (this.performanceMonitor) {
      this.performanceMonitor.destroy();
    }

    console.error('âœ… Enhanced Outreach Client shutdown complete');
  }
}

export default EnhancedOutreachClient;

NaN
FILE: src/enhanced-tools.js
SIZE: 15.79 KB | LINES: 484
MODIFIED: 2025-08-28T12:22:58.982Z
NaN

export const enhancedTools = [

  {
    name: 'create_complete_email_sequence',
    description: 'Create a complete email sequence with templates and timing in one call - no need for multiple steps',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceName: {
          type: 'string',
          description: 'Name of the sequence (e.g., "TechCorp - Security Platform - Steve Jobs Style")'
        },
        description: {
          type: 'string',
          description: 'Description of the sequence purpose and target audience'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags for organizing the sequence (e.g., ["security", "enterprise", "cold outreach"])'
        },
        emails: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              templateName: { type: 'string', description: 'Name of the email template' },
              subject: { type: 'string', description: 'Email subject line with personalization variables' },
              bodyHtml: { type: 'string', description: 'HTML email content with {{first_name}} and {{account.name}} variables' },
              tags: { type: 'array', items: { type: 'string' }, description: 'Tags for this specific email' },
              intervalInDays: { type: 'number', description: 'Days to wait before sending this email (0 for first email)' }
            },
            required: ['templateName', 'subject', 'bodyHtml', 'intervalInDays']
          },
          minItems: 1,
          maxItems: 10,
          description: 'Array of email templates with timing'
        }
      },
      required: ['sequenceName', 'description', 'emails']
    }
  },

  {
    name: 'create_and_enroll_prospect',
    description: 'Create a prospect and immediately enroll them in a sequence - combines two steps into one',
    inputSchema: {
      type: 'object',
      properties: {
        prospect: {
          type: 'object',
          properties: {
            firstName: { type: 'string', description: 'Prospect first name' },
            lastName: { type: 'string', description: 'Prospect last name' },
            email: { type: 'string', description: 'Prospect email address' },
            company: { type: 'string', description: 'Company name' },
            title: { type: 'string', description: 'Job title' },
            tags: { type: 'array', items: { type: 'string' } },
            customFields: { type: 'object' }
          },
          required: ['firstName', 'lastName', 'email']
        },
        sequenceName: {
          type: 'string',
          description: 'Name of the sequence to enroll prospect in'
        },
        options: {
          type: 'object',
          properties: {
            mailboxId: { type: 'string', description: 'ID of mailbox to use for sending (optional)' }
          }
        }
      },
      required: ['prospect', 'sequenceName']
    }
  },

  {
    name: 'create_campaign_with_prospects',
    description: 'Create complete campaign: sequence with emails + prospects + enrollment - full campaign setup in one call',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceName: {
          type: 'string',
          description: 'Name of the sequence/campaign'
        },
        description: {
          type: 'string',
          description: 'Campaign description and target audience'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Campaign tags for organization'
        },
        emails: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              templateName: { type: 'string' },
              subject: { type: 'string' },
              bodyHtml: { type: 'string' },
              tags: { type: 'array', items: { type: 'string' } },
              intervalInDays: { type: 'number' }
            },
            required: ['templateName', 'subject', 'bodyHtml', 'intervalInDays']
          },
          minItems: 1,
          maxItems: 10
        },
        prospects: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              firstName: { type: 'string' },
              lastName: { type: 'string' },
              email: { type: 'string' },
              company: { type: 'string' },
              title: { type: 'string' },
              tags: { type: 'array', items: { type: 'string' } }
            },
            required: ['firstName', 'lastName', 'email']
          },
          minItems: 1,
          maxItems: 100,
          description: 'List of prospects to create and enroll'
        }
      },
      required: ['sequenceName', 'description', 'emails', 'prospects']
    }
  },

  {
    name: 'bulk_create_prospects',
    description: 'Create multiple prospects in batch (25-50 at once) for improved performance',
    inputSchema: {
      type: 'object',
      properties: {
        prospects: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              firstName: { type: 'string', description: 'First name' },
              lastName: { type: 'string', description: 'Last name' },
              email: { type: 'string', description: 'Email address' },
              company: { type: 'string', description: 'Company name' },
              title: { type: 'string', description: 'Job title' },
              tags: { type: 'array', items: { type: 'string' } },
              customFields: { type: 'object' }
            },
            required: ['firstName', 'lastName', 'email']
          },
          minItems: 1,
          maxItems: 50,
          description: 'Array of prospect objects to create'
        },
        options: {
          type: 'object',
          properties: {
            batchSize: { type: 'number', default: 25, description: 'Number of prospects per batch' },
            continueOnError: { type: 'boolean', default: true, description: 'Continue processing if some fail' }
          }
        }
      },
      required: ['prospects']
    }
  },

  {
    name: 'bulk_create_sequences',
    description: 'Create multiple sequences in batch for improved performance',
    inputSchema: {
      type: 'object',
      properties: {
        sequences: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Sequence name' },
              description: { type: 'string', description: 'Sequence description' },
              tags: { type: 'array', items: { type: 'string' } },
              shareType: { type: 'string', enum: ['shared', 'private', 'team'], default: 'shared' }
            },
            required: ['name']
          },
          minItems: 1,
          maxItems: 25,
          description: 'Array of sequence objects to create'
        }
      },
      required: ['sequences']
    }
  },

  {
    name: 'bulk_create_templates',
    description: 'Create multiple email templates in batch for improved performance',
    inputSchema: {
      type: 'object',
      properties: {
        templates: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              name: { type: 'string', description: 'Template name' },
              subject: { type: 'string', description: 'Email subject line' },
              bodyHtml: { type: 'string', description: 'HTML email body' },
              bodyText: { type: 'string', description: 'Plain text email body' },
              tags: { type: 'array', items: { type: 'string' } },
              shareType: { type: 'string', enum: ['shared', 'private'], default: 'shared' }
            },
            required: ['name', 'subject']
          },
          minItems: 1,
          maxItems: 20,
          description: 'Array of template objects to create'
        }
      },
      required: ['templates']
    }
  },

  {
    name: 'bulk_enroll_prospects',
    description: 'Enroll multiple prospects in sequences in batch for improved performance',
    inputSchema: {
      type: 'object',
      properties: {
        enrollments: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              prospectId: { type: 'string', description: 'Prospect ID' },
              sequenceId: { type: 'string', description: 'Sequence ID' },
              options: {
                type: 'object',
                properties: {
                  mailboxId: { type: 'string', description: 'Mailbox ID for sending' },
                  state: { type: 'string', default: 'active' }
                }
              }
            },
            required: ['prospectId', 'sequenceId']
          },
          minItems: 1,
          maxItems: 100,
          description: 'Array of prospect enrollment objects'
        }
      },
      required: ['enrollments']
    }
  },

  {
    name: 'get_performance_metrics',
    description: 'Get detailed performance metrics for the MCP server',
    inputSchema: {
      type: 'object',
      properties: {
        includeDetails: {
          type: 'boolean',
          default: false,
          description: 'Include detailed breakdown by tool and component'
        }
      }
    }
  },

  {
    name: 'get_health_status',
    description: 'Get comprehensive health status of all MCP server components',
    inputSchema: {
      type: 'object',
      properties: {
        includeAlerts: {
          type: 'boolean',
          default: true,
          description: 'Include performance alerts and warnings'
        }
      }
    }
  },

  {
    name: 'generate_performance_report',
    description: 'Generate detailed performance report with recommendations',
    inputSchema: {
      type: 'object',
      properties: {
        format: {
          type: 'string',
          enum: ['summary', 'detailed', 'json'],
          default: 'summary',
          description: 'Report format and detail level'
        }
      }
    }
  },

  {
    name: 'clear_cache',
    description: 'Clear cached data to force fresh API calls',
    inputSchema: {
      type: 'object',
      properties: {
        cacheType: {
          type: 'string',
          enum: ['all', 'api', 'prospects', 'sequences', 'templates'],
          default: 'api',
          description: 'Type of cache to clear'
        }
      }
    }
  },

  {
    name: 'get_cache_stats',
    description: 'Get cache performance statistics and hit rates',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  },

  {
    name: 'create_prospect',
    description: 'Create a new prospect in Outreach (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {
        firstName: { type: 'string', description: 'First name of the prospect' },
        lastName: { type: 'string', description: 'Last name of the prospect' },
        email: { type: 'string', description: 'Email address of the prospect' },
        company: { type: 'string', description: 'Company name' },
        title: { type: 'string', description: 'Job title of the prospect' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags to assign to the prospect' },
        customFields: { type: 'object', description: 'Custom fields as key-value pairs' }
      },
      required: ['firstName', 'lastName', 'email']
    }
  },

  {
    name: 'search_prospects',
    description: 'Search for prospects based on criteria (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {
        email: { type: 'string', description: 'Search by email address' },
        company: { type: 'string', description: 'Search by company name' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Search by tags' },
        limit: { type: 'number', description: 'Maximum number of results', default: 25 }
      }
    }
  },

  {
    name: 'get_sequences',
    description: 'Get all sequences from Outreach (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {
        limit: { type: 'number', description: 'Maximum number of sequences', default: 25 }
      }
    }
  },

  {
    name: 'create_sequence',
    description: 'Create a new sequence in Outreach (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the sequence' },
        description: { type: 'string', description: 'Description of the sequence' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags for the sequence' },
        shareType: { type: 'string', description: 'Share type', enum: ['shared', 'private', 'team'], default: 'shared' }
      },
      required: ['name']
    }
  },

  {
    name: 'create_sequence_step',
    description: 'Add a step to a sequence (email, call, or task)',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceId: { type: 'string', description: 'ID of the sequence' },
        stepType: { type: 'string', description: 'Type of step', enum: ['email', 'auto_email', 'manual_email', 'call', 'task'], default: 'auto_email' },
        intervalInDays: { type: 'number', description: 'Days to wait before this step', default: 0 },
        taskNote: { type: 'string', description: 'Note for call/task steps' },
        order: { type: 'number', description: 'Step order in sequence' }
      },
      required: ['sequenceId']
    }
  },

  {
    name: 'create_sequence_template',
    description: 'Create an email template for sequence steps (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the template' },
        subject: { type: 'string', description: 'Email subject line (use {{first_name}} and {{account.name}} for variables)' },
        bodyHtml: { type: 'string', description: 'HTML email body' },
        bodyText: { type: 'string', description: 'Plain text email body' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags for organizing templates' },
        trackLinks: { type: 'boolean', description: 'Whether to track link clicks', default: true },
        trackOpens: { type: 'boolean', description: 'Whether to track email opens', default: true }
      },
      required: ['name', 'subject']
    }
  },

  {
    name: 'link_template_to_step',
    description: 'Link an existing template to a sequence step',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceStepId: { type: 'string', description: 'ID of the sequence step' },
        templateId: { type: 'string', description: 'ID of the template to link' }
      },
      required: ['sequenceStepId', 'templateId']
    }
  },

  {
    name: 'add_prospect_to_sequence',
    description: 'Add a prospect to a sequence',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: { type: 'string', description: 'ID of the prospect' },
        sequenceId: { type: 'string', description: 'ID of the sequence' },
        options: {
          type: 'object',
          properties: {
            mailboxId: { type: 'string', description: 'ID of the mailbox to use for sending' }
          }
        }
      },
      required: ['prospectId', 'sequenceId']
    }
  },

  {
    name: 'get_mailboxes',
    description: 'Get all available mailboxes (enhanced with caching)',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  },

  {
    name: 'health_check',
    description: 'Check the health status of the MCP server and Outreach API connection',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  }
];

NaN
FILE: src/index.js
SIZE: 9.85 KB | LINES: 356
MODIFIED: 2025-08-28T22:52:23.623Z
NaN

#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from '@modelcontextprotocol/sdk/types.js';
import EnhancedOutreachClient from './enhanced-outreach-client.js';
import { enhancedTools } from './enhanced-tools.js';
import { config } from 'dotenv';

config();

const server = new Server(
  {
    name: process.env.MCP_SERVER_NAME || 'outreach-mcp',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

let outreachClient;

async function initializeClient() {
  try {
    outreachClient = new EnhancedOutreachClient();
    console.error('âœ… Outreach MCP server initialized successfully');
  } catch (error) {
    console.error('âŒ Failed to initialize Outreach client:', error.message);
    throw error;
  }
}

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: enhancedTools
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args = {} } = request.params;

  if (process.env.DEBUG) {
    console.error('ðŸ”§ Tool called:', name, JSON.stringify(args, null, 2));
  }

  if (!outreachClient) {
    throw new McpError(ErrorCode.InternalError, 'Outreach client not initialized');
  }

  if (name === 'health_check') {
    try {
      const health = outreachClient.getHealth();
      await outreachClient.getMailboxes();
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            ...health,
            server: process.env.MCP_SERVER_NAME || 'outreach-mcp',
            version: '1.0.0'
          }, null, 2)
        }]
      };
    } catch (error) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            status: 'unhealthy',
            error: error.message,
            timestamp: new Date().toISOString()
          }, null, 2)
        }]
      };
    }
  }

  try {
    let result;

    switch (name) {

      case 'create_prospect':
        result = await outreachClient.createProspect(args);
        break;

      case 'search_prospects':
        result = await outreachClient.searchProspects(args);
        break;

      case 'update_prospect':
        result = await outreachClient.updateProspect(args.prospectId, args.updates);
        break;

      case 'tag_prospect':
        result = await outreachClient.tagProspect(args.prospectId, args.tags);
        break;

      case 'get_sequences':
        result = await outreachClient.getSequences(args.limit);
        break;

      case 'find_sequence':
        result = await outreachClient.findSequence(args.name);
        break;

      case 'create_sequence':
        result = await outreachClient.createSequence(args);
        break;

      case 'create_sequence_step':
        result = await outreachClient.createSequenceStep(args);
        break;

      case 'get_sequence_steps':
        result = await outreachClient.getSequenceSteps(args.sequenceId);
        break;

      case 'create_sequence_template':
        result = await outreachClient.createSequenceTemplate(args);
        break;

      case 'get_sequence_templates':
        result = await outreachClient.getSequenceTemplates(args);
        break;

      case 'find_sequence_template':
        result = await outreachClient.findSequenceTemplate(args.name);
        break;

      case 'update_sequence_template':
        result = await outreachClient.updateSequenceTemplate(args.templateId, args.updates);
        break;

      case 'link_template_to_step':
        result = await outreachClient.linkTemplateToStep(args.sequenceStepId, args.templateId);
        break;

      case 'add_prospect_to_sequence':
        result = await outreachClient.addProspectToSequence(
          args.prospectId,
          args.sequenceId,
          args.options
        );
        break;

      case 'remove_prospect_from_sequence':
        result = await outreachClient.removeProspectFromSequence(args.sequenceStateId);
        break;

      case 'create_account':
        result = await outreachClient.createAccount(args);
        break;

      case 'search_accounts':
        result = await outreachClient.searchAccounts(args);
        break;

      case 'get_mailboxes':
        result = await outreachClient.getMailboxes();
        break;

      case 'create_complete_email_sequence':
        result = await outreachClient.createCompleteEmailSequence(args);
        break;

      case 'create_and_enroll_prospect':
        result = await outreachClient.createAndEnrollProspect(args);
        break;

      case 'create_campaign_with_prospects':
        result = await outreachClient.createCampaignWithProspects(args);
        break;

      case 'bulk_create_prospects':
        result = await outreachClient.bulkCreateProspects(args.prospects, args.options);
        break;

      case 'bulk_create_sequences':
        result = await outreachClient.bulkCreateSequences(args.sequences);
        break;

      case 'bulk_create_templates':
        result = await outreachClient.bulkCreateTemplates(args.templates);
        break;

      case 'bulk_enroll_prospects':
        result = await outreachClient.bulkEnrollProspects(args.enrollments);
        break;

      case 'get_performance_metrics':
        result = outreachClient.getPerformanceMetrics();
        break;

      case 'get_health_status':
        result = outreachClient.getHealth();
        break;

      case 'generate_performance_report':
        result = outreachClient.generatePerformanceReport();
        break;

      case 'clear_cache':
        result = {
          success: true,
          message: `Cache cleared for type: ${args.cacheType || 'api'}`,
          timestamp: new Date().toISOString()
        };

        if (args.cacheType === 'all') {
          outreachClient.cacheManager.clear();
        } else {
          outreachClient.cacheManager.clearByType(args.cacheType || 'api');
        }
        break;

      case 'get_cache_stats':
        result = outreachClient.cacheManager.getStats();
        break;

      default:
        throw new McpError(ErrorCode.MethodNotFound, `Tool ${name} not found`);
    }

    if (process.env.DEBUG) {
      console.error('ðŸ“Š Result:', JSON.stringify(result, null, 2));
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify(result, null, 2)
        }
      ]
    };

  } catch (error) {
    console.error(`âŒ Error executing tool ${name}:`, error);

    if (error.response) {
      const statusCode = error.response.status;
      const responseData = error.response.data;

      if (statusCode === 401) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'Authentication failed. Please check your Outreach API token.'
        );
      } else if (statusCode === 403) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'Access denied. Please check your API permissions.'
        );
      } else if (statusCode === 429) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'Rate limit exceeded. Please try again later.'
        );
      } else if (statusCode >= 400 && statusCode < 500) {

        const errorDetail = responseData?.errors?.[0]?.detail ||
                           responseData?.message ||
                           error.message;
        throw new McpError(
          ErrorCode.InvalidRequest,
          `Bad request (${statusCode}): ${errorDetail}`
        );
      } else if (statusCode >= 500) {
        const errorDetail = responseData?.errors?.[0]?.detail ||
                           responseData?.message ||
                           'Server error';
        throw new McpError(
          ErrorCode.InternalError,
          `Outreach server error (${statusCode}): ${errorDetail}`
        );
      }
    }

    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {
      throw new McpError(
        ErrorCode.InternalError,
        'Cannot connect to Outreach API. Please check your network connection.'
      );
    }

    if (error.code === 'ETIMEDOUT') {
      throw new McpError(
        ErrorCode.InternalError,
        'Request to Outreach API timed out. Please try again.'
      );
    }

    throw new McpError(
      ErrorCode.InternalError,
      `Error executing ${name}: ${error.message}`
    );
  }
});

async function main() {
  try {
    await initializeClient();
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error('ðŸš€ Outreach MCP server running on stdio');
  } catch (error) {
    console.error('ðŸ’¥ Fatal error starting server:', error);
    process.exit(1);
  }
}

process.on('SIGINT', async () => {
  console.error('ðŸ›‘ Server shutting down...');
  if (outreachClient) {
    await outreachClient.shutdown();
  }
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.error('ðŸ›‘ Server shutting down...');
  if (outreachClient) {
    await outreachClient.shutdown();
  }
  process.exit(0);
});

main().catch((error) => {
  console.error('ðŸ’¥ Fatal error:', error);
  process.exit(1);
});

NaN
FILE: src/index.ts
SIZE: 8.99 KB | LINES: 316
MODIFIED: 2025-08-28T22:52:23.615Z
NaN

#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ErrorCode,
  McpError
} from '@modelcontextprotocol/sdk/types.js';
import { OutreachClient } from './outreach-client.js';
import { OutreachOAuth } from './oauth.js';
import { config } from 'dotenv';

config();

const server = new Server(
  {
    name: 'mcp-outreach-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

let outreachClient: OutreachClient;

async function initializeClient() {

  const apiToken = process.env.OUTREACH_API_TOKEN;

  if (!apiToken) {
    throw new Error('OUTREACH_API_TOKEN environment variable is required. Please set your Outreach.io API token.');
  }

  outreachClient = new OutreachClient(
    apiToken,
    process.env.OUTREACH_API_URL || 'https:
  );

  console.error('MCP Outreach server initialized with API token');
}

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'create_sequence',
        description: 'Create a new sequence in Outreach',
        inputSchema: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'Name of the sequence',
            },
            description: {
              type: 'string',
              description: 'Description of the sequence',
            },
            enabled: {
              type: 'boolean',
              description: 'Whether the sequence is enabled',
              default: true,
            },
            shareType: {
              type: 'string',
              description: 'Share type: private, read_only, or shared',
              enum: ['private', 'read_only', 'shared'],
              default: 'private',
            },
          },
          required: ['name'],
        },
      },
      {
        name: 'list_sequences',
        description: 'List all sequences in Outreach',
        inputSchema: {
          type: 'object',
          properties: {
            limit: {
              type: 'number',
              description: 'Number of sequences to return',
              default: 50,
            },
            offset: {
              type: 'number',
              description: 'Offset for pagination',
              default: 0,
            },
          },
        },
      },
      {
        name: 'get_account_prospects',
        description: 'Get prospects from a specific account',
        inputSchema: {
          type: 'object',
          properties: {
            accountId: {
              type: 'number',
              description: 'ID of the account',
            },
            accountName: {
              type: 'string',
              description: 'Name of the account (alternative to accountId)',
            },
            limit: {
              type: 'number',
              description: 'Number of prospects to return',
              default: 100,
            },
          },
        },
      },
      {
        name: 'search_accounts',
        description: 'Search for accounts by name or domain',
        inputSchema: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'Search query (name or domain)',
            },
            limit: {
              type: 'number',
              description: 'Number of accounts to return',
              default: 20,
            },
          },
          required: ['query'],
        },
      },
      {
        name: 'add_prospects_to_sequence',
        description: 'Add prospects to a sequence',
        inputSchema: {
          type: 'object',
          properties: {
            sequenceId: {
              type: 'number',
              description: 'ID of the sequence',
            },
            prospectIds: {
              type: 'array',
              items: {
                type: 'number',
              },
              description: 'Array of prospect IDs to add',
            },
            mailboxId: {
              type: 'number',
              description: 'ID of the mailbox to use for sending',
            },
          },
          required: ['sequenceId', 'prospectIds'],
        },
      },
      {
        name: 'create_sequence_step',
        description: 'Add a step to a sequence',
        inputSchema: {
          type: 'object',
          properties: {
            sequenceId: {
              type: 'number',
              description: 'ID of the sequence',
            },
            order: {
              type: 'number',
              description: 'Order of the step in the sequence',
            },
            interval: {
              type: 'number',
              description: 'Days to wait before this step',
              default: 1,
            },
            stepType: {
              type: 'string',
              description: 'Type of step: auto_email, manual_email, call, task, linkedin_send_message',
              enum: ['auto_email', 'manual_email', 'call', 'task', 'linkedin_send_message'],
            },
            subject: {
              type: 'string',
              description: 'Email subject (for email steps)',
            },
            body: {
              type: 'string',
              description: 'Content of the step',
            },
          },
          required: ['sequenceId', 'order', 'stepType'],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args = {} } = request.params;

  try {
    switch (name) {
      case 'create_sequence': {
        const result = await outreachClient.createSequence(
          args.name as string,
          args.description as string,
          args.enabled as boolean,
          args.shareType as string
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      case 'list_sequences': {
        const result = await outreachClient.listSequences(
          args.limit as number,
          args.offset as number
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      case 'get_account_prospects': {
        const result = await outreachClient.getAccountProspects(
          args.accountId as number,
          args.accountName as string,
          args.limit as number
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      case 'search_accounts': {
        const result = await outreachClient.searchAccounts(
          args.query as string,
          args.limit as number
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      case 'add_prospects_to_sequence': {
        const result = await outreachClient.addProspectsToSequence(
          args.sequenceId as number,
          args.prospectIds as number[],
          args.mailboxId as number
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      case 'create_sequence_step': {
        const result = await outreachClient.createSequenceStep(
          args.sequenceId as number,
          args.order as number,
          args.interval as number,
          args.stepType as string,
          args.subject as string,
          args.body as string
        );
        return { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] };
      }

      default:
        throw new McpError(ErrorCode.MethodNotFound, `Tool ${name} not found`);
    }
  } catch (error: any) {
    console.error(`Error executing ${name}:`, error);

    if (error.response) {
      const statusCode = error.response.status;
      const responseData = error.response.data;

      if (statusCode === 401) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'Authentication failed. Please check your API token.'
        );
      } else if (statusCode === 403) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          'Access denied. Please check your API permissions.'
        );
      } else if (statusCode >= 400 && statusCode < 500) {
        throw new McpError(
          ErrorCode.InvalidRequest,
          `Bad request: ${responseData?.errors?.[0]?.detail || error.message}`
        );
      } else {
        throw new McpError(
          ErrorCode.InternalError,
          `Server error: ${responseData?.errors?.[0]?.detail || error.message}`
        );
      }
    }

    throw new McpError(
      ErrorCode.InternalError,
      `Error executing ${name}: ${error.message}`
    );
  }
});

async function main() {
  await initializeClient();
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('MCP Outreach server running on stdio');
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

NaN
FILE: src/oauth.ts
SIZE: 5.71 KB | LINES: 192
MODIFIED: 2025-08-18T12:07:44.242Z
NaN

import express from 'express';
import axios from 'axios';
import fs from 'fs/promises';
import path from 'path';
import { spawn } from 'child_process';
import os from 'os';

interface OAuthConfig {
  clientId: string;
  clientSecret: string;
  redirectUri: string;
  scope: string;
}

interface TokenData {
  access_token: string;
  refresh_token: string;
  expires_at: number;
}

const TOKEN_FILE = path.join(os.homedir(), '.mcp-outreach', 'token.json');

export class OutreachOAuth {
  private config: OAuthConfig;
  private tokenData?: TokenData;

  constructor(config: OAuthConfig) {
    this.config = config;
  }

  async initialize(): Promise<string> {

    try {
      const tokenContent = await fs.readFile(TOKEN_FILE, 'utf8');
      this.tokenData = JSON.parse(tokenContent);

      if (this.tokenData && Date.now() < this.tokenData.expires_at) {
        console.error('Using existing valid token');
        return this.tokenData.access_token;
      }

      if (this.tokenData?.refresh_token) {
        console.error('Token expired, refreshing...');
        return await this.refreshToken();
      }
    } catch (error) {
      console.error('No valid token found, starting OAuth flow...');
    }

    return await this.startOAuthFlow();
  }

  private async startOAuthFlow(): Promise<string> {
    return new Promise((resolve, reject) => {
      const app = express();
      let server: any;

      app.get('/callback', async (req, res) => {
        const { code } = req.query;

        if (!code) {
          res.send('Error: No authorization code received');
          server.close();
          reject(new Error('No authorization code received'));
          return;
        }

        try {

          const tokenResponse = await axios.post('https:
            client_id: this.config.clientId,
            client_secret: this.config.clientSecret,
            code: code as string,
            grant_type: 'authorization_code',
            redirect_uri: this.config.redirectUri
          });

          const { access_token, refresh_token, expires_in } = tokenResponse.data;

          this.tokenData = {
            access_token,
            refresh_token,
            expires_at: Date.now() + (expires_in * 1000)
          };

          await this.saveToken();

          res.send(`
            <html>
              <body style="font-family: sans-serif; text-align: center; padding: 50px;">
                <h1>âœ… Authentication Successful!</h1>
                <p>You can now close this window and return to Claude.</p>
                <script>setTimeout(() => window.close(), 3000);</script>
              </body>
            </html>
          `);

          server.close();
          resolve(access_token);
        } catch (error) {
          res.send('Error exchanging code for token');
          server.close();
          reject(error);
        }
      });

      const port = this.config.redirectUri.includes('localhost:3001') ? 3001 : 3000;
      server = app.listen(port, () => {
        console.error(`OAuth server listening on http:

        const authUrl = new URL('https:
        authUrl.searchParams.append('client_id', this.config.clientId);
        authUrl.searchParams.append('redirect_uri', this.config.redirectUri);
        authUrl.searchParams.append('response_type', 'code');
        authUrl.searchParams.append('scope', this.config.scope);

        console.error('\nðŸ” Please authorize the application:');
        console.error(authUrl.toString());
        console.error('\nOpening browser...\n');

        const openCommand = process.platform === 'darwin' ? 'open' :
                          process.platform === 'win32' ? 'start' :
                          'xdg-open';

        spawn(openCommand, [authUrl.toString()], { detached: true });
      });

      setTimeout(() => {
        server.close();
        reject(new Error('OAuth flow timed out'));
      }, 300000);
    });
  }

  private async refreshToken(): Promise<string> {
    if (!this.tokenData?.refresh_token) {
      throw new Error('No refresh token available');
    }

    try {
      const response = await axios.post('https:
        client_id: this.config.clientId,
        client_secret: this.config.clientSecret,
        refresh_token: this.tokenData.refresh_token,
        grant_type: 'refresh_token'
      });

      const { access_token, refresh_token, expires_in } = response.data;

      this.tokenData = {
        access_token,
        refresh_token: refresh_token || this.tokenData.refresh_token,
        expires_at: Date.now() + (expires_in * 1000)
      };

      await this.saveToken();
      return access_token;
    } catch (error) {
      console.error('Failed to refresh token:', error);

      return await this.startOAuthFlow();
    }
  }

  private async saveToken(): Promise<void> {
    const dir = path.dirname(TOKEN_FILE);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(TOKEN_FILE, JSON.stringify(this.tokenData, null, 2));
  }

  async getValidToken(): Promise<string> {
    if (!this.tokenData) {
      return await this.initialize();
    }

    if (Date.now() >= this.tokenData.expires_at) {
      return await this.refreshToken();
    }

    return this.tokenData.access_token;
  }
}

NaN
FILE: src/outreach-client.js
SIZE: 14.3 KB | LINES: 500
MODIFIED: 2025-08-21T08:31:21.529Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

class OutreachClient {
  constructor() {
    this.clientId = process.env.OUTREACH_CLIENT_ID;
    this.clientSecret = process.env.OUTREACH_CLIENT_SECRET;
    this.redirectUri = process.env.OUTREACH_REDIRECT_URI || 'http:
    this.refreshToken = process.env.OUTREACH_REFRESH_TOKEN;
    this.baseURL = process.env.OUTREACH_API_BASE_URL || 'https:
    this.tokenURL = 'https:

    this.accessToken = null;
    this.tokenExpiry = null;

    this.client = axios.create({
      baseURL: this.baseURL,
      headers: {
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    this.client.interceptors.request.use(
      async (config) => {
        await this.ensureValidToken();
        config.headers['Authorization'] = `Bearer ${this.accessToken}`;
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        const originalRequest = error.config;

        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          await this.refreshAccessToken();
          originalRequest.headers['Authorization'] = `Bearer ${this.accessToken}`;
          return this.client(originalRequest);
        }

        return Promise.reject(error);
      }
    );
  }

  async ensureValidToken() {
    if (!this.accessToken || this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
  }

  isTokenExpired() {
    if (!this.tokenExpiry) return true;
    return Date.now() >= this.tokenExpiry;
  }

  async refreshAccessToken() {
    try {
      const params = new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken
      });

      const response = await axios.post(this.tokenURL, params, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      });

      this.accessToken = response.data.access_token;
      this.refreshToken = response.data.refresh_token || this.refreshToken;

      this.tokenExpiry = Date.now() + ((response.data.expires_in - 300) * 1000);

      if (response.data.refresh_token && response.data.refresh_token !== this.refreshToken) {
        console.error('New refresh token received:', response.data.refresh_token);
        console.error('Update your OUTREACH_REFRESH_TOKEN in .env file');
      }

      return this.accessToken;
    } catch (error) {
      throw new Error(`Failed to refresh access token: ${error.message}`);
    }
  }

  async createProspect(data) {
    try {
      const payload = {
        data: {
          type: 'prospect',
          attributes: {
            firstName: data.firstName,
            lastName: data.lastName,
            email: data.email,
            company: data.company,
            title: data.title,
            tags: data.tags || [],
            customFields: data.customFields || {}
          }
        }
      };

      const response = await this.client.post('/prospects', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create prospect: ${error.message}`);
    }
  }

  async searchProspects(criteria) {
    try {
      const params = new URLSearchParams();

      if (criteria.email) {
        params.append('filter[email]', criteria.email);
      }
      if (criteria.company) {
        params.append('filter[company]', criteria.company);
      }
      if (criteria.tags && criteria.tags.length > 0) {
        params.append('filter[tags]', criteria.tags.join(','));
      }
      if (criteria.limit) {
        params.append('page[limit]', criteria.limit);
      }

      const response = await this.client.get(`/prospects?${params.toString()}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to search prospects: ${error.message}`);
    }
  }

  async updateProspect(prospectId, updates) {
    try {
      const payload = {
        data: {
          type: 'prospect',
          id: prospectId,
          attributes: updates
        }
      };

      const response = await this.client.patch(`/prospects/${prospectId}`, payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to update prospect: ${error.message}`);
    }
  }

  async tagProspect(prospectId, tags) {
    try {

      const prospect = await this.client.get(`/prospects/${prospectId}`);
      const currentTags = prospect.data.data.attributes.tags || [];
      const newTags = [...new Set([...currentTags, ...tags])];

      return await this.updateProspect(prospectId, { tags: newTags });
    } catch (error) {
      throw new Error(`Failed to tag prospect: ${error.message}`);
    }
  }

  async getSequences(limit = 25) {
    try {
      const response = await this.client.get(`/sequences?page[limit]=${limit}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get sequences: ${error.message}`);
    }
  }

  async findSequence(name) {
    try {
      const response = await this.client.get(`/sequences?filter[name]=${encodeURIComponent(name)}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find sequence: ${error.message}`);
    }
  }

  async createSequence(sequenceData) {
    try {
      const payload = {
        data: {
          type: 'sequence',
          attributes: {
            name: sequenceData.name,
            description: sequenceData.description || '',
            tags: sequenceData.tags || [],
            shareType: sequenceData.shareType || 'shared'
          }
        }
      };

      const response = await this.client.post('/sequences', payload);

      const result = response.data;
      if (result.data && result.data.id) {
        result._uiLink = `https:
      }
      return result;
    } catch (error) {
      throw new Error(`Failed to create sequence: ${error.message}`);
    }
  }

  async createSequenceStep(stepData) {
    try {

      let order = stepData.order;
      if (!order) {
        const existingSteps = await this.getSequenceSteps(stepData.sequenceId);
        order = existingSteps.data ? existingSteps.data.length + 1 : 1;
      }

      const payload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: stepData.stepType === 'email' ? 'auto_email' : stepData.stepType || 'auto_email',
            order: order,
            interval: stepData.intervalInDays ? stepData.intervalInDays * 24 * 60 : 0,
            ...(stepData.taskNote && { taskNote: stepData.taskNote })
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: stepData.sequenceId
              }
            }
          }
        }
      };

      const response = await this.client.post('/sequenceSteps', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create sequence step: ${error.message}`);
    }
  }

  async getSequenceSteps(sequenceId) {
    try {
      const response = await this.client.get(`/sequenceSteps?filter[sequence][id]=${sequenceId}&sort=order`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get sequence steps: ${error.message}`);
    }
  }

  async createSequenceTemplate(templateData) {
    try {
      const payload = {
        data: {
          type: 'template',
          attributes: {
            name: templateData.name,
            subject: templateData.subject,
            ...(templateData.bodyHtml && { bodyHtml: templateData.bodyHtml }),
            ...(templateData.bodyText && { bodyText: templateData.bodyText }),
            ...(templateData.tags && { tags: templateData.tags }),
            shareType: templateData.shareType || 'shared',
            archived: false,
            trackLinks: templateData.trackLinks !== false,
            trackOpens: templateData.trackOpens !== false
          }
        }
      };

      const response = await this.client.post('/templates', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create template: ${error.message}`);
    }
  }

  async getSequenceTemplates(options = {}) {
    try {
      const params = new URLSearchParams();
      if (options.limit) params.append('page[limit]', options.limit);
      if (options.search) {
        params.append('filter[name]', `*${options.search}*`);
      }

      const response = await this.client.get(`/templates?${params.toString()}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get templates: ${error.message}`);
    }
  }

  async findSequenceTemplate(name) {
    try {
      const response = await this.client.get(`/templates?filter[name]=${encodeURIComponent(name)}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to find template: ${error.message}`);
    }
  }

  async updateSequenceTemplate(templateId, updates) {
    try {
      const payload = {
        data: {
          type: 'template',
          id: templateId,
          attributes: updates
        }
      };

      const response = await this.client.patch(`/templates/${templateId}`, payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to update template: ${error.message}`);
    }
  }

  async linkTemplateToStep(sequenceStepId, templateId) {
    try {

      const payload = {
        data: {
          type: 'sequenceTemplate',
          relationships: {
            sequenceStep: {
              data: {
                type: 'sequenceStep',
                id: sequenceStepId.toString()
              }
            },
            template: {
              data: {
                type: 'template',
                id: templateId.toString()
              }
            }
          }
        }
      };

      const response = await this.client.post('/sequenceTemplates', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to link template to step: ${error.message}`);
    }
  }

  async getSequenceTemplates() {
    try {
      const response = await this.client.get('/sequenceTemplates');
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get sequence templates: ${error.message}`);
    }
  }

  async unlinkTemplateFromStep(sequenceTemplateId) {
    try {
      const response = await this.client.delete(`/sequenceTemplates/${sequenceTemplateId}`);
      return { success: true };
    } catch (error) {
      throw new Error(`Failed to unlink template from step: ${error.message}`);
    }
  }

  async addProspectToSequence(prospectId, sequenceId, options = {}) {
    try {
      const payload = {
        data: {
          type: 'sequenceState',
          attributes: {
            state: 'active',
            ...options
          },
          relationships: {
            prospect: {
              data: {
                type: 'prospect',
                id: prospectId
              }
            },
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId
              }
            }
          }
        }
      };

      if (options.mailboxId) {
        payload.data.relationships.mailbox = {
          data: {
            type: 'mailbox',
            id: options.mailboxId
          }
        };
      }

      const response = await this.client.post('/sequenceStates', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to add prospect to sequence: ${error.message}`);
    }
  }

  async removeProspectFromSequence(sequenceStateId) {
    try {
      const payload = {
        data: {
          type: 'sequenceState',
          id: sequenceStateId,
          attributes: {
            state: 'finished'
          }
        }
      };

      const response = await this.client.patch(`/sequenceStates/${sequenceStateId}`, payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to remove prospect from sequence: ${error.message}`);
    }
  }

  async createAccount(data) {
    try {
      const payload = {
        data: {
          type: 'account',
          attributes: {
            name: data.name,
            domain: data.domain,
            industry: data.industry,
            size: data.size,
            customFields: data.customFields || {}
          }
        }
      };

      const response = await this.client.post('/accounts', payload);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to create account: ${error.message}`);
    }
  }

  async searchAccounts(criteria) {
    try {
      const params = new URLSearchParams();

      if (criteria.name) {
        params.append('filter[name]', criteria.name);
      }
      if (criteria.domain) {
        params.append('filter[domain]', criteria.domain);
      }

      const response = await this.client.get(`/accounts?${params.toString()}`);
      return response.data;
    } catch (error) {
      throw new Error(`Failed to search accounts: ${error.message}`);
    }
  }

  async getMailboxes() {
    try {
      const response = await this.client.get('/mailboxes');
      return response.data;
    } catch (error) {
      throw new Error(`Failed to get mailboxes: ${error.message}`);
    }
  }
}

export default OutreachClient;


NaN
FILE: src/outreach-client.ts
SIZE: 5.16 KB | LINES: 219
MODIFIED: 2025-08-28T22:52:23.616Z
NaN

import axios, { AxiosInstance } from 'axios';

export class OutreachClient {
  private client: AxiosInstance;

  constructor(apiToken: string, baseURL: string) {
    if (!apiToken) {
      throw new Error('OUTREACH_API_TOKEN environment variable is required');
    }

    this.client = axios.create({
      baseURL,
      headers: {
        'Authorization': `Bearer ${apiToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json',
      },
    });
  }

  async createSequence(
    name: string,
    description?: string,
    enabled: boolean = true,
    shareType: string = 'private'
  ) {
    const payload = {
      data: {
        type: 'sequence',
        attributes: {
          name,
          description: description || '',
          enabled,
          shareType,
          sequenceType: 'outbound',
        },
      },
    };

    try {
      const response = await this.client.post('/sequences', payload);
      return response.data;
    } catch (error: any) {
      if (error.response) {
        throw new Error(`Failed to create sequence: ${error.response.status} - ${JSON.stringify(error.response.data)}`);
      }
      throw error;
    }
  }

  async listSequences(limit: number = 50, offset: number = 0) {
    const response = await this.client.get('/sequences', {
      params: {
        'page[limit]': limit,
        'page[offset]': offset,
        'sort': '-createdAt',
      },
    });
    return response.data;
  }

  async getAccountProspects(
    accountId?: number,
    accountName?: string,
    limit: number = 100
  ) {
    let filter: any = {};

    if (accountId) {
      filter['account[id]'] = accountId;
    } else if (accountName) {
      const accounts = await this.searchAccounts(accountName, 1);
      if (accounts.data && accounts.data.length > 0) {
        filter['account[id]'] = accounts.data[0].id;
      } else {
        throw new Error(`Account not found: ${accountName}`);
      }
    } else {
      throw new Error('Either accountId or accountName must be provided');
    }

    const response = await this.client.get('/prospects', {
      params: {
        ...filter,
        'page[limit]': limit,
        'include': 'account',
      },
    });
    return response.data;
  }

  async searchAccounts(query: string, limit: number = 20) {
    const response = await this.client.get('/accounts', {
      params: {
        'filter[name]': query,
        'page[limit]': limit,
      },
    });

    if (!response.data.data || response.data.data.length === 0) {
      const domainResponse = await this.client.get('/accounts', {
        params: {
          'filter[domain]': query,
          'page[limit]': limit,
        },
      });
      return domainResponse.data;
    }

    return response.data;
  }

  async addProspectsToSequence(
    sequenceId: number,
    prospectIds: number[],
    mailboxId?: number
  ) {
    const sequenceStates = await Promise.all(
      prospectIds.map(async (prospectId) => {
        const payload: any = {
          data: {
            type: 'sequenceState',
            relationships: {
              sequence: {
                data: {
                  type: 'sequence',
                  id: sequenceId.toString(),
                },
              },
              prospect: {
                data: {
                  type: 'prospect',
                  id: prospectId.toString(),
                },
              },
            },
          },
        };

        if (mailboxId) {
          payload.data.relationships.mailbox = {
            data: {
              type: 'mailbox',
              id: mailboxId.toString(),
            },
          };
        }

        try {
          const response = await this.client.post('/sequenceStates', payload);
          return { success: true, prospectId, data: response.data };
        } catch (error: any) {
          return {
            success: false,
            prospectId,
            error: error.response?.data || error.message
          };
        }
      })
    );

    return {
      results: sequenceStates,
      summary: {
        total: prospectIds.length,
        successful: sequenceStates.filter(s => s.success).length,
        failed: sequenceStates.filter(s => !s.success).length,
      },
    };
  }

  async createSequenceStep(
    sequenceId: number,
    order: number,
    interval: number = 1,
    stepType: string,
    subject?: string,
    body?: string
  ) {
    const payload: any = {
      data: {
        type: 'sequenceStep',
        attributes: {
          order,
          interval,
          stepType,
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString(),
            },
          },
        },
      },
    };

    if (stepType.includes('email') && subject) {
      payload.data.attributes.subject = subject;
    }

    if (body) {
      payload.data.attributes.body = body;
    }

    const response = await this.client.post('/sequenceSteps', payload);
    return response.data;
  }

  async getMailboxes() {
    const response = await this.client.get('/mailboxes', {
      params: {
        'page[limit]': 100,
      },
    });
    return response.data;
  }
}

NaN
FILE: src/performance/bulk-operations.js
SIZE: 8.98 KB | LINES: 277
MODIFIED: 2025-08-28T11:39:33.276Z
NaN

import { setTimeout as delay } from 'timers/promises';

class BulkOperationsManager {
  constructor(outreachClient, config = {}) {
    this.client = outreachClient;
    this.batchSize = config.batchSize || 25;
    this.maxRetries = config.maxRetries || 3;
    this.retryDelay = config.retryDelay || 1000;
    this.parallelLimit = config.parallelLimit || 5;

    this.stats = {
      totalOperations: 0,
      successfulOperations: 0,
      failedOperations: 0,
      retriedOperations: 0
    };
  }

  async bulkCreateProspects(prospectsData, options = {}) {
    console.error(`ðŸ“¦ Starting bulk prospect creation: ${prospectsData.length} prospects`);

    const results = {
      successful: [],
      failed: [],
      summary: {
        total: prospectsData.length,
        succeeded: 0,
        failed: 0,
        batchesProcessed: 0
      }
    };

    const batches = this.createBatches(prospectsData, this.batchSize);
    console.error(`ðŸ”„ Processing ${batches.length} batches of ${this.batchSize} prospects each`);

    for (let i = 0; i < batches.length; i += this.parallelLimit) {
      const batchGroup = batches.slice(i, i + this.parallelLimit);
      const batchPromises = batchGroup.map((batch, index) =>
        this.processBatch(batch, i + index, 'prospects')
      );

      const batchResults = await Promise.allSettled(batchPromises);

      batchResults.forEach(result => {
        if (result.status === 'fulfilled') {
          results.successful.push(...result.value.successful);
          results.failed.push(...result.value.failed);
          results.summary.batchesProcessed++;
        } else {
          console.error(`âŒ Batch processing failed: ${result.reason}`);
          results.failed.push({ error: result.reason, batch: true });
        }
      });

      if (i + this.parallelLimit < batches.length) {
        await delay(500);
      }
    }

    results.summary.succeeded = results.successful.length;
    results.summary.failed = results.failed.length;

    console.error(`âœ… Bulk prospect creation complete: ${results.summary.succeeded}/${results.summary.total} successful`);
    return results;
  }

  async processBatch(batch, batchIndex, operationType, attempt = 1) {
    const results = { successful: [], failed: [] };

    try {
      console.error(`âš¡ Processing batch ${batchIndex + 1}: ${batch.length} items (attempt ${attempt})`);

      for (const item of batch) {
        try {
          let result;

          switch (operationType) {
            case 'prospects':
              result = await this.client.createProspect(item);
              break;
            case 'sequences':
              result = await this.client.createSequence(item);
              break;
            case 'templates':
              result = await this.client.createSequenceTemplate(item);
              break;
            default:
              throw new Error(`Unknown operation type: ${operationType}`);
          }

          results.successful.push({
            input: item,
            result: result,
            batchIndex: batchIndex
          });

          this.stats.successfulOperations++;

          await delay(100);

        } catch (error) {
          console.error(`âŒ Individual operation failed: ${error.message}`);
          results.failed.push({
            input: item,
            error: error.message,
            batchIndex: batchIndex
          });
          this.stats.failedOperations++;
        }
      }

      this.stats.totalOperations += batch.length;
      return results;

    } catch (error) {
      console.error(`âŒ Batch ${batchIndex + 1} failed: ${error.message}`);

      if (attempt < this.maxRetries) {
        console.error(`ðŸ”„ Retrying batch ${batchIndex + 1} in ${this.retryDelay}ms (attempt ${attempt + 1})`);
        this.stats.retriedOperations++;

        await delay(this.retryDelay * attempt);
        return this.processBatch(batch, batchIndex, operationType, attempt + 1);
      }

      batch.forEach(item => {
        results.failed.push({
          input: item,
          error: `Batch failed after ${this.maxRetries} attempts: ${error.message}`,
          batchIndex: batchIndex
        });
      });

      this.stats.failedOperations += batch.length;
      return results;
    }
  }

  async bulkCreateSequences(sequencesData, options = {}) {
    console.error(`ðŸ“¦ Starting bulk sequence creation: ${sequencesData.length} sequences`);

    const batches = this.createBatches(sequencesData, Math.min(this.batchSize, 10));
    const results = { successful: [], failed: [], summary: { total: sequencesData.length, succeeded: 0, failed: 0 } };

    for (let i = 0; i < batches.length; i++) {
      const batchResult = await this.processBatch(batches[i], i, 'sequences');
      results.successful.push(...batchResult.successful);
      results.failed.push(...batchResult.failed);

      await delay(1000);
    }

    results.summary.succeeded = results.successful.length;
    results.summary.failed = results.failed.length;

    console.error(`âœ… Bulk sequence creation complete: ${results.summary.succeeded}/${results.summary.total} successful`);
    return results;
  }

  async bulkCreateTemplates(templatesData, options = {}) {
    console.error(`ðŸ“¦ Starting bulk template creation: ${templatesData.length} templates`);

    const batches = this.createBatches(templatesData, Math.min(this.batchSize, 15));
    const results = { successful: [], failed: [], summary: { total: templatesData.length, succeeded: 0, failed: 0 } };

    for (let i = 0; i < batches.length; i++) {
      const batchResult = await this.processBatch(batches[i], i, 'templates');
      results.successful.push(...batchResult.successful);
      results.failed.push(...batchResult.failed);

      await delay(500);
    }

    results.summary.succeeded = results.successful.length;
    results.summary.failed = results.failed.length;

    console.error(`âœ… Bulk template creation complete: ${results.summary.succeeded}/${results.summary.total} successful`);
    return results;
  }

  async bulkEnrollProspects(enrollmentData, options = {}) {
    console.error(`ðŸ“¦ Starting bulk prospect enrollment: ${enrollmentData.length} enrollments`);

    const results = { successful: [], failed: [], summary: { total: enrollmentData.length, succeeded: 0, failed: 0 } };

    const batches = this.createBatches(enrollmentData, Math.min(this.batchSize, 20));

    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];

      try {
        for (const enrollment of batch) {
          try {
            const result = await this.client.addProspectToSequence(
              enrollment.prospectId,
              enrollment.sequenceId,
              enrollment.options || {}
            );

            results.successful.push({
              input: enrollment,
              result: result
            });

            await delay(200);

          } catch (error) {
            results.failed.push({
              input: enrollment,
              error: error.message
            });
          }
        }

      } catch (batchError) {
        console.error(`âŒ Enrollment batch ${i + 1} failed: ${batchError.message}`);
      }

      await delay(1000);
    }

    results.summary.succeeded = results.successful.length;
    results.summary.failed = results.failed.length;

    console.error(`âœ… Bulk enrollment complete: ${results.summary.succeeded}/${results.summary.total} successful`);
    return results;
  }

  createBatches(array, batchSize) {
    const batches = [];
    for (let i = 0; i < array.length; i += batchSize) {
      batches.push(array.slice(i, i + batchSize));
    }
    return batches;
  }

  getStats() {
    const successRate = this.stats.totalOperations > 0
      ? ((this.stats.successfulOperations / this.stats.totalOperations) * 100).toFixed(2)
      : 0;

    return {
      ...this.stats,
      successRate: `${successRate}%`
    };
  }

  getHealth() {
    const stats = this.getStats();
    return {
      status: 'healthy',
      batchSize: this.batchSize,
      parallelLimit: this.parallelLimit,
      successRate: stats.successRate,
      totalOperations: stats.totalOperations
    };
  }
}

export default BulkOperationsManager;

NaN
FILE: src/performance/cache-manager.js
SIZE: 5.51 KB | LINES: 211
MODIFIED: 2025-08-28T11:39:33.274Z
NaN

import NodeCache from 'node-cache';

class CacheManager {
  constructor(config = {}) {

    this.ttl = {
      oauth_token: config.oauthTtl || 3300,
      api_response: config.apiTtl || 300,
      prospect_data: config.prospectTtl || 1800,
      sequence_data: config.sequenceTtl || 3600,
      short_term: config.shortTtl || 60
    };

    this.oauthCache = new NodeCache({
      stdTTL: this.ttl.oauth_token,
      checkperiod: 60,
      useClones: false
    });

    this.apiCache = new NodeCache({
      stdTTL: this.ttl.api_response,
      checkperiod: 30,
      useClones: false
    });

    this.dataCache = new NodeCache({
      stdTTL: this.ttl.sequence_data,
      checkperiod: 120,
      useClones: false
    });

    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0
    };

    this.setupEventListeners();
  }

  setupEventListeners() {
    [this.oauthCache, this.apiCache, this.dataCache].forEach(cache => {
      cache.on('expired', (key, value) => {
        console.error(`ðŸ—‘ï¸ Cache expired: ${key}`);
      });

      cache.on('del', (key, value) => {
        this.stats.deletes++;
      });

      cache.on('set', (key, value) => {
        this.stats.sets++;
      });
    });
  }

  setOAuthToken(key, tokenData) {
    const cacheKey = `oauth:${key}`;
    this.oauthCache.set(cacheKey, tokenData, this.ttl.oauth_token);
    console.error(`ðŸ” OAuth token cached: ${key}`);
  }

  getOAuthToken(key) {
    const cacheKey = `oauth:${key}`;
    const token = this.oauthCache.get(cacheKey);
    if (token) {
      this.stats.hits++;
      console.error(`âœ… OAuth token cache hit: ${key}`);
      return token;
    }
    this.stats.misses++;
    console.error(`âŒ OAuth token cache miss: ${key}`);
    return null;
  }

  setApiResponse(endpoint, params, data) {
    const cacheKey = this.generateApiKey(endpoint, params);
    this.apiCache.set(cacheKey, data, this.ttl.api_response);
    console.error(`ðŸ’¾ API response cached: ${endpoint}`);
  }

  getApiResponse(endpoint, params) {
    const cacheKey = this.generateApiKey(endpoint, params);
    const data = this.apiCache.get(cacheKey);
    if (data) {
      this.stats.hits++;
      console.error(`âœ… API cache hit: ${endpoint}`);
      return data;
    }
    this.stats.misses++;
    return null;
  }

  setProspectData(prospectId, data) {
    const cacheKey = `prospect:${prospectId}`;
    this.dataCache.set(cacheKey, data, this.ttl.prospect_data);
  }

  getProspectData(prospectId) {
    const cacheKey = `prospect:${prospectId}`;
    const data = this.dataCache.get(cacheKey);
    if (data) {
      this.stats.hits++;
      return data;
    }
    this.stats.misses++;
    return null;
  }

  setSequenceData(sequenceId, data) {
    const cacheKey = `sequence:${sequenceId}`;
    this.dataCache.set(cacheKey, data, this.ttl.sequence_data);
  }

  getSequenceData(sequenceId) {
    const cacheKey = `sequence:${sequenceId}`;
    const data = this.dataCache.get(cacheKey);
    if (data) {
      this.stats.hits++;
      return data;
    }
    this.stats.misses++;
    return null;
  }

  setTemplateData(templateId, data) {
    const cacheKey = `template:${templateId}`;
    this.dataCache.set(cacheKey, data, this.ttl.sequence_data);
  }

  getTemplateData(templateId) {
    const cacheKey = `template:${templateId}`;
    const data = this.dataCache.get(cacheKey);
    if (data) {
      this.stats.hits++;
      return data;
    }
    this.stats.misses++;
    return null;
  }

  generateApiKey(endpoint, params) {
    const sortedParams = params ? JSON.stringify(params, Object.keys(params).sort()) : '';
    return `api:${endpoint}:${Buffer.from(sortedParams).toString('base64')}`;
  }

  invalidateApiCache() {
    this.apiCache.flushAll();
    console.error('ðŸ—‘ï¸ API cache invalidated');
  }

  invalidateProspectCache(prospectId = null) {
    if (prospectId) {
      this.dataCache.del(`prospect:${prospectId}`);
    } else {

      const keys = this.dataCache.keys().filter(key => key.startsWith('prospect:'));
      this.dataCache.del(keys);
    }
  }

  getStats() {
    const hitRate = this.stats.hits + this.stats.misses > 0
      ? (this.stats.hits / (this.stats.hits + this.stats.misses) * 100).toFixed(2)
      : 0;

    return {
      ...this.stats,
      hitRate: `${hitRate}%`,
      oauthCacheKeys: this.oauthCache.keys().length,
      apiCacheKeys: this.apiCache.keys().length,
      dataCacheKeys: this.dataCache.keys().length
    };
  }

  getHealth() {
    const stats = this.getStats();
    return {
      status: 'healthy',
      hitRate: stats.hitRate,
      totalKeys: stats.oauthCacheKeys + stats.apiCacheKeys + stats.dataCacheKeys,
      cacheTypes: {
        oauth: stats.oauthCacheKeys,
        api: stats.apiCacheKeys,
        data: stats.dataCacheKeys
      }
    };
  }

  close() {
    this.oauthCache.close();
    this.apiCache.close();
    this.dataCache.close();
    console.error('âœ… Cache manager closed');
  }
}

export default CacheManager;

NaN
FILE: src/performance/connection-pool.js
SIZE: 2.01 KB | LINES: 79
MODIFIED: 2025-08-28T11:39:33.278Z
NaN

import axios from 'axios';
import pkg from 'agentkeepalive';
const { HttpsAgent } = pkg;

class ConnectionPoolManager {
  constructor(config = {}) {
    this.maxSockets = config.maxSockets || 15;
    this.maxFreeSockets = config.maxFreeSockets || 10;
    this.timeout = config.timeout || 30000;
    this.keepAliveTimeout = config.keepAliveTimeout || 30000;

    this.httpAgent = new HttpsAgent({
      maxSockets: this.maxSockets,
      maxFreeSockets: this.maxFreeSockets,
      timeout: this.timeout,
      freeSocketTimeout: this.keepAliveTimeout,
      keepAlive: true
    });

    this.client = axios.create({
      httpAgent: this.httpAgent,
      timeout: this.timeout,
      headers: {
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    this.stats = {
      totalRequests: 0,
      activeConnections: 0,
      poolHits: 0,
      poolMisses: 0
    };
  }

  getClient() {
    return this.client;
  }

  getStats() {
    return {
      ...this.stats,
      activeConnections: this.httpAgent.getCurrentStatus?.()?.createSocketCount || 0,
      freeConnections: this.httpAgent.getCurrentStatus?.()?.freeSocketCount || 0
    };
  }

  incrementStats() {
    this.stats.totalRequests++;
  }

  async shutdown() {
    console.error('ðŸ”Œ Shutting down connection pool...');
    this.httpAgent.destroy();
    console.error('âœ… Connection pool shutdown complete');
  }

  getHealth() {
    const stats = this.getStats();
    return {
      status: 'healthy',
      totalRequests: stats.totalRequests,
      activeConnections: stats.activeConnections,
      freeConnections: stats.freeConnections,
      maxSockets: this.maxSockets
    };
  }
}

export default ConnectionPoolManager;

NaN
FILE: src/performance/enhanced-oauth.js
SIZE: 6.91 KB | LINES: 234
MODIFIED: 2025-08-28T11:39:33.273Z
NaN

import { setTimeout as delay } from 'timers/promises';

class EnhancedOAuthManager {
  constructor(clientId, clientSecret, redirectUri, initialRefreshToken, cacheManager) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUri = redirectUri;
    this.refreshToken = initialRefreshToken;
    this.cacheManager = cacheManager;

    this.tokenURL = 'https:
    this.accessToken = null;
    this.tokenExpiry = null;

    this.bufferTime = 10 * 60 * 1000;
    this.maxRetries = 3;
    this.retryDelay = 1000;

    this.stats = {
      tokenRefreshes: 0,
      proactiveRefreshes: 0,
      failedRefreshes: 0,
      cacheHits: 0,
      cacheMisses: 0
    };

    this.startProactiveRefresh();
  }

  startProactiveRefresh() {

    this.refreshInterval = setInterval(() => {
      this.checkAndRefreshToken();
    }, 5 * 60 * 1000);

    console.error('ðŸ”„ Proactive OAuth token refresh monitoring started');
  }

  async checkAndRefreshToken() {
    try {
      if (this.needsRefresh()) {
        console.error('ðŸ”„ Proactive token refresh triggered');
        await this.refreshAccessToken();
        this.stats.proactiveRefreshes++;
      }
    } catch (error) {
      console.error('âŒ Proactive token refresh failed:', error.message);
    }
  }

  needsRefresh() {
    if (!this.accessToken || !this.tokenExpiry) {
      return true;
    }

    const timeUntilExpiry = this.tokenExpiry - Date.now();
    return timeUntilExpiry <= this.bufferTime;
  }

  async refreshAccessToken(attempt = 1) {
    try {
      console.error(`ðŸ”‘ Refreshing OAuth token (attempt ${attempt})...`);

      const cachedToken = this.cacheManager?.getOAuthToken('access_token');
      if (cachedToken && !this.isTokenExpired(cachedToken)) {
        console.error('âœ… Using cached access token');
        this.accessToken = cachedToken.access_token;
        this.tokenExpiry = cachedToken.expiry;
        this.stats.cacheHits++;
        return this.accessToken;
      }

      this.stats.cacheMisses++;

      const params = new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken
      });

      const response = await fetch(this.tokenURL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'User-Agent': 'MCP-Outreach-Server/1.0'
        },
        body: params
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      const tokenData = await response.json();

      this.accessToken = tokenData.access_token;
      this.refreshToken = tokenData.refresh_token || this.refreshToken;

      const expiresIn = tokenData.expires_in || 3600;
      this.tokenExpiry = Date.now() + ((expiresIn - 300) * 1000);

      if (this.cacheManager) {
        this.cacheManager.setOAuthToken('access_token', {
          access_token: this.accessToken,
          refresh_token: this.refreshToken,
          expiry: this.tokenExpiry
        });
      }

      this.stats.tokenRefreshes++;
      console.error(`âœ… OAuth token refreshed successfully (expires in ${Math.round((this.tokenExpiry - Date.now()) / 1000 / 60)} minutes)`);

      if (tokenData.refresh_token && tokenData.refresh_token !== this.refreshToken) {
        console.error('ðŸ”„ New refresh token received - update your .env file');
        console.error(`OUTREACH_REFRESH_TOKEN=${tokenData.refresh_token}`);
      }

      return this.accessToken;

    } catch (error) {
      console.error(`âŒ OAuth token refresh failed (attempt ${attempt}):`, error.message);
      this.stats.failedRefreshes++;

      if (attempt < this.maxRetries) {
        const delayMs = this.retryDelay * Math.pow(2, attempt - 1);
        console.error(`ðŸ”„ Retrying token refresh in ${delayMs}ms...`);

        await delay(delayMs);
        return this.refreshAccessToken(attempt + 1);
      }

      throw new Error(`OAuth token refresh failed after ${this.maxRetries} attempts: ${error.message}`);
    }
  }

  async ensureValidToken() {
    if (!this.accessToken || this.needsRefresh()) {
      await this.refreshAccessToken();
    }
    return this.accessToken;
  }

  async getAccessToken() {
    return await this.ensureValidToken();
  }

  isTokenExpired(token = null) {
    if (token && token.expiry) {
      return Date.now() >= token.expiry;
    }

    if (!this.tokenExpiry) return true;
    return Date.now() >= this.tokenExpiry;
  }

  getTokenStatus() {
    if (!this.accessToken || !this.tokenExpiry) {
      return {
        status: 'invalid',
        hasToken: false,
        expiresIn: 0,
        needsRefresh: true
      };
    }

    const expiresIn = Math.max(0, this.tokenExpiry - Date.now());
    const expiresInMinutes = Math.round(expiresIn / 1000 / 60);

    return {
      status: this.isTokenExpired() ? 'expired' : 'valid',
      hasToken: true,
      expiresIn: expiresIn,
      expiresInMinutes: expiresInMinutes,
      needsRefresh: this.needsRefresh()
    };
  }

  getStats() {
    return {
      ...this.stats,
      tokenStatus: this.getTokenStatus(),
      cacheHitRate: this.stats.cacheHits + this.stats.cacheMisses > 0
        ? `${((this.stats.cacheHits / (this.stats.cacheHits + this.stats.cacheMisses)) * 100).toFixed(2)}%`
        : '0%'
    };
  }

  getHealth() {
    const status = this.getTokenStatus();
    const stats = this.getStats();

    return {
      status: status.status === 'valid' ? 'healthy' : 'warning',
      tokenStatus: status.status,
      expiresInMinutes: status.expiresInMinutes,
      totalRefreshes: stats.tokenRefreshes,
      proactiveRefreshes: stats.proactiveRefreshes,
      cacheHitRate: stats.cacheHitRate
    };
  }

  destroy() {
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }
    console.error('ðŸ”„ OAuth manager cleanup complete');
  }
}

export default EnhancedOAuthManager;

NaN
FILE: src/performance/performance-monitor.js
SIZE: 7.37 KB | LINES: 268
MODIFIED: 2025-08-28T11:39:33.271Z
NaN

class PerformanceMonitor {
  constructor() {
    this.metrics = {
      requests: {
        total: 0,
        successful: 0,
        failed: 0,
        avgResponseTime: 0,
        responseTimes: []
      },
      tools: {},
      system: {
        startTime: Date.now(),
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage()
      }
    };

    this.startSystemMonitoring();
  }

  startSystemMonitoring() {
    this.systemInterval = setInterval(() => {
      this.updateSystemMetrics();
    }, 30000);

    console.error('ðŸ“Š Performance monitoring started');
  }

  updateSystemMetrics() {
    this.metrics.system.memoryUsage = process.memoryUsage();
    this.metrics.system.cpuUsage = process.cpuUsage(this.metrics.system.cpuUsage);
  }

  recordRequest(toolName, responseTime, success = true) {

    this.metrics.requests.total++;
    if (success) {
      this.metrics.requests.successful++;
    } else {
      this.metrics.requests.failed++;
    }

    this.metrics.requests.responseTimes.push(responseTime);
    if (this.metrics.requests.responseTimes.length > 100) {
      this.metrics.requests.responseTimes.shift();
    }

    const sum = this.metrics.requests.responseTimes.reduce((a, b) => a + b, 0);
    this.metrics.requests.avgResponseTime = Math.round(sum / this.metrics.requests.responseTimes.length);

    if (!this.metrics.tools[toolName]) {
      this.metrics.tools[toolName] = {
        total: 0,
        successful: 0,
        failed: 0,
        avgResponseTime: 0,
        responseTimes: []
      };
    }

    const toolMetrics = this.metrics.tools[toolName];
    toolMetrics.total++;
    if (success) {
      toolMetrics.successful++;
    } else {
      toolMetrics.failed++;
    }

    toolMetrics.responseTimes.push(responseTime);
    if (toolMetrics.responseTimes.length > 50) {
      toolMetrics.responseTimes.shift();
    }

    const toolSum = toolMetrics.responseTimes.reduce((a, b) => a + b, 0);
    toolMetrics.avgResponseTime = Math.round(toolSum / toolMetrics.responseTimes.length);
  }

  getMetrics() {
    const uptime = Date.now() - this.metrics.system.startTime;
    const successRate = this.metrics.requests.total > 0
      ? ((this.metrics.requests.successful / this.metrics.requests.total) * 100).toFixed(2)
      : 0;

    return {
      uptime: {
        milliseconds: uptime,
        seconds: Math.round(uptime / 1000),
        minutes: Math.round(uptime / 1000 / 60),
        hours: Math.round(uptime / 1000 / 60 / 60)
      },
      requests: {
        ...this.metrics.requests,
        successRate: `${successRate}%`,
        requestsPerMinute: this.calculateRequestsPerMinute(),
        responseTimes: undefined
      },
      tools: this.getToolMetricsSummary(),
      system: {
        ...this.metrics.system,
        memoryUsageFormatted: this.formatMemoryUsage(this.metrics.system.memoryUsage)
      }
    };
  }

  calculateRequestsPerMinute() {
    const uptimeMinutes = (Date.now() - this.metrics.system.startTime) / 1000 / 60;
    return uptimeMinutes > 0 ? Math.round(this.metrics.requests.total / uptimeMinutes) : 0;
  }

  getToolMetricsSummary() {
    const summary = {};
    Object.keys(this.metrics.tools).forEach(toolName => {
      const tool = this.metrics.tools[toolName];
      const successRate = tool.total > 0
        ? ((tool.successful / tool.total) * 100).toFixed(2)
        : 0;

      summary[toolName] = {
        total: tool.total,
        successful: tool.successful,
        failed: tool.failed,
        successRate: `${successRate}%`,
        avgResponseTime: `${tool.avgResponseTime}ms`
      };
    });
    return summary;
  }

  formatMemoryUsage(memUsage) {
    return {
      rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
      external: `${Math.round(memUsage.external / 1024 / 1024)}MB`
    };
  }

  getAlerts() {
    const alerts = [];
    const metrics = this.getMetrics();

    if (metrics.requests.avgResponseTime > 2000) {
      alerts.push({
        type: 'warning',
        message: `High average response time: ${metrics.requests.avgResponseTime}ms`,
        threshold: 2000,
        current: metrics.requests.avgResponseTime
      });
    }

    const errorRate = (metrics.requests.failed / metrics.requests.total) * 100;
    if (errorRate > 5) {
      alerts.push({
        type: 'error',
        message: `High error rate: ${errorRate.toFixed(2)}%`,
        threshold: 5,
        current: errorRate
      });
    }

    const heapUsedMB = metrics.system.memoryUsage.heapUsed / 1024 / 1024;
    if (heapUsedMB > 500) {
      alerts.push({
        type: 'warning',
        message: `High memory usage: ${Math.round(heapUsedMB)}MB`,
        threshold: 500,
        current: Math.round(heapUsedMB)
      });
    }

    return alerts;
  }

  getHealth() {
    const alerts = this.getAlerts();
    const metrics = this.getMetrics();

    let status = 'healthy';
    if (alerts.some(alert => alert.type === 'error')) {
      status = 'unhealthy';
    } else if (alerts.length > 0) {
      status = 'warning';
    }

    return {
      status: status,
      uptime: metrics.uptime,
      performance: {
        avgResponseTime: `${metrics.requests.avgResponseTime}ms`,
        successRate: metrics.requests.successRate,
        requestsPerMinute: metrics.requests.requestsPerMinute
      },
      alerts: alerts.length,
      alertDetails: alerts
    };
  }

  generateReport() {
    const metrics = this.getMetrics();
    const health = this.getHealth();
    const timestamp = new Date().toISOString();

    return {
      timestamp: timestamp,
      health: health,
      metrics: metrics,
      summary: {
        totalRequests: metrics.requests.total,
        successRate: metrics.requests.successRate,
        avgResponseTime: `${metrics.requests.avgResponseTime}ms`,
        uptime: `${metrics.uptime.hours}h ${metrics.uptime.minutes % 60}m`,
        toolCount: Object.keys(metrics.tools).length,
        memoryUsage: metrics.system.memoryUsageFormatted.heapUsed
      }
    };
  }

  reset() {
    this.metrics = {
      requests: {
        total: 0,
        successful: 0,
        failed: 0,
        avgResponseTime: 0,
        responseTimes: []
      },
      tools: {},
      system: {
        startTime: Date.now(),
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage()
      }
    };
    console.error('ðŸ“Š Performance metrics reset');
  }

  destroy() {
    if (this.systemInterval) {
      clearInterval(this.systemInterval);
      this.systemInterval = null;
    }
    console.error('ðŸ“Š Performance monitor cleanup complete');
  }
}

export default PerformanceMonitor;

NaN
FILE: src/setup-oauth.js
SIZE: 8.88 KB | LINES: 275
MODIFIED: 2025-08-28T17:21:18.346Z
NaN

import express from 'express';
import axios from 'axios';
import open from 'open';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import fs from 'fs';
import readline from 'readline';

dotenv.config();

const app = express();
const PORT = 3000;

const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = process.env.OUTREACH_CLIENT_SECRET;
const REDIRECT_URI = process.env.OUTREACH_REDIRECT_URI || `http:

if (!CLIENT_ID || !CLIENT_SECRET) {
  console.error('âŒ Missing OUTREACH_CLIENT_ID or OUTREACH_CLIENT_SECRET in .env file');
  process.exit(1);
}

const AUTH_URL = 'https:
const TOKEN_URL = 'https:

const SCOPES = [
  'accounts.read',
  'accounts.write',
  'prospects.read',
  'prospects.write',
  'sequences.read',
  'sequences.write',
  'sequenceSteps.read',
  'sequenceSteps.write',
  'sequenceTemplates.read',
  'sequenceTemplates.write',
  'templates.read',
  'templates.write',
  'mailboxes.read',
  'users.read'
].join(' ');

let server;

app.get('/', (req, res) => {
  const authUrl = `${AUTH_URL}?` + new URLSearchParams({
    client_id: CLIENT_ID,
    redirect_uri: REDIRECT_URI,
    response_type: 'code',
    scope: SCOPES
  });

  res.send(`
    <html>
      <body style="font-family: system-ui; padding: 40px; max-width: 600px; margin: 0 auto;">
        <h1>Outreach OAuth Setup</h1>
        <p>Click the button below to authorize the MCP server with Outreach:</p>
        <a href="${authUrl}" style="display: inline-block; padding: 12px 24px; background: #4F46E5; color: white; text-decoration: none; border-radius: 6px;">
          Authorize with Outreach
        </a>
        <p><small>You will be redirected to: ${REDIRECT_URI}</small></p>
      </body>
    </html>
  `);
});

app.get('/auth', (req, res) => {
  const authUrl = `${AUTH_URL}?` + new URLSearchParams({
    client_id: CLIENT_ID,
    redirect_uri: REDIRECT_URI,
    response_type: 'code',
    scope: SCOPES
  });

  res.redirect(authUrl);
});

app.get('/callback', async (req, res) => {
  const { code, error } = req.query;

  if (error) {
    res.send(`
      <html>
        <body style="font-family: system-ui; padding: 40px;">
          <h1 style="color: red;">âŒ Authorization Failed</h1>
          <p>Error: ${error}</p>
        </body>
      </html>
    `);
    return;
  }

  try {

    const params = new URLSearchParams({
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URI,
      grant_type: 'authorization_code',
      code: code
    });

    const response = await axios.post(TOKEN_URL, params, {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    });

    const { access_token, refresh_token, expires_in } = response.data;

    const __dirname = dirname(fileURLToPath(import.meta.url));
    const envPath = join(__dirname, '..', '.env');
    let envContent = fs.readFileSync(envPath, 'utf8');

    if (envContent.includes('OUTREACH_REFRESH_TOKEN=')) {
      envContent = envContent.replace(
        /OUTREACH_REFRESH_TOKEN=.*/,
        `OUTREACH_REFRESH_TOKEN=${refresh_token}`
      );
    } else {
      envContent += `\nOUTREACH_REFRESH_TOKEN=${refresh_token}\n`;
    }

    fs.writeFileSync(envPath, envContent);

    res.send(`
      <html>
        <body style="font-family: system-ui; padding: 40px; max-width: 600px; margin: 0 auto;">
          <h1 style="color: green;">âœ… Authorization Successful!</h1>
          <p>Your refresh token has been saved to the .env file.</p>
          <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>Token Information:</h3>
            <p><strong>Access Token:</strong> ${access_token.substring(0, 20)}...</p>
            <p><strong>Refresh Token:</strong> ${refresh_token.substring(0, 20)}...</p>
            <p><strong>Expires In:</strong> ${expires_in} seconds</p>
          </div>
          <div style="background: #FEF3C7; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3>âš ï¸ Important:</h3>
            <p>Your refresh token has been saved. Keep this token secure!</p>
            <p>The MCP server will use this token to authenticate with Outreach.</p>
          </div>
          <p>You can now close this window and start using the MCP server.</p>
          <button onclick="window.close()" style="padding: 12px 24px; background: #4F46E5; color: white; border: none; border-radius: 6px; cursor: pointer;">
            Close Window
          </button>
        </body>
      </html>
    `);

    console.log('\nâœ… OAuth setup complete!');
    console.log('ðŸ“ Refresh token saved to .env file');
    console.log('\nYou can now run: npm start\n');

    setTimeout(() => {
      server.close();
      process.exit(0);
    }, 5000);

  } catch (error) {
    console.error('Error exchanging code for token:', error.response?.data || error.message);
    res.send(`
      <html>
        <body style="font-family: system-ui; padding: 40px;">
          <h1 style="color: red;">âŒ Token Exchange Failed</h1>
          <p>Error: ${error.message}</p>
          <pre>${JSON.stringify(error.response?.data, null, 2)}</pre>
        </body>
      </html>
    `);
  }
});

server = app.listen(PORT, () => {
  const isLocalRedirect = REDIRECT_URI.includes('localhost');

  if (isLocalRedirect) {
    console.log(`\nðŸš€ OAuth Setup Server running at http:
    console.log('\nðŸ“‹ Steps to complete OAuth setup:');
    console.log('1. Opening browser to http:
    console.log('2. Click "Authorize with Outreach"');
    console.log('3. Log in to your Outreach account');
    console.log('4. Approve the permissions');
    console.log('5. The refresh token will be saved automatically\n');

    open(`http:
  } else {

    const authUrl = `${AUTH_URL}?` + new URLSearchParams({
      client_id: CLIENT_ID,
      redirect_uri: REDIRECT_URI,
      response_type: 'code',
      scope: SCOPES
    });

    console.log(`\nðŸš€ OAuth Setup using production callback: ${REDIRECT_URI}`);
    console.log('\nðŸ“‹ Steps to complete OAuth setup:');
    console.log('1. Opening browser to Outreach OAuth page');
    console.log('2. Log in to your Outreach account');
    console.log('3. Approve the permissions');
    console.log('4. You will be redirected to your production server');
    console.log('5. Copy the authorization code from the URL and paste it here\n');

    open(authUrl);

    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    rl.question('ðŸ“ Paste the authorization code from the redirect URL: ', async (code) => {
      rl.close();

      try {

        const params = new URLSearchParams({
          client_id: CLIENT_ID,
          client_secret: CLIENT_SECRET,
          redirect_uri: REDIRECT_URI,
          grant_type: 'authorization_code',
          code: code.trim()
        });

        const response = await axios.post(TOKEN_URL, params, {
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        });

        const { access_token, refresh_token, expires_in } = response.data;

        const __dirname = dirname(fileURLToPath(import.meta.url));
        const envPath = join(__dirname, '..', '.env');
        let envContent = fs.readFileSync(envPath, 'utf8');

        if (envContent.includes('OUTREACH_REFRESH_TOKEN=')) {
          envContent = envContent.replace(
            /OUTREACH_REFRESH_TOKEN=.*/,
            `OUTREACH_REFRESH_TOKEN=${refresh_token}`
          );
        } else {
          envContent += `\nOUTREACH_REFRESH_TOKEN=${refresh_token}\n`;
        }

        fs.writeFileSync(envPath, envContent);

        console.log('\nâœ… OAuth setup complete!');
        console.log('ðŸ“ Refresh token saved to .env file');
        console.log(`ðŸ”‘ Access Token: ${access_token.substring(0, 20)}...`);
        console.log(`ðŸ”„ Refresh Token: ${refresh_token.substring(0, 20)}...`);
        console.log(`â° Expires In: ${expires_in} seconds`);
        console.log('\nYou can now run: npm start\n');

        server.close();
        process.exit(0);

      } catch (error) {
        console.error('\nâŒ Error exchanging code for token:', error.response?.data || error.message);
        server.close();
        process.exit(1);
      }
    });
  }
});

NaN
FILE: src/tools.js
SIZE: 11.02 KB | LINES: 472
MODIFIED: 2025-08-21T08:23:20.919Z
NaN

export const tools = [

  {
    name: 'create_prospect',
    description: 'Create a new prospect in Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        firstName: {
          type: 'string',
          description: 'First name of the prospect'
        },
        lastName: {
          type: 'string',
          description: 'Last name of the prospect'
        },
        email: {
          type: 'string',
          description: 'Email address of the prospect'
        },
        company: {
          type: 'string',
          description: 'Company name'
        },
        title: {
          type: 'string',
          description: 'Job title of the prospect'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags to assign to the prospect'
        },
        customFields: {
          type: 'object',
          description: 'Custom fields as key-value pairs'
        }
      },
      required: ['firstName', 'lastName', 'email']
    }
  },

  {
    name: 'search_prospects',
    description: 'Search for prospects based on criteria',
    inputSchema: {
      type: 'object',
      properties: {
        email: {
          type: 'string',
          description: 'Search by email address'
        },
        company: {
          type: 'string',
          description: 'Search by company name'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Search by tags'
        },
        limit: {
          type: 'number',
          description: 'Maximum number of results to return',
          default: 25
        }
      }
    }
  },

  {
    name: 'update_prospect',
    description: 'Update an existing prospect',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: {
          type: 'string',
          description: 'ID of the prospect to update'
        },
        updates: {
          type: 'object',
          description: 'Fields to update',
          properties: {
            firstName: { type: 'string' },
            lastName: { type: 'string' },
            email: { type: 'string' },
            company: { type: 'string' },
            title: { type: 'string' },
            tags: {
              type: 'array',
              items: { type: 'string' }
            },
            customFields: { type: 'object' }
          }
        }
      },
      required: ['prospectId', 'updates']
    }
  },

  {
    name: 'tag_prospect',
    description: 'Add tags to a prospect',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: {
          type: 'string',
          description: 'ID of the prospect'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags to add to the prospect'
        }
      },
      required: ['prospectId', 'tags']
    }
  },

  {
    name: 'get_sequences',
    description: 'Get all sequences from Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Maximum number of sequences to return',
          default: 25
        }
      }
    }
  },

  {
    name: 'find_sequence',
    description: 'Find a sequence by name',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the sequence to find'
        }
      },
      required: ['name']
    }
  },

  {
    name: 'create_sequence',
    description: 'Create a new sequence in Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the sequence'
        },
        description: {
          type: 'string',
          description: 'Description of the sequence'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags for the sequence'
        },
        shareType: {
          type: 'string',
          description: 'Share type: shared (recommended), private, or team',
          enum: ['shared', 'private', 'team'],
          default: 'shared'
        }
      },
      required: ['name']
    }
  },

  {
    name: 'create_sequence_step',
    description: 'Add a step to a sequence (email, call, or task)',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceId: {
          type: 'string',
          description: 'ID of the sequence to add the step to'
        },
        stepType: {
          type: 'string',
          description: 'Type of step: auto_email, manual_email, call, or task',
          enum: ['email', 'auto_email', 'manual_email', 'call', 'task'],
          default: 'auto_email'
        },
        intervalInDays: {
          type: 'number',
          description: 'Days to wait before this step (0 for immediate)',
          default: 0
        },
        taskNote: {
          type: 'string',
          description: 'Note for call/task steps'
        },
        order: {
          type: 'number',
          description: 'Step order in sequence (auto-calculated if not provided)'
        }
      },
      required: ['sequenceId']
    }
  },

  {
    name: 'get_sequence_steps',
    description: 'Get all steps for a sequence',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceId: {
          type: 'string',
          description: 'ID of the sequence'
        }
      },
      required: ['sequenceId']
    }
  },

  {
    name: 'create_sequence_template',
    description: 'Create an email template for sequence steps',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the template'
        },
        subject: {
          type: 'string',
          description: 'Email subject line (use {{first_name}} and {{account.name}} for variables)'
        },
        bodyHtml: {
          type: 'string',
          description: 'HTML email body (primary content)'
        },
        bodyText: {
          type: 'string',
          description: 'Plain text email body (optional fallback)'
        },
        tags: {
          type: 'array',
          items: { type: 'string' },
          description: 'Tags for organizing templates'
        },
        trackLinks: {
          type: 'boolean',
          description: 'Whether to track link clicks',
          default: true
        },
        trackOpens: {
          type: 'boolean',
          description: 'Whether to track email opens',
          default: true
        }
      },
      required: ['name', 'subject']
    }
  },

  {
    name: 'get_sequence_templates',
    description: 'Get all available sequence templates',
    inputSchema: {
      type: 'object',
      properties: {
        limit: {
          type: 'number',
          description: 'Maximum number of templates to return',
          default: 25
        },
        search: {
          type: 'string',
          description: 'Search templates by name or subject'
        }
      }
    }
  },

  {
    name: 'find_sequence_template',
    description: 'Find a template by name',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the template to find'
        }
      },
      required: ['name']
    }
  },

  {
    name: 'update_sequence_template',
    description: 'Update an existing sequence template',
    inputSchema: {
      type: 'object',
      properties: {
        templateId: {
          type: 'string',
          description: 'ID of the template to update'
        },
        updates: {
          type: 'object',
          description: 'Fields to update',
          properties: {
            name: { type: 'string' },
            subject: { type: 'string' },
            bodyText: { type: 'string' },
            bodyHtml: { type: 'string' },
            tags: {
              type: 'array',
              items: { type: 'string' }
            }
          }
        }
      },
      required: ['templateId', 'updates']
    }
  },

  {
    name: 'link_template_to_step',
    description: 'Link an existing template to a sequence step',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceStepId: {
          type: 'string',
          description: 'ID of the sequence step'
        },
        templateId: {
          type: 'string',
          description: 'ID of the template to link'
        }
      },
      required: ['sequenceStepId', 'templateId']
    }
  },

  {
    name: 'add_prospect_to_sequence',
    description: 'Add a prospect to a sequence',
    inputSchema: {
      type: 'object',
      properties: {
        prospectId: {
          type: 'string',
          description: 'ID of the prospect'
        },
        sequenceId: {
          type: 'string',
          description: 'ID of the sequence'
        },
        options: {
          type: 'object',
          description: 'Additional options',
          properties: {
            mailboxId: {
              type: 'string',
              description: 'ID of the mailbox to use for sending'
            }
          }
        }
      },
      required: ['prospectId', 'sequenceId']
    }
  },

  {
    name: 'remove_prospect_from_sequence',
    description: 'Remove a prospect from a sequence',
    inputSchema: {
      type: 'object',
      properties: {
        sequenceStateId: {
          type: 'string',
          description: 'ID of the sequence state to remove'
        }
      },
      required: ['sequenceStateId']
    }
  },

  {
    name: 'create_account',
    description: 'Create a new account in Outreach',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Name of the account/company'
        },
        domain: {
          type: 'string',
          description: 'Company domain'
        },
        industry: {
          type: 'string',
          description: 'Industry category'
        },
        size: {
          type: 'string',
          description: 'Company size'
        },
        customFields: {
          type: 'object',
          description: 'Custom fields as key-value pairs'
        }
      },
      required: ['name']
    }
  },

  {
    name: 'search_accounts',
    description: 'Search for accounts by name or domain',
    inputSchema: {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Search by account name'
        },
        domain: {
          type: 'string',
          description: 'Search by domain'
        }
      }
    }
  },

  {
    name: 'get_mailboxes',
    description: 'Get all available mailboxes',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  },

  {
    name: 'health_check',
    description: 'Check the health status of the MCP server and Outreach API connection',
    inputSchema: {
      type: 'object',
      properties: {}
    }
  }
];

NaN
FILE: test-account-variables.js
SIZE: 3.41 KB | LINES: 97
MODIFIED: 2025-08-21T08:51:22.018Z
NaN

#!/usr/bin/env node

import OutreachClient from './src/outreach-client.js';
import dotenv from 'dotenv';

dotenv.config();

const client = new OutreachClient();

async function exploreAccountVariables() {
  try {
    console.log('ðŸ” Exploring Outreach account variables and custom fields...\n');

    console.log('1. Getting sample account data...');
    const accounts = await client.searchAccounts({});

    if (accounts.data && accounts.data.length > 0) {
      const sampleAccount = accounts.data[0];
      console.log('Sample account structure:');
      console.log(JSON.stringify(sampleAccount, null, 2));

      console.log('\nðŸ“‹ Available account fields for templates:');
      const attributes = sampleAccount.attributes || {};
      Object.keys(attributes).forEach(field => {
        console.log(`- {{account.${field}}} = ${attributes[field]}`);
      });

      const customFields = Object.keys(attributes).filter(key => key.startsWith('custom'));
      if (customFields.length > 0) {
        console.log('\nðŸŽ¯ Custom fields found:');
        customFields.forEach(field => {
          console.log(`- {{account.${field}}} = ${attributes[field]}`);
        });
      } else {
        console.log('\nâš ï¸  No custom fields found in this account');
      }
    }

    console.log('\n2. Checking API types endpoint for field definitions...');
    try {
      const types = await client.client.get('/types');
      console.log('Field definitions available:', !!types.data);

      if (types.data && types.data.data) {
        const accountTypes = types.data.data.filter(type =>
          type.attributes && type.attributes.name === 'account'
        );
        if (accountTypes.length > 0) {
          console.log('Account field types:', JSON.stringify(accountTypes[0], null, 2));
        }
      }
    } catch (typeError) {
      console.log('Types endpoint not accessible:', typeError.message);
    }

    console.log('\n3. Common account variables you can likely use:');
    const commonVars = [
      'account.name',
      'account.domain',
      'account.industry',
      'account.description',
      'account.employees',
      'account.revenue',
      'account.custom1',
      'account.custom2',
      'account.custom3',
      'account.custom4',
      'account.custom5'
    ];

    commonVars.forEach(variable => {
      console.log(`- {{${variable}}}`);
    });

  } catch (error) {
    console.error('âŒ Error exploring account variables:', error.message);

    console.log('\nðŸ“š Based on Outreach documentation, these variables should work:');
    console.log('Standard account fields:');
    console.log('- {{account.name}} - Account name');
    console.log('- {{account.domain}} - Account domain');
    console.log('- {{account.industry}} - Account industry');
    console.log('- {{account.description}} - Account description');
    console.log('- {{account.employees}} - Number of employees');
    console.log('- {{account.revenue}} - Annual revenue');
    console.log('\nCustom fields (if configured):');
    console.log('- {{account.custom1}} through {{account.custom50}}');
    console.log('- Custom field names depend on your Outreach setup');
  }
}

exploreAccountVariables();

NaN
FILE: test-atomic-creation.js
SIZE: 7.83 KB | LINES: 239
MODIFIED: 2025-08-21T07:55:47.700Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testAtomicCreation() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('âš¡ Creating complete sequence with template in atomic operation...');

    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Atomic Creation Test ' + Date.now(),
          description: 'Testing atomic creation of sequence with templates',
          shareType: 'shared'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    const templates = [];
    for (let i = 1; i <= 3; i++) {
      const templatePayload = {
        data: {
          type: 'template',
          attributes: {
            name: `Email ${i} Template ${Date.now()}`,
            subject: `Step ${i}: Important message for {{prospect.firstName}}`,
            bodyHtml: `
              <!DOCTYPE html>
              <html>
              <body style="font-family: Arial, sans-serif;">
                <h2>Email ${i} in Sequence</h2>
                <p>Hi {{prospect.firstName}},</p>
                <p>This is email number ${i} in our sequence.</p>
                <p>Best regards,<br>{{sender.firstName}}</p>
              </body>
              </html>
            `,
            shareType: 'shared',
            archived: false,
            trackLinks: true,
            trackOpens: true
          }
        }
      };

      const templateResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      templates.push({
        id: templateResponse.data.data.id,
        name: templateResponse.data.data.attributes.name
      });
      console.log(`âœ… Template ${i} created:`, templateResponse.data.data.id);
    }

    const steps = [];
    const stepTimings = [0, 1440, 4320];

    for (let i = 0; i < 3; i++) {
      const stepPayload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: i + 1,
            interval: stepTimings[i]
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      steps.push({
        id: stepResponse.data.data.id,
        order: i + 1
      });
      console.log(`âœ… Step ${i + 1} created:`, stepResponse.data.data.id);
    }

    console.log('\nðŸ”— Linking all templates to steps immediately...');
    const sequenceTemplates = [];

    for (let i = 0; i < 3; i++) {
      const linkPayload = {
        data: {
          type: 'sequenceTemplate',
          relationships: {
            sequenceStep: {
              data: {
                type: 'sequenceStep',
                id: steps[i].id.toString()
              }
            },
            template: {
              data: {
                type: 'template',
                id: templates[i].id.toString()
              }
            }
          }
        }
      };

      const linkResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      sequenceTemplates.push(linkResponse.data.data.id);
      console.log(`âœ… Template ${i + 1} linked to step ${i + 1}:`, linkResponse.data.data.id);
    }

    console.log('\nðŸ” Immediate verification of all steps...');
    for (let i = 0; i < 3; i++) {
      const stepCheck = await axios.get(
        `https:
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/vnd.api+json',
            'Accept': 'application/vnd.api+json'
          }
        }
      );

      const hasTemplates = stepCheck.data.data.relationships.sequenceTemplates?.data?.length > 0;
      console.log(`Step ${i + 1} has templates: ${hasTemplates}`);

      if (hasTemplates && stepCheck.data.included) {
        const template = stepCheck.data.included.find(item => item.type === 'template');
        if (template) {
          console.log(`  â””â”€ Template: "${template.attributes.name}"`);
        }
      }
    }

    console.log('\nâ±ï¸  Waiting 5 seconds and checking again...');
    await new Promise(resolve => setTimeout(resolve, 5000));

    for (let i = 0; i < 3; i++) {
      const stepCheck = await axios.get(
        `https:
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/vnd.api+json',
            'Accept': 'application/vnd.api+json'
          }
        }
      );

      console.log(`Step ${i + 1} after delay - attributes keys:`, Object.keys(stepCheck.data.data.attributes));
    }

    console.log('\nðŸ“Š ATOMIC CREATION SUMMARY');
    console.log('==========================');
    console.log(`Sequence: ${sequenceId}`);
    console.log(`Templates: ${templates.map(t => t.id).join(', ')}`);
    console.log(`Steps: ${steps.map(s => s.id).join(', ')}`);
    console.log(`SequenceTemplates: ${sequenceTemplates.join(', ')}`);

    console.log('\nðŸŒ CRITICAL TEST:');
    console.log(`https:
    console.log('\nIf templates STILL don\'t show after this atomic creation:');
    console.log('1. The issue is not timing/order related');
    console.log('2. The issue is not in the linking process');
    console.log('3. The issue is likely in a missing API field or different resource');
    console.log('4. We may need to investigate mailings or other resources');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testAtomicCreation();

NaN
FILE: test-complete-sequence.js
SIZE: 6.96 KB | LINES: 219
MODIFIED: 2025-08-21T07:38:10.357Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testCompleteSequence() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ” Checking existing templates structure...');
    const existingTemplates = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    if (existingTemplates.data.data.length > 0) {
      console.log('Example template attributes:', Object.keys(existingTemplates.data.data[0].attributes));
      console.log('First template:', {
        name: existingTemplates.data.data[0].attributes.name,
        archived: existingTemplates.data.data[0].attributes.archived,
        shareType: existingTemplates.data.data[0].attributes.shareType
      });
    }

    console.log('\nðŸ“ Creating comprehensive template...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Complete Template ' + Date.now(),
          subject: 'Important: {{prospect.firstName}}, this is for you',
          bodyHtml: `<!DOCTYPE html>
<html>
<head>
<style>
body { font-family: Arial, sans-serif; }
.container { padding: 20px; }
</style>
</head>
<body>
<div class="container">
<p>Hi {{prospect.firstName}},</p>
<p>This is a complete email template with full HTML content.</p>
<p>Best regards,<br>{{sender.firstName}}</p>
</div>
</body>
</html>`,
          shareType: 'shared',
          archived: false,
          trackLinks: true,
          trackOpens: true,
          toRecipients: ['{{prospect.email}}'],
          ccRecipients: [],
          bccRecipients: []
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const templateId = templateResponse.data.data.id;
    console.log('âœ… Template created:', templateId);
    console.log('Template attributes:', Object.keys(templateResponse.data.data.attributes));

    console.log('\nðŸ“‹ Creating sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Complete Sequence Test ' + Date.now(),
          description: 'Testing complete template integration',
          shareType: 'shared',
          sequenceType: 'interval'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    console.log('\nðŸ“§ Creating multiple sequence steps...');

    const steps = [
      { order: 1, interval: 0, name: 'Initial Email' },
      { order: 2, interval: 1440, name: 'Day 1 Follow-up' },
      { order: 3, interval: 4320, name: 'Day 3 Follow-up' }
    ];

    const stepIds = [];
    for (const step of steps) {
      const stepPayload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: step.order,
            interval: step.interval,

          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      stepIds.push(stepResponse.data.data.id);
      console.log(`âœ… Step ${step.order} created:`, stepResponse.data.data.id);
    }

    console.log('\nðŸ”— Linking template to first step...');
    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        attributes: {

        },
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepIds[0].toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    const linkResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Template linked to step 1');

    console.log('\nðŸ“Š Final Summary:');
    console.log('================');
    console.log(`Sequence: ${sequenceId}`);
    console.log(`Template: ${templateId}`);
    console.log(`Steps: ${stepIds.join(', ')}`);
    console.log(`SequenceTemplate: ${linkResponse.data.data.id}`);
    console.log('\nðŸŒ View in Outreach:');
    console.log(`https:
    console.log('\nâš ï¸  Check if the template appears in step 1 in the UI');
    console.log('If not visible, you may need to:');
    console.log('1. Enable/activate the template in Outreach settings');
    console.log('2. Set template as "shared" instead of "private"');
    console.log('3. Use a different template type or category');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testCompleteSequence();

NaN
FILE: test-connection.js
SIZE: 2.08 KB | LINES: 69
MODIFIED: 2025-08-19T14:00:23.278Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testConnection() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('ðŸ“ Fetching current user...');
    const userResponse = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json'
      },
      params: {
        'page[limit]': 1
      }
    });

    console.log('âœ… API connection successful!');
    console.log('ðŸ‘¤ User:', userResponse.data.data[0]?.attributes?.email || 'No user found');

    console.log('\nðŸ“ Fetching sequences...');
    const sequenceResponse = await axios.get('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json'
      },
      params: {
        'page[limit]': 3
      }
    });

    console.log(`âœ… Found ${sequenceResponse.data.data.length} sequences`);
    sequenceResponse.data.data.forEach(seq => {
      console.log(`  - ${seq.attributes.name}`);
    });

    console.log('\nðŸŽ‰ All tests passed! Your MCP server is ready to use.');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testConnection();

NaN
FILE: test-create-sequence.js
SIZE: 1.92 KB | LINES: 65
MODIFIED: 2025-08-19T14:10:00.265Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testCreateSequence() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('ðŸ“ Attempting to create test sequence...');

    const payload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Test Sequence via MCP ' + Date.now(),
          description: 'Test sequence created via MCP server',
          shareType: 'private'
        }
      }
    };

    const response = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Sequence created successfully!');
    console.log('ðŸ“Š Response:', JSON.stringify(response.data, null, 2));

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);

    if (error.response?.status === 403) {
      console.error('\nðŸ”’ Permission Error: Your app may need additional scopes.');
      console.error('Make sure your Outreach OAuth app has WRITE permissions for sequences.');
    }
  }
}

testCreateSequence();

NaN
FILE: test-different-step-approaches.js
SIZE: 8.96 KB | LINES: 283
MODIFIED: 2025-08-21T07:54:43.430Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testDifferentStepApproaches() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ“‹ Creating sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Different Approaches Test ' + Date.now(),
          description: 'Testing different ways to create steps with content',
          shareType: 'shared'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    console.log('\nðŸ§ª TEST 1: Creating unnamed template...');
    try {
      const unnamedTemplatePayload = {
        data: {
          type: 'template',
          attributes: {

            subject: 'Unnamed Template Subject {{prospect.firstName}}',
            bodyHtml: '<p>This is an unnamed template for {{prospect.firstName}}</p>',
            shareType: 'shared',
            archived: false
          }
        }
      };

      const unnamedTemplateResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Unnamed template created:', unnamedTemplateResponse.data.data.id);
      console.log('Template name:', unnamedTemplateResponse.data.data.attributes.name);
    } catch (error) {
      console.log('âŒ Failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ§ª TEST 2: Creating template and step together...');

    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Inline Template ' + Date.now(),
          subject: 'Inline Subject {{prospect.firstName}}',
          bodyHtml: '<h1>Inline Content</h1><p>This should work for {{prospect.firstName}}</p>',
          shareType: 'shared',
          archived: false
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const templateId = templateResponse.data.data.id;

    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const stepId = stepResponse.data.data.id;

    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    const linkResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Template and step created together, sequenceTemplate:', linkResponse.data.data.id);

    console.log('\nðŸ§ª TEST 3: Investigating mailing relationship...');

    const stepCheck = await axios.get(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('Step relationships keys:', Object.keys(stepCheck.data.data.relationships));
    if (stepCheck.data.data.relationships.mailings) {
      console.log('Mailings relationship:', stepCheck.data.data.relationships.mailings);
    }

    console.log('\nðŸ§ª TEST 4: Checking sequence-level template relationships...');
    const sequenceCheck = await axios.get(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('Sequence relationships keys:', Object.keys(sequenceCheck.data.data.relationships || {}));

    console.log('\nðŸ§ª TEST 5: Trying manual_email stepType...');
    try {
      const manualStepPayload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'manual_email',
            order: 2,
            interval: 1440
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const manualStepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Manual email step created:', manualStepResponse.data.data.id);

      const manualLinkPayload = {
        data: {
          type: 'sequenceTemplate',
          relationships: {
            sequenceStep: {
              data: {
                type: 'sequenceStep',
                id: manualStepResponse.data.data.id.toString()
              }
            },
            template: {
              data: {
                type: 'template',
                id: templateId.toString()
              }
            }
          }
        }
      };

      await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Template linked to manual email step');
    } catch (error) {
      console.log('âŒ Manual email step failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ“Š SUMMARY');
    console.log('================');
    console.log(`Sequence: ${sequenceId}`);
    console.log(`Template: ${templateId}`);
    console.log('\nðŸŒ Check this URL:');
    console.log(`https:
    console.log('\nLook specifically for differences between:');
    console.log('- Step 1 (auto_email)');
    console.log('- Step 2 (manual_email)');
    console.log('- Whether templates appear in either case');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testDifferentStepApproaches();

NaN
FILE: test-enable-sequence.js
SIZE: 6.51 KB | LINES: 210
MODIFIED: 2025-08-21T07:44:37.791Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testEnableSequence() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ“ Creating template...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Enable Test Template ' + Date.now(),
          subject: 'This should show: {{prospect.firstName}}',
          bodyHtml: '<h1>Hello {{prospect.firstName}}!</h1><p>This template should appear in the enabled sequence.</p>',
          shareType: 'shared',
          archived: false,
          trackLinks: true,
          trackOpens: true
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const templateId = templateResponse.data.data.id;
    console.log('âœ… Template created:', templateId);

    console.log('\nðŸ“‹ Creating sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Enable Test Sequence ' + Date.now(),
          description: 'Testing if enabling sequence shows templates',
          shareType: 'shared'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    console.log('\nðŸ“§ Creating sequence step...');
    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const stepId = stepResponse.data.data.id;
    console.log('âœ… Step created:', stepId);

    console.log('\nðŸ”— Linking template to step...');
    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Template linked to step');

    console.log('\nâš¡ Enabling sequence...');
    try {
      const enablePayload = {
        data: {
          type: 'sequence',
          id: sequenceId.toString(),
          attributes: {
            enabled: true
          }
        }
      };

      const enableResponse = await axios.patch(`https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Sequence enabled successfully!');
      console.log('Enabled status:', enableResponse.data.data.attributes.enabled);
    } catch (error) {
      console.log('âŒ Failed to enable sequence:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ“Š Final state check...');
    const finalCheck = await axios.get(
      `https:
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      }
    );

    const hasTemplates = finalCheck.data.data.relationships.sequenceTemplates?.data?.length > 0;
    console.log('Step has templates:', hasTemplates);

    if (hasTemplates && finalCheck.data.included) {
      const template = finalCheck.data.included.find(item => item.type === 'template');
      if (template) {
        console.log('Template linked:', template.attributes.name);
        console.log('Template subject:', template.attributes.subject);
      }
    }

    console.log('\nðŸŒ IMPORTANT: Check this URL in Outreach:');
    console.log(`https:
    console.log('\nLook to see if the template appears in Step 1 after enabling the sequence.');
    console.log('If it still doesn\'t show, the issue might be:');
    console.log('1. Templates need to be assigned through a different mechanism');
    console.log('2. The UI requires manual template selection regardless of API links');
    console.log('3. There\'s a separate "default template" setting required');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testEnableSequence();

NaN
FILE: test-mcp.js
SIZE: 2.27 KB | LINES: 83
MODIFIED: 2025-08-18T10:25:02.386Z
NaN

#!/usr/bin/env node

import { spawn } from 'child_process';
import { config } from 'dotenv';

config();

console.log('ðŸ§ª Testing MCP Outreach Server...\n');

const testMCPServer = () => {
  return new Promise((resolve, reject) => {
    console.log('ðŸ“¡ Starting MCP server...');

    const mcpServer = spawn('node', ['dist/index.js'], {
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let output = '';
    let errorOutput = '';

    mcpServer.stdout.on('data', (data) => {
      output += data.toString();
      console.log('ðŸ“ Server output:', data.toString().trim());
    });

    mcpServer.stderr.on('data', (data) => {
      errorOutput += data.toString();
      console.log('âš ï¸ Server stderr:', data.toString().trim());

      if (data.toString().includes('MCP Outreach server running')) {
        console.log('âœ… MCP server is running!\n');

        console.log('ðŸ”§ Testing list_tools request...');
        const listToolsRequest = {
          jsonrpc: '2.0',
          id: 1,
          method: 'tools/list'
        };

        mcpServer.stdin.write(JSON.stringify(listToolsRequest) + '\n');

        setTimeout(() => {
          mcpServer.kill();
          resolve({ output, errorOutput });
        }, 5000);
      }
    });

    mcpServer.on('error', (error) => {
      console.error('âŒ Failed to start MCP server:', error);
      reject(error);
    });

    setTimeout(() => {
      mcpServer.kill();
      reject(new Error('Test timed out'));
    }, 30000);
  });
};

testMCPServer()
  .then(({ output, errorOutput }) => {
    console.log('\nðŸ“Š Test Results:');
    console.log('âœ… MCP server started successfully');
    if (output.includes('tools')) {
      console.log('âœ… Tools endpoint responded');
    }
    if (errorOutput.includes('OAuth') || errorOutput.includes('token')) {
      console.log('âš ï¸ OAuth flow initiated (expected for first run)');
    }
  })
  .catch((error) => {
    console.error('\nâŒ Test failed:', error.message);
    process.exit(1);
  });

NaN
FILE: test-sequence-steps.js
SIZE: 3.66 KB | LINES: 128
MODIFIED: 2025-08-19T14:52:54.169Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testSequenceSteps() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('ðŸ“ Creating test sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Test Sequence with Steps ' + Date.now(),
          description: 'Testing sequence step creation',
          shareType: 'private'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Created sequence ID:', sequenceId);

    console.log('ðŸ“§ Adding email step to sequence...');
    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Created sequence step successfully!');
    console.log('ðŸ“Š Step Details:', {
      id: stepResponse.data.data.id,
      stepType: stepResponse.data.data.attributes.stepType,
      order: stepResponse.data.data.attributes.order,
      subject: stepResponse.data.data.attributes.subject
    });

    console.log('ðŸ“§ Adding follow-up email step...');
    const followupPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 2,
          interval: 4320
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const followupResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Created follow-up step successfully!');
    console.log('ðŸŽ‰ Sequence with steps is ready!');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
  }
}

testSequenceSteps();

NaN
FILE: test-step-content.js
SIZE: 2.92 KB | LINES: 100
MODIFIED: 2025-08-20T06:54:32.055Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testSequenceStepContent() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('ðŸ“ Creating test sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Test Step Content ' + Date.now(),
          description: 'Testing sequence step email content',
          shareType: 'private'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Created sequence ID:', sequenceId);

    console.log('ðŸ“§ Testing sequence step with email content...');
    const stepWithContentPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0,
          subject: 'Direct subject in step',
          bodyHtml: '<p>Direct HTML content in step</p>',
          bodyText: 'Direct text content in step'
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Created step with direct content!');
    console.log('ðŸ“Š Step attributes:', stepResponse.data.data.attributes);

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);

    if (error.response?.data?.errors) {
      error.response.data.errors.forEach(err => {
        console.error(`ðŸ“ ${err.title}: ${err.detail}`);
      });
    }
  }
}

testSequenceStepContent();

NaN
FILE: test-template-linking-methods.js
SIZE: 10.57 KB | LINES: 351
MODIFIED: 2025-08-21T07:43:15.518Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testTemplateLinkingMethods() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token\n');

    console.log('ðŸ“ Creating template...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Test Linking Template ' + Date.now(),
          subject: 'Test Subject {{prospect.firstName}}',
          bodyHtml: '<p>Test content for {{prospect.firstName}}</p>',
          shareType: 'shared',
          archived: false,
          trackLinks: true,
          trackOpens: true
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const templateId = templateResponse.data.data.id;
    console.log('âœ… Template created:', templateId);

    console.log('\nðŸ“‹ Creating sequence...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Test Template Linking ' + Date.now(),
          description: 'Testing different template linking methods',
          shareType: 'shared'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Sequence created:', sequenceId);

    console.log('\nðŸ§ª TEST 1: Creating step with template relationship...');
    try {
      const stepWithTemplatePayload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: 1,
            interval: 0
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            },
            template: {
              data: {
                type: 'template',
                id: templateId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Step created with template relationship!');
      console.log('Step ID:', stepResponse.data.data.id);
      console.log('Relationships:', JSON.stringify(stepResponse.data.data.relationships, null, 2));
    } catch (error) {
      console.log('âŒ Failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ§ª TEST 2: Creating step with emailTemplateId attribute...');
    try {
      const stepWithEmailTemplateId = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: 2,
            interval: 1440,
            emailTemplateId: templateId.toString()
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Step created with emailTemplateId!');
      console.log('Step ID:', stepResponse.data.data.id);
    } catch (error) {
      console.log('âŒ Failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ§ª TEST 3: Creating step with templateId attribute...');
    try {
      const stepWithTemplateId = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: 3,
            interval: 2880,
            templateId: templateId.toString()
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Step created with templateId!');
      console.log('Step ID:', stepResponse.data.data.id);
    } catch (error) {
      console.log('âŒ Failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ§ª TEST 4: Create step then PATCH with template...');
    try {

      const plainStepPayload = {
        data: {
          type: 'sequenceStep',
          attributes: {
            stepType: 'auto_email',
            order: 4,
            interval: 4320
          },
          relationships: {
            sequence: {
              data: {
                type: 'sequence',
                id: sequenceId.toString()
              }
            }
          }
        }
      };

      const stepResponse = await axios.post('https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      const stepId = stepResponse.data.data.id;
      console.log('Step created:', stepId);

      const patchPayload = {
        data: {
          type: 'sequenceStep',
          id: stepId.toString(),
          relationships: {
            template: {
              data: {
                type: 'template',
                id: templateId.toString()
              }
            }
          }
        }
      };

      const patchResponse = await axios.patch(`https:
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      });

      console.log('âœ… Step patched with template!');
    } catch (error) {
      console.log('âŒ Failed:', error.response?.data?.errors?.[0]?.detail || error.message);
    }

    console.log('\nðŸ§ª TEST 5: Checking sequenceTemplate impact...');
    const plainStep = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 5,
          interval: 5760
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const finalStepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const finalStepId = finalStepResponse.data.data.id;

    const seqTemplatePayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: finalStepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const verifyResponse = await axios.get(
      `https:
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/vnd.api+json',
          'Accept': 'application/vnd.api+json'
        }
      }
    );

    console.log('Step with sequenceTemplate:');
    console.log('- Has sequenceTemplates:', verifyResponse.data.data.relationships.sequenceTemplates?.data?.length > 0);
    console.log('- Included resources:', verifyResponse.data.included?.map(r => r.type));

    console.log('\nðŸ“Š SUMMARY');
    console.log('===========');
    console.log(`Sequence: ${sequenceId}`);
    console.log(`Template: ${templateId}`);
    console.log('\nðŸŒ Check in Outreach UI:');
    console.log(`https:
    console.log('\nLook for which steps (if any) have the template automatically assigned.');

  } catch (error) {
    console.error('âŒ Unexpected error:', error.response?.data || error.message);
  }
}

testTemplateLinkingMethods();

NaN
FILE: test-templates.js
SIZE: 4.94 KB | LINES: 173
MODIFIED: 2025-08-19T15:22:09.502Z
NaN

import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const REFRESH_TOKEN = process.env.OUTREACH_REFRESH_TOKEN;
const CLIENT_ID = process.env.OUTREACH_CLIENT_ID;
const CLIENT_SECRET = '3~uWIul|6x~MS6b8>#O1b_tN<V|#H2~O$wR&QsA#N@<';

async function testTemplates() {
  try {

    console.log('ðŸ”„ Getting access token...');
    const tokenResponse = await axios.post('https:
      new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: REFRESH_TOKEN,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      }), {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }
    );

    const accessToken = tokenResponse.data.access_token;
    console.log('âœ… Got access token');

    console.log('ðŸ“ Creating email template...');
    const templatePayload = {
      data: {
        type: 'template',
        attributes: {
          name: 'Welcome Email Template ' + Date.now(),
          subject: 'Welcome to our platform, {{prospect.firstName}}!',
          bodyHtml: `<p>Hi {{prospect.firstName}},</p>

<p>Welcome to our platform! We're excited to have you on board.</p>

<p>Here's what you can expect:</p>
<ul>
  <li>Personalized onboarding</li>
  <li>24/7 support</li>
  <li>Access to exclusive resources</li>
</ul>

<p>Best regards,<br>
The Team</p>

<p><em>P.S. If you have any questions, just reply to this email!</em></p>`,
          trackLinks: true,
          trackOpens: true
        }
      }
    };

    const templateResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Template created successfully!');
    console.log('ðŸ“Š Template Details:', {
      id: templateResponse.data.data.id,
      name: templateResponse.data.data.attributes.name,
      subject: templateResponse.data.data.attributes.subject
    });

    const templateId = templateResponse.data.data.id;

    console.log('\nðŸ“ Creating sequence with template...');
    const sequencePayload = {
      data: {
        type: 'sequence',
        attributes: {
          name: 'Template-based Sequence ' + Date.now(),
          description: 'Testing template linking',
          shareType: 'private'
        }
      }
    };

    const sequenceResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const sequenceId = sequenceResponse.data.data.id;
    console.log('âœ… Created sequence ID:', sequenceId);

    console.log('ðŸ“§ Adding email step to sequence...');
    const stepPayload = {
      data: {
        type: 'sequenceStep',
        attributes: {
          stepType: 'auto_email',
          order: 1,
          interval: 0
        },
        relationships: {
          sequence: {
            data: {
              type: 'sequence',
              id: sequenceId.toString()
            }
          }
        }
      }
    };

    const stepResponse = await axios.post('https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    const stepId = stepResponse.data.data.id;
    console.log('âœ… Created step ID:', stepId);

    console.log('ðŸ”— Linking template to step via sequenceTemplate...');
    const linkPayload = {
      data: {
        type: 'sequenceTemplate',
        relationships: {
          sequenceStep: {
            data: {
              type: 'sequenceStep',
              id: stepId.toString()
            }
          },
          template: {
            data: {
              type: 'template',
              id: templateId.toString()
            }
          }
        }
      }
    };

    const linkResponse = await axios.post(`https:
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      }
    });

    console.log('âœ… Template linked successfully!');
    console.log('ðŸŽ‰ Complete sequence with email template is ready!');

  } catch (error) {
    console.error('âŒ Error:', error.response?.data || error.message);
    if (error.response?.status === 403) {
      console.error('\nðŸ”’ Permission Error: Your app may need templates.all scope.');
    }
  }
}

testTemplates();

NaN
FILE: tsconfig.json
SIZE: 457 B | LINES: 19
MODIFIED: 2025-08-14T20:40:50.670Z
NaN

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

NaN
FLATTENING STATISTICS
NaN
Files processed: 70
Lines processed: 15,895
Bytes processed: 470.6 KB
Comments removed: 0 lines
Whitespace optimized: 5.27 KB
Generated: 2025-09-01T09:38:59.646Z
Processing time: 71ms
NaN